密码题型总结
模的性质
同余：

若​，则称a与b在模p意义下同余，记作

​

对称性：

​等价于​。

传递性：

若​且​，则​

结合律：

​

交换律：

​

分配律：

​

同时取模运算和四则运算类似，有一点例外是除法，你会发现我们所涉及的所有数都是正整数，我们不关心分数和负数，在整数模运算中，除一个数应该写（说）成乘上该数的逆元素。

在同余的情况下中，你可以将所有的操作都看作是整数的四则运算，不用关心运算过程中的取模，同理在做题时，如果涉及到要自己推式子，都可以按此操作，只需要记得最后取模即可

image-20241209192357936

仿射密码
介绍
仿射密码（Affine Cipher） 是一种古典加密方法，它基于线性代数中的仿射变换。它是替代密码的一种类型，其中每个字母被映射到一个数字，并通过线性函数进行加密和解密。具体来说，放射密码使用了两个线性变换参数a和b，并且加密和解密过程依赖于模运算。

放射密码的加密公式如下：​
其中：m是明文对应的数字，a和b（任意数，通常我们选择0<=b<n）是密钥，其中a和模n互素（即gcd(a,n)=1，确保a有模反元素），n是字母表的大小（字母表可以是26个英文字母表，有时也是base64d的编码表，也可能是其他）。我们需要找出在 1 到 n之间（因为 a的值不能为 0）的与 n互素的数。

例：假设n是26，通过计算，a∈{1,3,5,7,9,11,15,17,19,21,23,25}，任意挑以一个作为密钥就行，计算过程如此：

解密过程：​

暴力破解仿射密码(假设n为26)：
放射密码的密钥包括两个参数：a和 b。

a的可能值：如前所述，a必须满足与26互素的条件，在1到25之间，符合条件的a有12个。
b的可能值：b的值可以是任意从0到25的整数，因为它是一个平移量。
因此，密钥空间的大小是 12×26=312，这意味着总共有 312 种不同的密钥组合。
密钥空间较小，利于爆破。

例题：
题目：base64

给了一段字符串：xdcJgpIwTJIACecJ/dgjPtTR/7UFpdEFgr0s1r/AUacMHrP8y6UZUa/0DLPJDp8ZH6M7y6HaDaIMl6PADasIDur3

由题目我们联想到仿射密码的映射表是base64，利用暴力破解仿射密码。

EXP
1
import base64
2
​
3
# Base64字符表及索引映射
4
base64_table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
5
base64_index = {c: i for i, c in enumerate(base64_table)}  # 修正为字典推导式
6
​
7
# 密文
8
ciphertext = "xdcJgpIwTJIACecJ/dgjPtTR/7UFpdEFgr0s1r/AUacMHrP8y6UZUa/0DLPJDp8ZH6M7y6HaDaIMl6PADasIDur3"
9
​
10
# 遍历可能的仿射密码参数 a（必须为奇数）
11
possible_a = [a for a in range(1, 64, 2)]
12
​
13
found = False  # 标记是否找到Flag
14
​
15
for a in possible_a:
16
    try:
17
        a_inv = pow(a, -1, 64)  # 计算a的模64逆元
18
    except ValueError:
19
        continue  # 若逆元不存在则跳过
20
​
21
    for b in range(64):
22
        decrypted = []
23
        # 逐字符解密
24
        for c in ciphertext:
25
            x = base64_index[c]  # 获取密文字符的索引
26
            decrypted_x = (a_inv * (x - b)) % 64  # 仿射解密公式
27
            decrypted_char = base64_table[decrypted_x]
28
            decrypted.append(decrypted_char)
29
​
30
        # 补充Base64填充字符"="（长度必须为4的倍数）
31
        decrypted_b64 = ''.join(decrypted)
32
        missing_padding = len(decrypted_b64) % 4
33
        if missing_padding:
34
            decrypted_b64 += '=' * (4 - missing_padding)
35
​
36
        # 尝试解码并输出
37
        try:
38
            decoded_bytes = base64.b64decode(decrypted_b64)
39
            decoded_str = decoded_bytes.decode('utf-8')
40
            # 输出可能的候选结果
41
            print(f"尝试 a={a}, b={b} 解密结果: {decoded_str}")
42
            found = True
43
        except Exception as e:
44
            # 调试时可取消注释以下行查看错误信息
45
            # print(f"a={a}, b={b} 失败: {str(e)}")
46
            continue
47
​
48
if not found:
49
    print("未找到有效Flag，请检查输入或扩大参数范围。")
RSA
1.素数分解
1.素数分解工具：yafu

2.素数分解网站：factordb.com

（注：二者本质上不同yafu是计算，而网站是寻找库中匹配的n，撞库）

2.p、q很接近
<1>明显的一个特征：
1
p = getPrime(512)
2
q = gmpy2.next_prime(p)
解题：

1
1.
2
sn = isqrt(n)
3
q = next_prime(sn)
4
p = n // q
5
#isqrt 的函数，用于计算一个非负整数的整数平方根。这个函数返回的是不大于输入值的最大整数 n，使得 n * n 小于或等于输入值。与直接使用浮点数平方根不同，isqrt 只处理整数，因此它不会引入浮点数的精度问题。
6
#sqrt函数需：from gmpy2 import *
7
​
8
2.
9
sn=gmpy2.iroot(n,2)[0]  
10
p=gmpy2.next_prime(sn)
11
q=n//p
12
#iroot(n, k) 函数返回一个元组，其中第一个元素是 n 的整数 k 次根，第二个元素是一个布尔值，指示结果是否是精确的整数根。
13
#例如，gmpy2.iroot(n, 2)[0] 返回 n 的整数平方根
14
​
15
3.费马分解
16
def factor(n):
17
    a = gmpy2.iroot(n, 2)[0]
18
    while 1:
19
        B2 = pow(a, 2) - n
20
        if gmpy2.is_square(B2):
21
            b = gmpy2.iroot(B2, 2)[0]
22
            p = a + b
23
            q = a - b
24
            return p, q
25
        a += 1  # 千万别忘了a的自增步长为1
26
 
27
p,q=factor(n)
28
#解释：令a是n的"中间值"（\sqrt{n}),然后让a以步长为1自增遍历，直到pow(a,2)-n的结果可以正好开方为止。那个结果开方就是b。
29
#p=a-b,q=a+b,n=pq即n=a^2-b^2,
30
#b^2=n-a^2
31
#令a的起始值为√n
法4费马分解解释：

对于一个奇合数n = p ⋅ q ，可以写成一个平方差：
               ​

费马质因数分解算法，就是不停地循环尝试，找到两个数：
               ​

找到这两个数之后a + b和a-b就是p和q了。我们知道​.我们让a从​开始尝试，不断+1，直到​是一个平方数为止.

例题：
1
from Crypto.Util.number import *
2
import gmpy2
3
flag = b'NSSCTF{******}'
4
​
5
p = getPrime(512)
6
q = gmpy2.next_prime(p - getPrime(256))
7
n = p*q
8
e = 65537
9
phi = (p-1)*(q-1)
10
m = bytes_to_long(flag)
11
c = pow(m, e, n)
12
​
13
print(f'n = {n}')
14
print(f'e = {e}')
15
print(f'c = {c}')
16
​
17
n = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117
18
e = 65537
19
c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932
20
​
我们看到

1
p = getPrime(512)
2
q = gmpy2.next_prime(p - getPrime(256))
这里并不是简单的p、q很接近，q是（p-一个256位素数）的下一个素数。

EXP
1
import gmpy2,sympy
2
from Cryptodome.Util.number import *
3
from gmpy2 import *
4
​
5
​
6
def factor(n):
7
    a = gmpy2.iroot(n, 2)[0]
8
    while 1:
9
        B2 = pow(a, 2) - n
10
        if gmpy2.is_square(B2):
11
            b = gmpy2.iroot(B2, 2)[0]
12
            p = a + b
13
            q = a - b
14
            return p, q
15
        a += 1  # 千万别忘了a的自增步长为1
16
n = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117
17
e = 65537
18
c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932
19
p, q = factor(n)
20
print("p=",p)
21
print("q=",q)
22
phi=(p-1)*(q-1)
23
d = gmpy2.invert(e,(p-1)*(q-1))
24
​
25
m = pow(c,d,n)
26
print(long_to_bytes(m))
3.共享素数
<1>.明显特征：
1
n1 = p1*q
2
n2 = p2*q
3
​
4
e = 65537
5
​
6
m = bytes_to_long(flag)
7
c1 = pow(m, e, n1)
8
c2 = pow(m, e, n2)
9
   ........
10
​
11
n1 = 143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893
12
n2 = 138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169
13
e = 65537
14
c1 = 54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029
15
c2 = 122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736
16
​
我们看到有两个n：n1,n2,
但这两个n都有一个相同的素数q，即这是这二者的公因子，又因为n1,n2每个数都只有两个因子，则q还是二者的最大公因数，我们可以使用GCD或gmpy2包中的gcd函数进行求解。

当我们得到了q，便可以用整除n1,n2得到剩下的因子，但是因为二者都对flag进行了加密，我们只需要解密任意一个值即可，不过值得注意的是，若是使用n1的加密值，则需要用p1和q，以及取模时要模n1，不要混淆了各个数字。

EXP
1
from gmpy2 import *
2
q = gcd(n1, n2)#求共享素数
3
p1 = n1 // q
4
phi = (p1-1)*(q-1)
5
d = invert(e, phi)
6
​
7
m = pow(c1, d, n1)
8
print(long_to_bytes(m))
4.不止p,q
明显特征
<1>.

p = getPrime(512)
q = getPrime(512)
r = getPrime(512)
n = p*q*r
e = 65537
phi = (p-1)*(q-1)*(r-1)
题目中直接给了phi的过程，是三个欧拉函数相乘。

<2>.

from Cryptodome.Util.number import *
from secret import key


key=b'HYNUCTF{fake_flag_luelueluexxxx}'

m = bytes_to_long(key)
n = 1
for i in range(10):
    n *=getPrime(32)
e = 65537
c = pow(m,e,n)
print(f'n = {n}')
print(f'c = {c}')

n = 232966361816112569912041563518884558765070460996111828077964142640807456237834636317137285755707
c = 213905036857211268695822160923947943427584682494038145315201916836430023905384084154369548813723
题目中给了加密过程，n是由10个32位的素数相乘，分解n得到10个素数，改变phi的求法即可。

EXP
            ...........
phi=(P1-1)*(P2-1)*(P3-1)*(P4-1)*(P5-1)*(P6-1)*(P7-1)*(P8-1)*(P9-1)*(P10-1)
d = gmpy2.invert(e,phi)
m = pow(c,d,n)
print(long_to_bytes(m))
n是p的r次方
明显特征
，
为
素
数
，
没
有
了
因
为
​

那么计算n的欧拉函数​

#欧拉函数φ(n)的定义是小于n的自然数中与n互质的数的个数。
#p^r 质因数就只有p，那么不与它互质的数都含有p，
#和它不互质的数的个数：p^r/p=p^{r-1} 
#   (注：与p^r不互质的数是指那些包含P作为质因数的数，这些数可以是p,2p,3p....kp即与p^r不互质的数正好是p^r/p=p^(r-1),因为每个这样的数都是KP，其中K从1到p^(r-1))
#剩下就是互质的数，其个数就是：p^r-p^{r-1} 
#则有 φ(n)=p^r-p^{r-1}
例：
from Crypto.Util.number import *
flag = b'NSSCTF{******}' + b'1'*100
p = getPrime(256)
q = getPrime(256)
n = (p**3) * q
e = 65537
phi = (p-1)*(q-1)
m = bytes_to_long(flag)
c = pow(m, e, n)
print(f'p = {p}')
print(f'q = {q}')
print(f'e = {e}')
print(f'c = {c}')
p = 80505091208742938705306670241621545375764148093711243653439069254008824979403
q = 67599990875658931406915486208971556223245451500927259766683936131876689508521
e = 65537
c = 7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041
我们看到​，故我们需要改变phi的求法

EXP
import gmpy2,sympy
from Cryptodome.Util.number import *

p = 80505091208742938705306670241621545375764148093711243653439069254008824979403
q = 67599990875658931406915486208971556223245451500927259766683936131876689508521
e = 65537
c = 7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041

e = 65537
phi = (p**3-p**2)*(q-1)
n=(p**3)*q
d = gmpy2.invert(e,phi)
m = pow(c,d,n)
print(long_to_bytes(m))
小明文攻击/低加密指数攻击
情况一：
（明文m加密后小于n）当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。

p = getPrime(5120)
q = getPrime(5120)
 
n = p*q
e = 97
phi = (p-1)*(q-1)
#我们看到p，q很大即n很大，但e很小，故可能导致m^e还是比n小，即在模n后还是c=m^e,即我们直接对c开e次方。
EXP：
m=iroot(c,e)
情况二：
（明文m加密后大于n，但不是很大）如果加密后的 c 虽然大于 n 但是并不太大，由于pow (m，e) =kn+c，可以暴力枚举 k，然后开 e 次方，直到 e 次方可以开尽，解出了正确的 C 为止。

EXP:
1
for k in range(1000000):
2
    cc = k * n + c
3
    mm = iroot(cc, e)
4
    if mm[1]:
5
        m = mm[0]
6
        print(long_to_bytes(m))
7
        print('k:', k)
情况三：
考虑公钥指数​的RSA。如果明文大小在​区间内，解密只需简单的对密文​开三次方即可，因为​。考虑处于​区间内的明文。相应的，在有限域的表示里，​.令​，解密仅需计算出​的三次方，即​.

不互素
例1.
1
from Crypto.Util.number import *
2
​
3
flag = b'NSSCTF{******}'
4
​
5
p = getPrime(512)
6
q = getPrime(512)
7
​
8
e = 65537*2
9
​
10
n = p*q
11
​
12
m = bytes_to_long(flag)
13
​
14
c = pow(m, e, n)
15
​
16
print(f'p = {p}')
17
print(f'q = {q}')
18
print(f'e = {e}')
19
print(f'c = {c}')
20
​
21
​
22
p = 9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059
23
q = 9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343
24
e = 131074
25
c = 68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560
26
​
这道题我们来看不互素的另一种情况，我们会发现本题中的e和phi依然不互素，而且我们还么办法按照上体思路转化为其他因子所组成的公钥进行运算，因为p−1或q−1都是偶数，e也是偶数，他们显然不互素。

我们知道e=2⋅65537,则有​

我们考虑将​看成一个整体，则c也等价为使用e=65537加密​的结果，显然这个e和phi是互素的，也就是说我们可以得到私钥！

那么此时我们私钥解密将会得到​，我们只需要再进行开平方即可。

但是要注意这并不代表所有题目都可以如此完成，假设本题​>n，那么我们知道取模会丢失信息，我们解密得到的只会是​的余数，没办法直接开平方得到m。故我们也可以发现这种方法适用于不互素且m比较小的情况。

EXP 

n = p*q
phi = (p-1)*(q-1)
d = invert(e//2 , phi)

m = pow(c, d, p*q)
m1=iroot(m,2)[0]

print(long_to_bytes(m1))
费马小定理
题目1
from Crypto.Util.number import *
from random import *
from flag import flag

m = bytes_to_long(flag)

def getKey():
    p = getPrime(1024)
    q = getPrime(1024)
    n = p*q
    assert m < n
    _g = randint(1,n)
    _a = randint(1,n)
    _b = randint(1,n)
    return _g,_a,_b,p,n

def encrypt():
    key = getKey()
    _key = pow(key[0], key[1] * (key[3]-1), key[4])   #_key=_g**(_a*(p-1))%n
    c = (pow(_key, key[2], key[4]) * m) % key[4]      
#c=((_key**_b)%(n)*m)%n
    return key[4], _key, c

if __name__ == '__main__':
    print(encrypt())
(18179834236782025892165859358541969039672768622078317899558535972829779066590034272465041741258879770213528640616887797155080398928088158585694106907734126514213361875345507975960317351812797992725951327122851713302327820458710931182497244211627793166445441450354787055708273445176257841426295561697059359851693234672902342001564298222123930677021693824135290857682548806726262690296776413730423712555689778608531366304345258560702517364961150273435113114487840186421965955626002395362990009595593448407759619600184788649602049313701058708439962867646774483596360223764988749726613678029307186833464512585242569435003, 11847655277251446942383940882912368688156808473955941053063218251376227576794849789637061751561030423224338717881358695503734129213448747206540310077968159679087902861554101729530885006978457916005370151390141770528828726044070599163879940393777653050010384591813315879288161460396096268260181418863020260300992421872071273292678599559844166740721617200084689717099280979932276914367828947937478359933181441706805653179826272658999406454166746306193757296165968606398592219586135127604969713571323480832108309240510220649110629512108142189299294329845348146274638537031635599971704959419196082418167981085622698281250, 14415195091596957208690057717270843038813723273773797640804955509618976877138721476691508292484187601673314627535732234517837698631950684940570225175917508902812451340933203438247448893168609525426014319195770233401480816194489198464476480610373345480444974658239730190879678428967798637043230820661470572128997114218312981971051639788050332764374932384836724719743407759997343303062259374222621789562479046933232021478087932233308027796973486804634154183554333108258875955181959785332882009189939917648988868671919046698887438054678239786487480196578700573286352849560893479759745211457149133610748492277912237022560)
分析
我们看到给出了k[4]，_key，c.

同时我们知道：_key简写成k

1式可改写成：​

两边模p，由费马小定理得：​

得​即k-1式p的倍数。

所以有：​

由2式得​

再次同时模p：​

题目只给了m<n，我们猜测m大概率小于 p

所以有：​   （ ​是p的倍数，那么​也是p的倍数，有​这里可以考虑​二项展开）

EXP
p=gmpy2.gcd(n,k-1)
print(long_to_bytes(c%p))
题目2
from Crypto.Util.number import getPrime, bytes_to_long
from secret import f

flag = b'NSSCTF{test_flag}'
p = getPrime(512)
q = getPrime(512)
n = p*q

m = bytes_to_long(flag)
e = 65537
c = pow(m,e,n)

R.<x> = ZZ[]
f = R(str(f))

w = pow(2,f(p),n)


print(f'{n = }\n')
print(f'{e = }\n')
print(f'{c = }\n')
print(f'{f = }\n')
print(f'{w = }\n')



n = 101780569941880865465631942473186578520071435753163950944409148606282910806650879176280021512435190682009749926285674412651435782567149633130455645157688819845748439487113261739503325065997835517112163014056297017874761742768297646567397770742374004940360061700285170103292360590891188591132054903101398360047
e = 65537
c = 77538275949900942020886849496162539665323546686749270705418870515132296087721218282974435210763225488530925782158331269160555819622551413648073293857866671421886753377970220838141826468831099375757481041897142546760492813343115244448184595644585857978116766199800311200819967057790401213156560742779242511746
f = 2*x^332 - x^331 + x^329 + 3*x^328 - x^327 - 3*x^325 + x^323 - 3*x^322 - x^321 - 3*x^320 + x^319 + 2*x^318 - 4*x^317 - 3*x^315 - 2*x^314 + x^313 + x^312 + 2*x^311 + 2*x^309 + 2*x^308 + 5*x^307 + 2*x^306 + 3*x^305 + 5*x^304 + 4*x^303 + x^302 - x^301 - x^300 - 2*x^299 - 2*x^298 + x^297 + 3*x^296 - x^295 - 4*x^292 - x^290 + 4*x^289 - x^287 - 3*x^286 + x^285 - 2*x^284 + x^283 - x^282 - 2*x^281 + x^280 - 2*x^279 + x^278 + 2*x^277 - 3*x^276 - x^275 - 4*x^274 - 3*x^273 - 5*x^272 - 2*x^271 - 3*x^270 + 2*x^269 + 2*x^268 - x^267 - 2*x^266 + x^265 + x^264 - 3*x^262 - 3*x^259 + 2*x^258 - x^257 + 2*x^256 + 2*x^255 - x^254 - 2*x^253 - x^252 + 2*x^251 - x^250 + x^249 + 2*x^247 + 2*x^246 + 2*x^245 - 2*x^244 - 3*x^243 + 2*x^242 - 3*x^241 - x^240 - 3*x^239 - x^236 - 3*x^235 - 2*x^234 - x^233 - 2*x^232 - x^231 - 3*x^230 - 2*x^229 - 4*x^228 - 2*x^227 - 3*x^226 + 2*x^225 + x^224 - x^223 - 2*x^221 + 3*x^219 - x^217 - 2*x^216 + x^215 + 2*x^213 - x^212 + 3*x^211 + x^210 + 4*x^209 + x^208 - x^206 - x^205 - x^204 + 2*x^203 - 3*x^202 + 2*x^199 - x^198 + 2*x^196 - 2*x^195 + 3*x^194 + 3*x^193 - x^192 + 4*x^191 + 2*x^189 + x^186 - x^185 - x^184 + 3*x^183 + x^182 + 2*x^181 - 2*x^180 + x^177 + x^175 - x^173 + 3*x^172 + x^170 + x^169 - x^167 - 2*x^166 - x^165 - 4*x^164 - 2*x^163 + 2*x^162 + 4*x^161 - 2*x^160 - 3*x^159 - 2*x^158 - 2*x^157 + x^156 - x^155 + 3*x^154 - 4*x^153 + x^151 + 2*x^150 + x^149 - x^148 + 2*x^147 + 3*x^146 + 2*x^145 - 4*x^144 - 4*x^143 + x^142 - 2*x^140 - 2*x^139 + 2*x^138 + 3*x^137 + 3*x^136 + 3*x^135 + x^134 - x^133 + 2*x^132 + 3*x^130 - 3*x^129 - 2*x^128 - x^127 - 2*x^126 + x^125 + x^124 - 2*x^123 + x^122 - x^121 + 3*x^120 - x^119 - 2*x^118 - x^117 - x^116 - 2*x^115 + 2*x^114 + 2*x^113 - 3*x^112 - x^111 - 4*x^110 + x^109 + x^108 + x^106 - 4*x^105 + x^104 - x^103 - x^101 + x^100 - 2*x^99 + x^98 - x^97 + 3*x^96 + 3*x^94 - x^93 - x^92 + x^91 - 2*x^90 + x^89 - x^88 + x^87 - x^86 + x^85 + x^84 - x^83 + x^79 - 3*x^78 - 2*x^77 + x^74 + 3*x^73 - x^72 - 3*x^71 - 2*x^70 + x^69 - 3*x^66 + x^65 + x^64 - 4*x^62 - x^61 + x^60 - x^59 + 3*x^58 - x^57 - x^54 + 3*x^53 + x^51 - 3*x^50 - x^49 + 2*x^47 - x^46 - x^44 + x^43 - x^42 - 4*x^41 - 3*x^39 - x^37 - x^36 - 3*x^35 + x^34 + x^33 - 2*x^32 + 2*x^31 - x^30 + 2*x^29 - 2*x^28 - 2*x^27 - x^24 + x^22 - 5*x^21 + 3*x^20 + 2*x^19 - x^18 + 2*x^17 + x^16 - 2*x^15 - 2*x^14 + x^13 + x^12 + 2*x^11 - 3*x^10 + 3*x^9 + 2*x^8 - 4*x^6 - 2*x^5 - 4*x^4 + x^3 - x^2 - 1
w = 32824596080441735190523997982799829197530203904568086251690542244969244071312854874746142497647579310192994177896837383837384405062036521829088599595750902976191010000575697075792720479387771945760107268598283406893094243282498381006464103080551366587157561686900620059394693185990788592220509670478190685244
分析
思路一：(多项式的基本性质)
题目定义了一个多项式f，然后给出了​，其中p是n的因子，所以模p也成立。

根据​，我们有​，在此题中​，所以我们可以通过​计算得到p.

证明​：

（1）多项式f(x)可以表示为：

其中​是多项式的系数。

（2）多项式在x=1处的值：

（3）构造​

	我们可以构造一个新的多项式​：

简化：

(4)因式分解​

	对于任意整数
，
​可以因式分解为：

因此，​可以表示为：

#可以通过此代码验算x^k-1的分解因式包含x-1
x = var('x')
for i in range(1, 334):
f = x ^ i - 1
print(f.factor())
即可以表示为：​

（5）最后​

	​

在​的情况下，由费马小定理得：​

所以有：​

得到p后正常RSA解密即可。

EXP 1
from Cryptodome.Util.number import long_to_bytes, inverse
from sympy import symbols, sympify
import math

# 题目中给出的参数
n = 101780569941880865465631942473186578520071435753163950944409148606282910806650879176280021512435190682009749926285674412651435782567149633130455645157688819845748439487113261739503325065997835517112163014056297017874761742768297646567397770742374004940360061700285170103292360590891188591132054903101398360047
e = 65537
c = 77538275949900942020886849496162539665323546686749270705418870515132296087721218282974435210763225488530925782158331269160555819622551413648073293857866671421886753377970220838141826468831099375757481041897142546760492813343115244448184595644585857978116766199800311200819967057790401213156560742779242511746
w = 32824596080441735190523997982799829197530203904568086251690542244969244071312854874746142497647579310192994177896837383837384405062036521829088599595750902976191010000575697075792720479387771945760107268598283406893094243282498381006464103080551366587157561686900620059394693185990788592220509670478190685244

# 题目中提供的多项式 f（注意这里用 ^ 表示幂，所以需要替换为 **）
f_str = ("2*x^332 - x^331 + x^329 + 3*x^328 - x^327 - 3*x^325 + x^323 - 3*x^322 - x^321 - 3*x^320 + x^319 + 2*x^318 - 4*x^317 - 3*x^315 - 2*x^314 + x^313 + x^312 + 2*x^311 + 2*x^309 + 2*x^308 + 5*x^307 + 2*x^306 + 3*x^305 + 5*x^304 + 4*x^303 + x^302 - x^301 - x^300 - 2*x^299 - 2*x^298 + x^297 + 3*x^296 - x^295 - 4*x^292 - x^290 + 4*x^289 - x^287 - 3*x^286 + x^285 - 2*x^284 + x^283 - x^282 - 2*x^281 + x^280 - 2*x^279 + x^278 + 2*x^277 - 3*x^276 - x^275 - 4*x^274 - 3*x^273 - 5*x^272 - 2*x^271 - 3*x^270 + 2*x^269 + 2*x^268 - x^267 - 2*x^266 + x^265 + x^264 - 3*x^262 - 3*x^259 + 2*x^258 - x^257 + 2*x^256 + 2*x^255 - x^254 - 2*x^253 - x^252 + 2*x^251 - x^250 + x^249 + 2*x^247 + 2*x^246 + 2*x^245 - 2*x^244 - 3*x^243 + 2*x^242 - 3*x^241 - x^240 - 3*x^239 - x^236 - 3*x^235 - 2*x^234 - x^233 - 2*x^232 - x^231 - 3*x^230 - 2*x^229 - 4*x^228 - 2*x^227 - 3*x^226 + 2*x^225 + x^224 - x^223 - 2*x^221 + 3*x^219 - x^217 - 2*x^216 + x^215 + 2*x^213 - x^212 + 3*x^211 + x^210 + 4*x^209 + x^208 - x^206 - x^205 - x^204 + 2*x^203 - 3*x^202 + 2*x^199 - x^198 + 2*x^196 - 2*x^195 + 3*x^194 + 3*x^193 - x^192 + 4*x^191 + 2*x^189 + x^186 - x^185 - x^184 + 3*x^183 + x^182 + 2*x^181 - 2*x^180 + x^177 + x^175 - x^173 + 3*x^172 + x^170 + x^169 - x^167 - 2*x^166 - x^165 - 4*x^164 - 2*x^163 + 2*x^162 + 4*x^161 - 2*x^160 - 3*x^159 - 2*x^158 - 2*x^157 + x^156 - x^155 + 3*x^154 - 4*x^153 + x^151 + 2*x^150 + x^149 - x^148 + 2*x^147 + 3*x^146 + 2*x^145 - 4*x^144 - 4*x^143 + x^142 - 2*x^140 - 2*x^139 + 2*x^138 + 3*x^137 + 3*x^136 + 3*x^135 + x^134 - x^133 + 2*x^132 + 3*x^130 - 3*x^129 - 2*x^128 - x^127 - 2*x^126 + x^125 + x^124 - 2*x^123 + x^122 - x^121 + 3*x^120 - x^119 - 2*x^118 - x^117 - x^116 - 2*x^115 + 2*x^114 + 2*x^113 - 3*x^112 - x^111 - 4*x^110 + x^109 + x^108 + x^106 - 4*x^105 + x^104 - x^103 - x^101 + x^100 - 2*x^99 + x^98 - x^97 + 3*x^96 + 3*x^94 - x^93 - x^92 + x^91 - 2*x^90 + x^89 - x^88 + x^87 - x^86 + x^85 + x^84 - x^83 + x^79 - 3*x^78 - 2*x^77 + x^74 + 3*x^73 - x^72 - 3*x^71 - 2*x^70 + x^69 - 3*x^66 + x^65 + x^64 - 4*x^62 - x^61 + x^60 - x^59 + 3*x^58 - x^57 - x^54 + 3*x^53 + x^51 - 3*x^50 - x^49 + 2*x^47 - x^46 - x^44 + x^43 - x^42 - 4*x^41 - 3*x^39 - x^37 - x^36 - 3*x^35 + x^34 + x^33 - 2*x^32 + 2*x^31 - x^30 + 2*x^29 - 2*x^28 - 2*x^27 - x^24 + x^22 - 5*x^21 + 3*x^20+ 2*x^19 - x^18+ 2*x^17+ x^16 - 2*x^15- 2*x^14+ x^13+ x^12+ 2*x^11- 3*x^10+ 3*x^9+ 2*x^8- 4*x^6- 2*x^5- 4*x^4+ x^3- x^2- 1")

# 使用 sympy 解析多项式，并计算 f(1)
x = symbols('x')
f_poly = sympify(f_str.replace('^', '**'))
f1 = int(f_poly.subs(x, 1))
print("f(1) =", f1)

# 根据 2^(f(p)) ≡ 2^(f(1)) (mod p)，我们有 p | (2^(f(1)) - 2^(f(p))).
# 注意 w = 2^(f(p)) mod n，所以可以计算 gcd(2^(f(1)) - w, n) 得到 p。
g = pow(2, f1, n)
p = math.gcd(g - w, n)
if p == 1 or p == n:
    print("分解失败")
    exit(1)

q = n // p
print("p =", p)
print("q =", q)

# 计算 φ(n) 并求出 RSA 私钥 d
phi = (p - 1) * (q - 1)
d = inverse(e, phi)

# 解出明文 m 并转换为 bytes
m = pow(c, d, n)
flag = long_to_bytes(m)
print("Flag:", flag.decode())
思路二：
题目给了如下等式：

我们带入多项式并展开，有：

我们知道形如​的式子因式分解后都有一因子​，因此可以构造费马小定理。

然后转为在模p的意义下，在依据费马小定理，有：

也就是：

和n进行gcd即可求得p.

EXP 2
#代码运行有问题，后面在改
from Crypto.Util.number import long_to_bytes, inverse
from gmpy2 import gcd

x = var('x')
n = 101780569941880865465631942473186578520071435753163950944409148606282910806650879176280021512435190682009749926285674412651435782567149633130455645157688819845748439487113261739503325065997835517112163014056297017874761742768297646567397770742374004940360061700285170103292360590891188591132054903101398360047
e = 65537
c = 77538275949900942020886849496162539665323546686749270705418870515132296087721218282974435210763225488530925782158331269160555819622551413648073293857866671421886753377970220838141826468831099375757481041897142546760492813343115244448184595644585857978116766199800311200819967057790401213156560742779242511746
f = ...
w = 32824596080441735190523997982799829197530203904568086251690542244969244071312854874746142497647579310192994177896837383837384405062036521829088599595750902976191010000575697075792720479387771945760107268598283406893094243282498381006464103080551366587157561686900620059394693185990788592220509670478190685244
for i in f.list()[1::]:
    w *= 2 ^ (-ZZ(i))
    w %= n

p = gcd(w * 2 - 1,  n)
q = n // p
print(long_to_bytes(pow(c, inverse(e, (p - 1) * (q - 1)), n)))  #b'NSSCTF{8d1e3405044a79b23a44a43084bd994b}'
维纳攻击
连分数
每个数都可以分解为连分数的形式,对一个分数做连分数展开就是在对分子分母做辗转相除,例如：

所以​展开为连分数为：​

维纳攻击(wiener)
在RSA中有​

其中p*q远大于p+q，所以我们有​

因为​

则有​

对上式两边同时除以​有​

将上式
用
替
换
，
则
上
式
变
为
​

显然等式右边的d∗N是个很大的数,所以我们可以将等式右边看成0,则上式变为：​

那么对于此结果,我们得到两个近似的数,对于等式左边的数,我们可以将其展开为连分数,再遍历每一组近似解,就有可能找到等式右边的值.

设其中一组值为（d，k）有​

即：​

这样就可以计算出（p,d），通过验算p*q是否等于N可验证d是否正确.

（注：维纳攻击需满足​）

攻击脚本
EXP1
import gmpy2
import libnum


def continuedFra(x, y):
    """计算连分数
    :param x: 分子
    :param y: 分母
    :return: 连分数列表
    """
    cf = []
    while y:
        cf.append(x // y)
        x, y = y, x % y
    return cf


def gradualFra(cf):
    """计算传入列表最后的渐进分数
    :param cf: 连分数列表
    :return: 该列表最后的渐近分数
    """
    numerator = 0
    denominator = 1
    for x in cf[::-1]:
        # 这里的渐进分数分子分母要分开
        numerator, denominator = denominator, x * denominator + numerator
    return numerator, denominator


def solve_pq(a, b, c):
    """使用韦达定理解出pq，x^2−(p+q)∗x+pq=0
    :param a:x^2的系数
    :param b:x的系数
    :param c:pq
    :return:p，q
    """
    par = gmpy2.isqrt(b * b - 4 * a * c)
    return (-b + par) // (2 * a), (-b - par) // (2 * a)


def getGradualFra(cf):
    """计算列表所有的渐近分数
    :param cf: 连分数列表
    :return: 该列表所有的渐近分数
    """
    gf = []
    for i in range(1, len(cf) + 1):
        gf.append(gradualFra(cf[:i]))
    return gf


def wienerAttack(e, n):
    """
    :param e:
    :param n:
    :return: 私钥d
    """
    cf = continuedFra(e, n)
    gf = getGradualFra(cf)
    for d, k in gf:
        if k == 0: continue
        if (e * d - 1) % k != 0:
            continue
        phi = (e * d - 1) // k
        p, q = solve_pq(1, n - phi + 1, n)
        if p * q == n:
            return d


n=
e=
c=

d = wienerAttack(e, n)
print(d)
m = pow(c, d, n)
print(libnum.n2s(m).decode())
EXP2
利用github下载的库

from Cryptodome.Util.number import long_to_bytes
from RSAwienerHacker import hack_RSA

n = 
e = 
c = 
# factordb result
d=hack_RSA(e,n)
flag=long_to_bytes(pow(c,d,n))
print(flag)
例题1
from Crypto.Util.number import *
from gmpy2 import *
flag = b'NSSCTF{******}'
p = getPrime(256)
q = getPrime(256)
n = p*q
d = getPrime(128)
e = inverse(d, (p-1)*(q-1))
m = bytes_to_long(flag)
c = powmod(m, e, n)
print(f'n = {n}')
print(f'e = {e}')
print(f'c = {c}')
n = 6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689
e = 3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669
c = 1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837
我们能够知道此时e会很大（因为​，一个小另一个就大），所以其实当我们发现e很大或者说很接近n时，便可以考虑使用连分数展开的方式，遍历每一个系数。

EXP
from Cryptodome.Util.number import *
from Cryptodome.Util.number import long_to_bytes
from gmpy2 import *

n = 6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689
e = 3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669
c = 1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837


class ContinuedFraction():
    def __init__(self, numerator, denumerator):
        self.numberlist = []  # number in continued fraction
        self.fractionlist = []  # the near fraction list
        self.GenerateNumberList(numerator, denumerator)
        self.GenerateFractionList()

    def GenerateNumberList(self, numerator, denumerator):
        while numerator != 1:
            quotient = numerator // denumerator
            remainder = numerator % denumerator
            self.numberlist.append(quotient)
            numerator = denumerator
            denumerator = remainder

    def GenerateFractionList(self):
        self.fractionlist.append([self.numberlist[0], 1])
        for i in range(1, len(self.numberlist)):
            numerator = self.numberlist[i]
            denumerator = 1
            for j in range(i):
                temp = numerator
                numerator = denumerator + numerator * self.numberlist[i - j - 1]
                denumerator = temp
            self.fractionlist.append([numerator, denumerator])


a = ContinuedFraction(e, n)
for k, d in a.fractionlist:
    m = powmod(c, d, n)
    flag = long_to_bytes(m)

    if b'NSSCTF' in flag:
        print(flag)
例题2
from Crypto.Util.number import *
from gmpy2 import *

flag = b'NSSCTF{******}'

m1 = bytes_to_long(flag[:len(flag)//2])
m2 = bytes_to_long(flag[len(flag)//2:])

p1 = getPrime(1024)
p2 = next_prime(p1)

q1 = getPrime(400)
q2 = getPrime(400)

n1 = p1 * p1 * q1
n2 = p2 * p2 * q2

e1 = getPrime(128)
e2 = getPrime(128)

c1 = pow(m1, e1, n1)
c2 = pow(m2, e2, n2)


print(f'n1 = {n1}')
print(f'e1 = {e1}')
print(f'c1 = {c1}')

print(f'n2 = {n2}')
print(f'e2 = {e2}')
print(f'c2 = {c2}')

n1 = 45965238261145848306223556876775641787109249067253988455950651872774381183888979035386577960806305813634216583223483001245996467366520071511779063266315692543617195166613592991812117446772937889819643718423377609566597230873623011099295202599905646652692946273375405832062164263711151844949794774229886016858313299259387152937467743637367261734624060321171598033647661809876890249035267180368762739600552966699295210431508056693524383116052539072065535970720901196322942269916455391238409489616842687658335666652878840458263998780783865062993401055465701207886230787204008073260653659510197069116237460322442433331870944968133645513020531983926180514313028320422449103156746225574626841023639595418255472716267486241462968101152032898749
e1 = 279586443815379026299414729432860797623
c1 = 11515318475856179010858377918435934663304239594599788732135470038988222237790835017056954077794506499559722814863240838882673078330335616745578747265404229105473136943188301293198548838105990504750972653445744347121859396823995101611868191609259910876207038154174100742978387355304521374228562928260479446249263909934393657537918407756957032700052269827171045167752168509783885071211516601218892308228572735545579606908430615218499620619028799140945676768341492724044499209913045110359935325510223652935426973411960865908064824205626343685369866932545651037748553442488682593143020861196339307665638704485958986411837014559504992818255506454051842453553265179370878637153602580071152915165775491633322055360737581203750897698007951117808
n2 = 25459365600568360055376316722846535809281537088824978187355135247184417413329012865221456308642116409716822227032113740366024809533942721286337697830775221199570509665320400376959076685728357107457862901087218522281771857981155239522807950207375964963527837592797198372303427082343684305143238075402697262610809363109748984974325271762535573995993132076293275456692621516174749076897962348000698039074721998780555541905706268579496243099763776676950336105074846695227221690550755501320117554250942600626927600558489780841103863110357615957088709321079080707735028039675102383525496673233697130053936053431067133520717494376952763684807635780416860233261892013531534059267366382617635000415723745274490604551078385404286689447761642713963
e2 = 249615977162294580923494787210301891647
c2 = 24544357952213952357056140974408354173440635791397720610932999473703241918398814255275362994811954064820912468224131892551724930677715676493892869921426790840199600798807085779112854131346378899855545138289836687048918660685766286852276199524789699567994154833159365800848535248059731927121269157841084905465048764152977389352561685340108834453730139893330210765986258703154334901509553990091592209268471594519326651914685843021165854654380119091009831071244459145750976193183411590207529489774630266528538380011000213950174694472355034075543687572037516433204151217601537869823709241020510051494619335852686100897182065588340025334679570763716458250649152257797833022586793526594784648938165537701256313728194521212887453997160504204832
分析
本题给了两组公钥和密文，之前我们学习过多组公钥时可以考虑共享素数，但从代码上来看可以发现他们使用的都是不一样的素数，但我们又会发现这些素数之间并不是完全独立的。

p2是p1的下一个素数，或者换种说法说，他们离得非常近，在考虑一下我们曾经所学过的攻击关于非常进的无外乎是p-q过小，我们可以利用费马分解进行操作，但这里两个非常近的素数并没有进行乘积，而是分开和其他数进行乘积。还有一种情况便是维纳攻击，在维纳攻击中我们说是当e和n非常接近时便可以使用

维纳攻击的核心：连分数定理

连分数定理：当a和b满足

时，则a/b是x的一个连分数近似。

连分数近似则代表我们可以对x进行连分数展开，其中的某个近似数便是​.

本定理便是我们的理论支撑，那么现在我们有了两个很近的数n1和n2，如果我们对这两个数进行连分数展开，我们的预期结果便是可以在展开的过程中得到p1和p2。

EXP
from Crypto.Util import number
import gmpy2

n1 = 45965238261145848306223556876775641787109249067253988455950651872774381183888979035386577960806305813634216583223483001245996467366520071511779063266315692543617195166613592991812117446772937889819643718423377609566597230873623011099295202599905646652692946273375405832062164263711151844949794774229886016858313299259387152937467743637367261734624060321171598033647661809876890249035267180368762739600552966699295210431508056693524383116052539072065535970720901196322942269916455391238409489616842687658335666652878840458263998780783865062993401055465701207886230787204008073260653659510197069116237460322442433331870944968133645513020531983926180514313028320422449103156746225574626841023639595418255472716267486241462968101152032898749
e1 = 279586443815379026299414729432860797623
c1 = 11515318475856179010858377918435934663304239594599788732135470038988222237790835017056954077794506499559722814863240838882673078330335616745578747265404229105473136943188301293198548838105990504750972653445744347121859396823995101611868191609259910876207038154174100742978387355304521374228562928260479446249263909934393657537918407756957032700052269827171045167752168509783885071211516601218892308228572735545579606908430615218499620619028799140945676768341492724044499209913045110359935325510223652935426973411960865908064824205626343685369866932545651037748553442488682593143020861196339307665638704485958986411837014559504992818255506454051842453553265179370878637153602580071152915165775491633322055360737581203750897698007951117808
n2 = 25459365600568360055376316722846535809281537088824978187355135247184417413329012865221456308642116409716822227032113740366024809533942721286337697830775221199570509665320400376959076685728357107457862901087218522281771857981155239522807950207375964963527837592797198372303427082343684305143238075402697262610809363109748984974325271762535573995993132076293275456692621516174749076897962348000698039074721998780555541905706268579496243099763776676950336105074846695227221690550755501320117554250942600626927600558489780841103863110357615957088709321079080707735028039675102383525496673233697130053936053431067133520717494376952763684807635780416860233261892013531534059267366382617635000415723745274490604551078385404286689447761642713963
e2 = 249615977162294580923494787210301891647
c2 = 24544357952213952357056140974408354173440635791397720610932999473703241918398814255275362994811954064820912468224131892551724930677715676493892869921426790840199600798807085779112854131346378899855545138289836687048918660685766286852276199524789699567994154833159365800848535248059731927121269157841084905465048764152977389352561685340108834453730139893330210765986258703154334901509553990091592209268471594519326651914685843021165854654380119091009831071244459145750976193183411590207529489774630266528538380011000213950174694472355034075543687572037516433204151217601537869823709241020510051494619335852686100897182065588340025334679570763716458250649152257797833022586793526594784648938165537701256313728194521212887453997160504204832


def continuedFra(x, y):
    cF = []
    while y:
        cF += [x // y]
        x, y = y, x % y
    return cF


def Simplify(ctnf):
    numerator = 0
    denominator = 1
    for x in ctnf[::-1]:
        numerator, denominator = denominator, x * denominator + numerator
    return (numerator, denominator)


def getit(c):
    cf = []
    for i in range(1, len(c)):
        cf.append(Simplify(c[:i]))
    return cf


def attack(e, n):
    cf = continuedFra(e, n)
    for (p2, p1) in getit(cf):
        if p1 == 0:
            continue
        if n1 % p1 == 0 and p1 != 1:
            return p1, p2
    print('not find!')


q1, q2 = attack(n1, n2)
p1 = gmpy2.iroot(n1//q1, 2)[0]
p2 = gmpy2.iroot(n2//q2, 2)[0]
phi1 = p1*(p1-1)*(q1-1)
phi2 = p2*(p2-1)*(q2-1)
d1 = gmpy2.invert(e1, phi1)
d2 = gmpy2.invert(e2, phi2)
m1 = number.long_to_bytes(gmpy2.powmod(c1, d1, n1))
m2 = number.long_to_bytes(gmpy2.powmod(c2, d2, n2))
print(m1+m2)
上面是完整的WP，在中间我们可以插入一行

assert n1/n2 - q1/q2 < 1/(2*q2*q2)

会发现他也是显然满足的。

连分数展开之后的内容便是常规RSA界面操作，不在赘述。

这里我们可以发现，只要发现题目中有差不多大的数，便可以寻找是否还有另外两个差不多大的数，并且这些数之间都是有联系的，只要能够找到这样的关系我们便可以考虑对较大的两个数进行连分数展开得到近似数，便有可能得到想要的值。

连分数攻击
原理
连分数：
​可以写成以下连分数形式：

或者写成简单表达式：​.

连分数是一种套式结构的分数，下图可以清楚的看出这样的结构形式：

image-20241130162452101

可见连分数就是一个套一个，每一个都是连分数。

例如：​

以此类推，可以得出​的连分数表达式。

渐进分数
我们可以将连分数写成​

其中1<=m<=n;

从而引出渐进分数的概念：

我们称
是
​的第m级渐进分数，（0<=m<=n）.

例如：
[3]是​的0级渐进分数，[3]=3,​，二者误差为0.423…

[3,2]是​的1级渐进分数，[3,2]=3+​=3.5，误差为0.0769…

[3,2,2]是​的2级渐进分数，[3,2,2]=​=3.4，误差为0.02307…

可见误差越来越小。

89/26是一个有理数，如果用小数来表示，是一个无限循环小数，写出来会非常的麻烦。可如果用连分数来表示就简单多了，而且通过渐进分数不断减小表达式的误差。

连分数攻击原理
连分数攻击的基本思想是利用连分数来逼近某两个大数（例如，RSA中的公钥模数和加密文本），从而找到它们的某些数学关系（如私钥）。在一些情况下，通过连续的分数逼近，攻击者可以揭示出加密算法中的隐含关系，甚至破解加密信息。

1.连分数的逼近性质
连分数的一个重要性质是，连分数可以用来生成越来越精确的有理数逼近。对于两个整数 a和 b，通过计算 a/b 的连分数展开，可以得到一些非常接近的分数对（即分子和分母），这些分数对可以通过某种方式揭示出 a 和 b之间的关系。

在一些密码学问题中，攻击者会通过连分数展开得到一些非常接近的分数，进而找到正确的解。例如，某些加密系统中，给定公钥模数 n 和加密消息 c，连分数方法可以帮助找到密文 c 和 n 之间的数学关系，进而解密消息或计算私钥。

2.连分数的攻击步骤
以RSA为例，假设你有公钥模数 n=p×q 和加密消息 c，其中 p 和 q 是大素数（通常通过连分数攻击，攻击者并不直接知道这两个素数）。攻击者可以利用以下步骤来进行连分数攻击：

1.计算连分数： 计算 n 和 c 的连分数展开。这是连分数攻击的核心步骤，通过对 n 和 c 进行连分数展开，得到一系列分数逼近。

2.寻找合适的逼近： 对连分数展开的每一项进行简化（逆序合并），得到一个分数对 (r,k)，其中 r 和 k 是分子和分母，可能与RSA的私钥或其他关键信息相关。

3.利用逼近进行解密： 根据得到的分数对，攻击者可以计算出潜在的私钥或解密消息。例如，攻击者可以通过计算 y=∣a⋅r−k⋅p∣ 来尝试恢复出密文或消息，并检查其中是否包含有用的标志（如“NSS”或其他特征）。

4.验证结果： 攻击者需要验证是否找到正确的解，通常是通过查找明文中是否包含已知的模式或标志。

连分数的应用场景
小的模数差异：如果RSA的两个素数 p 和 q 很接近，或者模数 n=p×q 的位数较小，那么可以使用连分数展开来获得 p 和 q 的逼近，从而帮助分解 n。

弱的加密实现：在某些情况下，密码系统可能实现不当或使用了过于简单的参数，这使得连分数攻击成为可行的选择。

例题1
from Crypto.Util.number import *
from gmpy2 import *

flag = b'******'
flag = bytes_to_long(flag)

p = getPrime(1024)
r = getPrime(175)
a = inverse(r, p)
a = (a*flag) % p

print(f'a = {a}')
print(f'p = {p}')

a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247
p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591
分析
在代码中，分析得到

现在我们已知a和p，求解m，咦我们会发现这和之前说的不一样啊，虽然a和p很接近，但是哪里存在另外两个数呢？

我们将上面的式子变变形状，从有限域（取模的整数域）变成实数域

则有

因为m相对于rp来说是一个非常小的数，所以我们得到近似关系：

展开后得到(r,k)，就可以进一步求解m了。

EXP
from Crypto.Util.number import *
import gmpy2
a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247
p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591

def continuedFra(x, y):
    cF = []
    while y:
        cF += [x // y]
        x, y = y, x % y
    return cF


def Simplify(ctnf):
    numerator = 0
    denominator = 1
    for x in ctnf[::-1]:
        numerator, denominator = denominator, x * denominator + numerator
    return (numerator, denominator)


def getit(c):
    cf = []
    for i in range(1, len(c)):
        cf.append(Simplify(c[:i]))
    return cf

cf = continuedFra(e, n)
for (r, k) in getit(cf):
    if r == 0:
        continue
    y = abs(a*r - k*p)
    flag = long_to_bytes(y)
    if b'NSS' in flag:
        print(flag)
低加密指数广播攻击/CRT 
例题1
from Crypto.Util.number import *
import os

flag = os.getenv('FLAG')
m = bytes_to_long(flag.encode())
e = 127

def enc():
    p = getPrime(512)
    q = getPrime(512)
    n = p*q
    c = pow(m, e, n)
    print(f"n: {n}")
    print(f"c: {c}")

def main():
    while True:
        opt = int(input('input> '))
        if opt == 1:
            enc()

main()
本题为交互题目，每次交互我们会发现程序会生成一组公钥来加密同一个明文，并且这些公钥中的e都相同，则我们有​，并且我们可以无限次交互获得足够多的数据，那么我们是否能够恢复m呢？考虑将​看作一个整体，因为它是不变的。那么问题则变成了给定一个数取模不同数的余数，问原数几何？

EXP
from gmpy2 import *
from pwn import *
from Cryptodome.Util.number import *


def crt(n_list, c_list):
    n = 1
    for i in n_list:
        n *= i
    N = []
    for i in n_list:
        N.append(n // i)
    t = []
    for i in range(len(n_list)):
        t.append(invert(N[i], n_list[i]))

    summary = 0
    for i in range(len(n_list)):
        summary = (summary + c_list[i] * t[i] * N[i]) % n
    return summary


io = remote('node4.anna.nssctf.cn', 28742)
e = 127
n_list = []
c_list = []
for i in range(127):
    io.sendlineafter(b'input> ', b'1')  # 等待收到input> 后发送1
    n = int(io.recvline().decode()[2:])  # 接收一行数据 即 n: xxxx
    c = int(io.recvline().decode()[2:])  # 接收一行数据 即 c: xxxx
    n_list.append(n)
    c_list.append(c)

M = crt(n_list, c_list)
m = iroot(M, e)[0]
flag = long_to_bytes(m)
print(flag)
这是是一个交互题目，将脚本保存在kali中py文件，然后在kali中python  xxxx打开该文件。

例题2
import libnum
import gmpy2
import random
from flag import *

m = libnum.s2n(flag)

n_list = []
c_list = []
q_list = []
p_list = []

for i in range(1, 6):
    p = libnum.generate_prime(1024)
    q = libnum.generate_prime(1024)
    n = p * q * (i + 1)

    p_list.append(p)
    q_list.append(q)
    n_list.append(n)

while True:
    e = random.randint(10, 30)

    if gmpy2.is_prime(e):
        break

for index in range(len(n_list)):
    c = pow(m, e, n_list[index])
    c_list.append(c_list.append(c * (index + 1)))
    print("n" + str(index + 1) + " =", n_list[index])
    print("c" + str(index + 1) + " =", c_list[index])

n1 = 22103870455568232891149694305142888751834308614394265111616851946569600408214771004642537180847811632101335684526571461971168013515137837024900824805617026937904594229522094231161022911739124543737188196687483192656237801622618078066399259928261566545087643719410735482610730976575506701177108423445928193645406926842010985319473171710362525271971508507747952666476652082985675013329629912123828667561346609223913700779782291638584038925201698832368301491167548373412290987271213331940429281040520028261848410995501268272516219976073764836056701179000719299634048587399330114683369803481960168019956231748933059575086
c1 = 11932229075145446680509155897048554062128427256365407597246250504495581359308426337230014475362231568192824606320775755785288148002607456528824047021370456983795336102290050703706457189838464034831160081682076095173411617546158489572376376884672473947738113750437924641752734999601688973523833305072494573210602790160977994408649942476416234572187935125916149727341802693373659080702112924850348826357976589797895053949499171267826718541148026541242636886850084012913015158312606367900952240929619627369492395483334316329627526281924799100659188037308919177852074431004118744919974806767580700568542188744931220106105
n2 = 75527641277099990800438920440041058388427571492243099817050670120985557789492014161535482889418153237600686779752008243731659250445079816272020155052679163716181164111466120389153470493389801068487079484957125572093805976995390398541806299511780722297642464948545911633969882049338027366168822259177038560221615245305724815740962661657512543487558774545803259821939839314547049519064559274668861232108875651136746020639698802437427698294031084596199751751480045337605111284980409927684686225365555725770862339970487179511801140925931587981761559129421142486178642732741442537609122284807214875446647952010067400441059
c2 = 124027357006179169026958610630330051622067042499828335143384044470302479154098199844981110929954078399392164965842575040140695741764719533745054315027041147434320473103634538090232615962998187567447484128103678001361703834076345621055674269048895730502155866761233018172058631071676397257894588728272913258599692996320058955017804506826897453939809574483310935927402899939042162496213745140970798253433830063777555869660983592646174581212241911650074643983280676238861065129884340834318081282521338654119292893592735294429956139729060770783817702837759047833794757601190967753969500822631312988106678317432186105038268
n3 = 67087501562139943813249584173215038264768218519355997619681399311361081244680048116472803745503996059873261361695629103578075388683394265112338602330356608572716276538183020643625652731722917269342461918246200053767885270359910155650804090015847462552469649420213346519159991670579334968778366255234963922378971680452094795318028353408405313888877068259282684640458674087251102468714734787171166396014144021959441774122328495595094512659302451021226956296868717965902597097040721193168373568780684532295504916946312087113872338693404258549907349353138009767393388073227204853717415106619739522003848121147803734511476
c3 = 34907142326483502918854711671956997110565154361385230791804714287500927140885225814711150443792832759398271249995064551044140838772959358268339105708186456545576271462167016667528764892342067422814982959975071847067493078241698635502292984200940132917130864956317815578073656622172241742542237740221147402449228459532782232518010610903660510875077798419046748683570340175197592449547071220020985311569095928938768945219762563190314531483012532595972282105394784611117089120803198848347397871670119847470687912177591609360741114570213377874848453859418234331921560384819899391157666714587396643397702710016410117040255
n4 = 107655225342909323493747650996643964780949305458547565103531987767712606044684527447631280423897684091717655597473336978923442425477823322239803312759244627308704521511743542550831030718035257133033470431042111429555597381959609892666206716219532081847930970282959800999825630713834546858387640307817593411764905032303294057112362597297253851687870254992314351948709124427458348128204263663881362955482132512838054738519685384575921373737470245719421223898475756247409282692966862335515090757754459242168056461013405091180148696649963461602177212697836496306046456138474445624214914814699390257673835554848791003397055
c4 = 260074379614284795599484546451240257157763532480505168853160303924952553177325935242853666448209970957052626857104522597130316456316378917529016900063473199051496246209878864043477905068893003923546332891289993179385753129868269775271722630762054161951558359984426822705582509592976962739279251035941138103001411061238095611738024433238447078804016593599525582868080696498271912174235479368671466666819582104245707176341268617126063957318342864903403961673418935623112290599738566078566393961145470677825235949530460449737989243772214379341818676279908757907698136648847166264635580606733816599243489965651372128251328
n5 = 70199621485671842359044641866403168058670803503736686351887502686934276983786039926002198676793045683182125769300687612734657616494815167750772182403321230734527784596550124329071164871143795929191396166096178482901122962656943854107741654772981259089537233024363295465966490361367216383217631330482253245796203648485653095242684462412133029510769320566443165990471527944889669809129572843754832577807509454633886982402256837076791468127186325307925886447397529190962280905611709973103713165872442266384750885343667064502988575278416037070011939869923447549518023420261237007329747290577829325263253564790709373901618
c5 = 207467685064436795719671032825183115862587233648672449925340580227825675452627031507906214773278665727530027025673966750973641715014217092820995216768554881760711270444952703291126925400881160114713107315867759288572987159233984669439942981888636828978580980986834342715153361271280814208437227309185682033733871844684874967978852089340054449142896831217885786745795842561143568848428620959961049292832772489885193639646881909425599177539209159664137785111991625129191354004990699226809474030005545318219197509201907072684957499981194498761673049651408375607248956494019809957851295451628144493493011699904221882421955
分析
题目给了多组n，c且使用同一个e加密，考虑CRT

EXP1
from gmpy2 import *
from Cryptodome.Util.number import *

n1 = 22103870455568232891149694305142888751834308614394265111616851946569600408214771004642537180847811632101335684526571461971168013515137837024900824805617026937904594229522094231161022911739124543737188196687483192656237801622618078066399259928261566545087643719410735482610730976575506701177108423445928193645406926842010985319473171710362525271971508507747952666476652082985675013329629912123828667561346609223913700779782291638584038925201698832368301491167548373412290987271213331940429281040520028261848410995501268272516219976073764836056701179000719299634048587399330114683369803481960168019956231748933059575086
c1 = 11932229075145446680509155897048554062128427256365407597246250504495581359308426337230014475362231568192824606320775755785288148002607456528824047021370456983795336102290050703706457189838464034831160081682076095173411617546158489572376376884672473947738113750437924641752734999601688973523833305072494573210602790160977994408649942476416234572187935125916149727341802693373659080702112924850348826357976589797895053949499171267826718541148026541242636886850084012913015158312606367900952240929619627369492395483334316329627526281924799100659188037308919177852074431004118744919974806767580700568542188744931220106105
n2 = 75527641277099990800438920440041058388427571492243099817050670120985557789492014161535482889418153237600686779752008243731659250445079816272020155052679163716181164111466120389153470493389801068487079484957125572093805976995390398541806299511780722297642464948545911633969882049338027366168822259177038560221615245305724815740962661657512543487558774545803259821939839314547049519064559274668861232108875651136746020639698802437427698294031084596199751751480045337605111284980409927684686225365555725770862339970487179511801140925931587981761559129421142486178642732741442537609122284807214875446647952010067400441059
c2 = 124027357006179169026958610630330051622067042499828335143384044470302479154098199844981110929954078399392164965842575040140695741764719533745054315027041147434320473103634538090232615962998187567447484128103678001361703834076345621055674269048895730502155866761233018172058631071676397257894588728272913258599692996320058955017804506826897453939809574483310935927402899939042162496213745140970798253433830063777555869660983592646174581212241911650074643983280676238861065129884340834318081282521338654119292893592735294429956139729060770783817702837759047833794757601190967753969500822631312988106678317432186105038268
n3 = 67087501562139943813249584173215038264768218519355997619681399311361081244680048116472803745503996059873261361695629103578075388683394265112338602330356608572716276538183020643625652731722917269342461918246200053767885270359910155650804090015847462552469649420213346519159991670579334968778366255234963922378971680452094795318028353408405313888877068259282684640458674087251102468714734787171166396014144021959441774122328495595094512659302451021226956296868717965902597097040721193168373568780684532295504916946312087113872338693404258549907349353138009767393388073227204853717415106619739522003848121147803734511476
c3 = 34907142326483502918854711671956997110565154361385230791804714287500927140885225814711150443792832759398271249995064551044140838772959358268339105708186456545576271462167016667528764892342067422814982959975071847067493078241698635502292984200940132917130864956317815578073656622172241742542237740221147402449228459532782232518010610903660510875077798419046748683570340175197592449547071220020985311569095928938768945219762563190314531483012532595972282105394784611117089120803198848347397871670119847470687912177591609360741114570213377874848453859418234331921560384819899391157666714587396643397702710016410117040255
n4 = 107655225342909323493747650996643964780949305458547565103531987767712606044684527447631280423897684091717655597473336978923442425477823322239803312759244627308704521511743542550831030718035257133033470431042111429555597381959609892666206716219532081847930970282959800999825630713834546858387640307817593411764905032303294057112362597297253851687870254992314351948709124427458348128204263663881362955482132512838054738519685384575921373737470245719421223898475756247409282692966862335515090757754459242168056461013405091180148696649963461602177212697836496306046456138474445624214914814699390257673835554848791003397055
c4 = 260074379614284795599484546451240257157763532480505168853160303924952553177325935242853666448209970957052626857104522597130316456316378917529016900063473199051496246209878864043477905068893003923546332891289993179385753129868269775271722630762054161951558359984426822705582509592976962739279251035941138103001411061238095611738024433238447078804016593599525582868080696498271912174235479368671466666819582104245707176341268617126063957318342864903403961673418935623112290599738566078566393961145470677825235949530460449737989243772214379341818676279908757907698136648847166264635580606733816599243489965651372128251328
n5 = 70199621485671842359044641866403168058670803503736686351887502686934276983786039926002198676793045683182125769300687612734657616494815167750772182403321230734527784596550124329071164871143795929191396166096178482901122962656943854107741654772981259089537233024363295465966490361367216383217631330482253245796203648485653095242684462412133029510769320566443165990471527944889669809129572843754832577807509454633886982402256837076791468127186325307925886447397529190962280905611709973103713165872442266384750885343667064502988575278416037070011939869923447549518023420261237007329747290577829325263253564790709373901618
c5 = 207467685064436795719671032825183115862587233648672449925340580227825675452627031507906214773278665727530027025673966750973641715014217092820995216768554881760711270444952703291126925400881160114713107315867759288572987159233984669439942981888636828978580980986834342715153361271280814208437227309185682033733871844684874967978852089340054449142896831217885786745795842561143568848428620959961049292832772489885193639646881909425599177539209159664137785111991625129191354004990699226809474030005545318219197509201907072684957499981194498761673049651408375607248956494019809957851295451628144493493011699904221882421955

n11=n1//2
n22=n2//3
n33=n3//4
n44=n4//5
n55=n5//6
c11=c1//1
c22=c2//2
c33=c3//3
c44=c4//4
c55=c5//5
def crt(n_list, c_list):
    n = 1
    for i in n_list:
        n *= i
    N = []
    for i in n_list:
        N.append(n // i)
    t = []
    for i in range(len(n_list)):
        t.append(invert(N[i], n_list[i]))

    summary = 0
    for i in range(len(n_list)):
        summary = (summary + c_list[i] * t[i] * N[i]) % n
    return summary

e = 13
n_list = [n11,n22,n33,n44,n55]
c_list = [c11,c22,c33,c44,c55]
M = crt(n_list, c_list)
m = iroot(M, e)[0]
flag = long_to_bytes(m)
print(flag)
EXP2
import libnum
from gmpy2 import invert, gcd, iroot
n1 = 22103870455568232891149694305142888751834308614394265111616851946569600408214771004642537180847811632101335684526571461971168013515137837024900824805617026937904594229522094231161022911739124543737188196687483192656237801622618078066399259928261566545087643719410735482610730976575506701177108423445928193645406926842010985319473171710362525271971508507747952666476652082985675013329629912123828667561346609223913700779782291638584038925201698832368301491167548373412290987271213331940429281040520028261848410995501268272516219976073764836056701179000719299634048587399330114683369803481960168019956231748933059575086
c1 = 11932229075145446680509155897048554062128427256365407597246250504495581359308426337230014475362231568192824606320775755785288148002607456528824047021370456983795336102290050703706457189838464034831160081682076095173411617546158489572376376884672473947738113750437924641752734999601688973523833305072494573210602790160977994408649942476416234572187935125916149727341802693373659080702112924850348826357976589797895053949499171267826718541148026541242636886850084012913015158312606367900952240929619627369492395483334316329627526281924799100659188037308919177852074431004118744919974806767580700568542188744931220106105
n2 = 75527641277099990800438920440041058388427571492243099817050670120985557789492014161535482889418153237600686779752008243731659250445079816272020155052679163716181164111466120389153470493389801068487079484957125572093805976995390398541806299511780722297642464948545911633969882049338027366168822259177038560221615245305724815740962661657512543487558774545803259821939839314547049519064559274668861232108875651136746020639698802437427698294031084596199751751480045337605111284980409927684686225365555725770862339970487179511801140925931587981761559129421142486178642732741442537609122284807214875446647952010067400441059
c2 = 124027357006179169026958610630330051622067042499828335143384044470302479154098199844981110929954078399392164965842575040140695741764719533745054315027041147434320473103634538090232615962998187567447484128103678001361703834076345621055674269048895730502155866761233018172058631071676397257894588728272913258599692996320058955017804506826897453939809574483310935927402899939042162496213745140970798253433830063777555869660983592646174581212241911650074643983280676238861065129884340834318081282521338654119292893592735294429956139729060770783817702837759047833794757601190967753969500822631312988106678317432186105038268
n3 = 67087501562139943813249584173215038264768218519355997619681399311361081244680048116472803745503996059873261361695629103578075388683394265112338602330356608572716276538183020643625652731722917269342461918246200053767885270359910155650804090015847462552469649420213346519159991670579334968778366255234963922378971680452094795318028353408405313888877068259282684640458674087251102468714734787171166396014144021959441774122328495595094512659302451021226956296868717965902597097040721193168373568780684532295504916946312087113872338693404258549907349353138009767393388073227204853717415106619739522003848121147803734511476
c3 = 34907142326483502918854711671956997110565154361385230791804714287500927140885225814711150443792832759398271249995064551044140838772959358268339105708186456545576271462167016667528764892342067422814982959975071847067493078241698635502292984200940132917130864956317815578073656622172241742542237740221147402449228459532782232518010610903660510875077798419046748683570340175197592449547071220020985311569095928938768945219762563190314531483012532595972282105394784611117089120803198848347397871670119847470687912177591609360741114570213377874848453859418234331921560384819899391157666714587396643397702710016410117040255
n4 = 107655225342909323493747650996643964780949305458547565103531987767712606044684527447631280423897684091717655597473336978923442425477823322239803312759244627308704521511743542550831030718035257133033470431042111429555597381959609892666206716219532081847930970282959800999825630713834546858387640307817593411764905032303294057112362597297253851687870254992314351948709124427458348128204263663881362955482132512838054738519685384575921373737470245719421223898475756247409282692966862335515090757754459242168056461013405091180148696649963461602177212697836496306046456138474445624214914814699390257673835554848791003397055
c4 = 260074379614284795599484546451240257157763532480505168853160303924952553177325935242853666448209970957052626857104522597130316456316378917529016900063473199051496246209878864043477905068893003923546332891289993179385753129868269775271722630762054161951558359984426822705582509592976962739279251035941138103001411061238095611738024433238447078804016593599525582868080696498271912174235479368671466666819582104245707176341268617126063957318342864903403961673418935623112290599738566078566393961145470677825235949530460449737989243772214379341818676279908757907698136648847166264635580606733816599243489965651372128251328
n5 = 70199621485671842359044641866403168058670803503736686351887502686934276983786039926002198676793045683182125769300687612734657616494815167750772182403321230734527784596550124329071164871143795929191396166096178482901122962656943854107741654772981259089537233024363295465966490361367216383217631330482253245796203648485653095242684462412133029510769320566443165990471527944889669809129572843754832577807509454633886982402256837076791468127186325307925886447397529190962280905611709973103713165872442266384750885343667064502988575278416037070011939869923447549518023420261237007329747290577829325263253564790709373901618
c5 = 207467685064436795719671032825183115862587233648672449925340580227825675452627031507906214773278665727530027025673966750973641715014217092820995216768554881760711270444952703291126925400881160114713107315867759288572987159233984669439942981888636828978580980986834342715153361271280814208437227309185682033733871844684874967978852089340054449142896831217885786745795842561143568848428620959961049292832772489885193639646881909425599177539209159664137785111991625129191354004990699226809474030005545318219197509201907072684957499981194498761673049651408375607248956494019809957851295451628144493493011699904221882421955

n11=n1//2
n22=n2//3
n33=n3//4
n44=n4//5
n55=n5//6
c11=c1//1
c22=c2//2
c33=c3//3
c44=c4//4
c55=c5//5

def op(x):
    res = 1
    for i in x:
        res *= i
    return res


def CRT(m, a):
    assert (len(m) == len(a))
    M = op(m)
    sum = 0
    for m, a in zip(m, a):
        Mi = M // m
        ti = invert(Mi, m)
        sum += a * ti * Mi
    return sum % M


def GCRT(m, a):
    assert (len(m) == len(a))
    curm, cura = m[0], a[0]
    for m, a in zip(m[1:], a[1:]):
        d = gcd(curm, m)
        c = a - cura
        assert (c % d == 0)
        K = c // d * invert(curm // d, m // d)
        cura += curm * K
        curm = curm * m // d
    return cura % curm


e1 = [13,17,19,13,29]
n=[n11,n22,n33,n44,n55]
c=[c11,c22,c33,c44,c55]
m = CRT(n, c)
for e in e1:
    m1 = iroot(m, e)  # 开e次方
    print("e=",e)
    print(m1)
    print(libnum.n2s(int(m1[0])))
EXP3（调库使用CRT）
n1 = 22103870455568232891149694305142888751834308614394265111616851946569600408214771004642537180847811632101335684526571461971168013515137837024900824805617026937904594229522094231161022911739124543737188196687483192656237801622618078066399259928261566545087643719410735482610730976575506701177108423445928193645406926842010985319473171710362525271971508507747952666476652082985675013329629912123828667561346609223913700779782291638584038925201698832368301491167548373412290987271213331940429281040520028261848410995501268272516219976073764836056701179000719299634048587399330114683369803481960168019956231748933059575086
c1 = 11932229075145446680509155897048554062128427256365407597246250504495581359308426337230014475362231568192824606320775755785288148002607456528824047021370456983795336102290050703706457189838464034831160081682076095173411617546158489572376376884672473947738113750437924641752734999601688973523833305072494573210602790160977994408649942476416234572187935125916149727341802693373659080702112924850348826357976589797895053949499171267826718541148026541242636886850084012913015158312606367900952240929619627369492395483334316329627526281924799100659188037308919177852074431004118744919974806767580700568542188744931220106105
n2 = 75527641277099990800438920440041058388427571492243099817050670120985557789492014161535482889418153237600686779752008243731659250445079816272020155052679163716181164111466120389153470493389801068487079484957125572093805976995390398541806299511780722297642464948545911633969882049338027366168822259177038560221615245305724815740962661657512543487558774545803259821939839314547049519064559274668861232108875651136746020639698802437427698294031084596199751751480045337605111284980409927684686225365555725770862339970487179511801140925931587981761559129421142486178642732741442537609122284807214875446647952010067400441059
c2 = 124027357006179169026958610630330051622067042499828335143384044470302479154098199844981110929954078399392164965842575040140695741764719533745054315027041147434320473103634538090232615962998187567447484128103678001361703834076345621055674269048895730502155866761233018172058631071676397257894588728272913258599692996320058955017804506826897453939809574483310935927402899939042162496213745140970798253433830063777555869660983592646174581212241911650074643983280676238861065129884340834318081282521338654119292893592735294429956139729060770783817702837759047833794757601190967753969500822631312988106678317432186105038268
n3 = 67087501562139943813249584173215038264768218519355997619681399311361081244680048116472803745503996059873261361695629103578075388683394265112338602330356608572716276538183020643625652731722917269342461918246200053767885270359910155650804090015847462552469649420213346519159991670579334968778366255234963922378971680452094795318028353408405313888877068259282684640458674087251102468714734787171166396014144021959441774122328495595094512659302451021226956296868717965902597097040721193168373568780684532295504916946312087113872338693404258549907349353138009767393388073227204853717415106619739522003848121147803734511476
c3 = 34907142326483502918854711671956997110565154361385230791804714287500927140885225814711150443792832759398271249995064551044140838772959358268339105708186456545576271462167016667528764892342067422814982959975071847067493078241698635502292984200940132917130864956317815578073656622172241742542237740221147402449228459532782232518010610903660510875077798419046748683570340175197592449547071220020985311569095928938768945219762563190314531483012532595972282105394784611117089120803198848347397871670119847470687912177591609360741114570213377874848453859418234331921560384819899391157666714587396643397702710016410117040255
n4 = 107655225342909323493747650996643964780949305458547565103531987767712606044684527447631280423897684091717655597473336978923442425477823322239803312759244627308704521511743542550831030718035257133033470431042111429555597381959609892666206716219532081847930970282959800999825630713834546858387640307817593411764905032303294057112362597297253851687870254992314351948709124427458348128204263663881362955482132512838054738519685384575921373737470245719421223898475756247409282692966862335515090757754459242168056461013405091180148696649963461602177212697836496306046456138474445624214914814699390257673835554848791003397055
c4 = 260074379614284795599484546451240257157763532480505168853160303924952553177325935242853666448209970957052626857104522597130316456316378917529016900063473199051496246209878864043477905068893003923546332891289993179385753129868269775271722630762054161951558359984426822705582509592976962739279251035941138103001411061238095611738024433238447078804016593599525582868080696498271912174235479368671466666819582104245707176341268617126063957318342864903403961673418935623112290599738566078566393961145470677825235949530460449737989243772214379341818676279908757907698136648847166264635580606733816599243489965651372128251328
n5 = 70199621485671842359044641866403168058670803503736686351887502686934276983786039926002198676793045683182125769300687612734657616494815167750772182403321230734527784596550124329071164871143795929191396166096178482901122962656943854107741654772981259089537233024363295465966490361367216383217631330482253245796203648485653095242684462412133029510769320566443165990471527944889669809129572843754832577807509454633886982402256837076791468127186325307925886447397529190962280905611709973103713165872442266384750885343667064502988575278416037070011939869923447549518023420261237007329747290577829325263253564790709373901618
c5 = 207467685064436795719671032825183115862587233648672449925340580227825675452627031507906214773278665727530027025673966750973641715014217092820995216768554881760711270444952703291126925400881160114713107315867759288572987159233984669439942981888636828978580980986834342715153361271280814208437227309185682033733871844684874967978852089340054449142896831217885786745795842561143568848428620959961049292832772489885193639646881909425599177539209159664137785111991625129191354004990699226809474030005545318219197509201907072684957499981194498761673049651408375607248956494019809957851295451628144493493011699904221882421955

n11=n1//2
n22=n2//3
n33=n3//4
n44=n4//5
n55=n5//6
c11=c1//1
c22=c2//2
c33=c3//3
c44=c4//4
c55=c5//5
n=[n11,n22,n33,n44,n55]
c=[c11,c22,c33,c44,c55]
mm=libnum.solve_crt(c,n)#使用中国剩余定理求解合并结果
print("mm=",mm)
for e in range(10,30):
    m,t=iroot(mm,e)
    if t:
        print(long_to_bytes(m))
P-1光滑
原理
定义1：一个数n可以被分解为若干小质数的乘积，则称其为光滑数。

定义2：当一个数的最大素因子组不大于B时，我们可以称其为B-光滑数，例如6=2*3可以称其为3-光滑数，12=2*2*3可以称其为4-光滑（因为2^2是最大的素因子组）数（注意我们也可以叫它5-光滑、6-光滑、n-光滑(n>3)）。

由上面两个定义，我们可以得到以下结论：
如果一个光滑数 N的所有小质因子都互不相同（即 N的质因子是​），有：
即
！
​

证明
先假设题目中得出p-1为光滑数，再根据B-光滑数的特性，我们自然联想到用费马小定理配合求解：

已知p-1为各个因子互不相同的B-光滑数，同时p为质数。
若a与p互质且p为质数，则有：
             ​
又因为p-1为各个因子互不相同的B-光滑数，故：
           ​
即：         ​
因此：     ​
说明p倍数可求，又有N=p*q，所以：​

通过上述证明，我们明确了因此P的可计算性，一旦N，P，Q知其二，那么RSA就得以破解。

一般EXP
a = 2
#这里选取a=2作为模p的生成元并不是硬性要求，在2失败时可以换成3，5或别的
B = 2
while True:
    a = powmod(a, B, n)
    p = gcd(a-1, n)
    if p != 1 and p != n:
        break
    B += 1
q = n // p
例题1.
from Crypto.Util.number import *
from random import choice

flag = b'NSSCTF{******}'


def getMyPrime(nbits):
    while True:
        p = 1
        while p.bit_length() <= nbits:
            p *= choice(sieve_base)

        if isPrime(p + 1):
            return p + 1


p = getMyPrime(256)
q = getMyPrime(256)

n = p * q
e = 65537
m = bytes_to_long(flag)

c = pow(m, e, n)

print(f'n = {n}')
print(f'e = {e}')
print(f'c = {c}')


n = 53763529836257082401813045869248978487210852880716446938539970599235060144454914000042178896730979463959004404421520555831136502171902051936080825853063287829
e = 65537
c = 50368170865606429432907125510556310647510431461588875539696416879298699197677994843344925466156992948241894107250131926237473102312181031875514294014181272618
分析
我们看到代码：

def getMyPrime(nbits):
while True:
  p = 1
  while p.bit_length() <= nbits:
      p *= choice(sieve_base)

  if isPrime(p + 1):
      return p + 1
我们分析会发现，它的功能的从sieve_base中随机选取数字进行相乘，直到得到足够多的位数为止。最后还要判断如果p+1不是一个素数则重复上述过程。
简言之，我们会得到这样一个素数：​

对于sieve_base，我们可以跟进查看其描述（在VScode中你只需要按住Ctrl+光标点击即可）。

# The first 10000 primes used for checking primality.
# This should be enough to eliminate most of the odd
# numbers before needing to do a Rabin-Miller test at all.
注释中解释其是前10000个素数构成的数组，也就是说我们得到的p就是一堆小素数乘积+1的结果。

对于该题：对于p来说它是p-光滑数（因为它是素数），但p−1包含很多小素数因子，即可以用上述结论.

EXP
from Cryptodome.Util.number import *
from gmpy2 import *

n = 53763529836257082401813045869248978487210852880716446938539970599235060144454914000042178896730979463959004404421520555831136502171902051936080825853063287829
e = 65537
c = 50368170865606429432907125510556310647510431461588875539696416879298699197677994843344925466156992948241894107250131926237473102312181031875514294014181272618

a = 2
B = 2
while True:
    a = powmod(a, B, n)
    p = gcd(a-1, n)
    if p != 1 and p != n:
        break
    B += 1
# print("a=",a)
# print("B=",B)
# print("p=",p)
q = n // p

phi = (p-1)*(q-1)
d = invert(e, phi)
m = powmod(c, d, n)
print(long_to_bytes(m))
例题2
from Crypto.Util.number import *
import random

primes = []

for i in range(1000):
    primes.append(getPrime(64))

def getMyPrime(nbits: int):
    while True:
        n = 2
        while n.bit_length() < nbits:
            n *= random.choice(primes)

        if isPrime(n+1):
            return n+1

p = getMyPrime(512)
q = getPrime(512)
n = p*q
e = 65537
flag = b'NSSCTF{******}'
c = pow(bytes_to_long(flag), e, n)

print(f'n = {n}')
print(f'c = {c}')


n = 210488679270475701976181947365152313699517734264122394812492020724654505220623065289117447808270300405893088216711827935540458944042230307295703758023289811232234667671779565383964487868833609515040373751117785890923111021052281871560758159098018301948230396406718130378740957192704249130990473406094468375190967933383609736557
c = 136071043914570532351840574748667342595827512223368889758030473691165475344493240895540489846178990095609930878050872170334417124306746585253763197947342333489768575699470163018093386136808345465103492262428343569799463896437045282842447134475696863670001725029430508792000363373891006638520238615750531296612676072986388618657
[12817836240916621099, 9796955111076276721, 14260192631353157767, 11331104417992923271, 9514036759383573643, 12830010251405547647, 13614319430115788837, 13292666469666083977, 14743386631123002553, 14117202746451676457, 13269748845129713117, 12168813134511397211, 17228879457544885133, 11476468574713278067, 11946685680111967199, 18345865007923209077, 18303664985620995833, 9822277703479114283, 15178066358256569473, 17098068971695098757, 13618686975649185601, 11744366650084293437, 14752193726031278261, 17843527472060726393, 12389668794044063273, 10376034649713785869, 12238540175552034637, 17132154884907233137, 11734611387998570581, 17011805096670339443, 11625121908845289409, 10757305216406425577, 12462221960790002209, 16018515046461158299, 13961897238779389541, 11607654254039926417, 14764422702778633637, 15889835560738915411, 13067226817787067883, 15887483815693916443, 17641812946382237687, 17751437011380057229, 18384735831631526519, 16918144377393116651, 14150464978154164637, 13178350295174895967, 17995769690138536847, 16340079015339247603, 9398681247575712871, 13634353827184119163, 9611544156521225383, 13453176756459641471, 11303353946688525031, 18109038864474076559, 15045485267231590583, 10972199753934977179, 17574722479092926033, 18278068689901766303, 16948848653119121327, 11758909188247026433, 15665449198029497387, 10901691956952449753, 10584519935735226743, 16912467675047183959, 14327261172669596407, 15097367563320670549, 12297273221784672769, 15947284817142437047, 16781387148892629007, 15881303895526705733, 13045061948663850751, 18436681745005029761, 9233724300944854859, 13047527195762392259, 14723757760242013169, 11741005205965231159, 16408614260735211923, 13814776270447837021, 15906163142517891569, 14423435831173412623, 14612928719996598469, 10885120118770555303, 13368686720584342981, 14068267570818591737, 9868356740416745089, 12406920698251977319, 9286022127447238097, 18023608417081960717, 14923516882492986133, 13823678708930659963, 12857551861722029083, 13230742121296437271, 12729591066572154191, 15849174322092304703, 11085431171727680393, 14068906847806320077, 13851658642377888133, 12875459865393464869, 16373459542443249833, 15042636961965421789, 17804579165451279653, 13220312902184268113, 15150287797243551839, 12346428755895098357, 17020549628614536703, 16886745404527188301, 18375430790398618129, 13224710597451808487, 13359444437510262103, 11873826262101064243, 11965351035977107903, 11235458928878258717, 12997583502966109111, 13789872877795337753, 9410284081150637203, 18303250922016774599, 12282563435683491241, 14305213835649582409, 11918623460221018469, 10943597593864147127, 13038337723454095519, 15455421326799165353, 14062369863925079513, 18367836708310870171, 10613492300802961321, 14459256689604923461, 11706673732895890387, 14382736049526145057, 16655509777788355597, 14000284683606298529, 11290821241077537707, 12847958971987427681, 13809253826547615959, 14684126452952111143, 11855586041954042173, 12714825000812576869, 9459493996196289107, 9842932973342874239, 10570590695078468843, 14410685183194015117, 16898517162308994587, 15220517599820119309, 17333608782273432163, 10377521770815190027, 13122631859485901471, 11571227468583314827, 11817889822931972323, 14228001997887128497, 14456085940081475863, 10270130489745680131, 17517555821987735831, 15429383763760026979, 11108995892538667811, 17911418867778656821, 17139731172232986937, 13426013319525942679, 14562642807139379233, 14531693252415486269, 15631238547467725579, 10320658119201020257, 11575894205699157263, 15384475741355621261, 10764073960673003609, 11153595693401172317, 14790585109191523507, 10690672323080867881, 10357625576156190589, 16431064857205643717, 12130023867007235381, 13564898535871926389, 16337575470726771133, 9618083378800557767, 17232134619106506173, 16342365536104729669, 17290061582737251799, 16670033868010116101, 16394458575620757607, 13679014824205066283, 17991831450196114597, 12317978714944305947, 11632115207816943743, 15797700688884441463, 11075555837128820431, 14881723251235989661, 10010880757411909987, 18270144545531928449, 9465870609311716069, 12582412206542381803, 14662660113361450837, 16112922901618122901, 15363650898935547023, 12533640949094063143, 9470733380298789667, 10096457749634891777, 14406227249889370421, 12890530725415748549, 17792709587851953943, 10409603150957944463, 16280446889224274527, 11347835861520223063, 17984512079289457829, 13366696032094869983, 15399033257453518289, 12925451097314982419, 10778713773001593313, 17284945985665888051, 13402816621446294619, 15528594004221819047, 15809192880967976213, 13251703483278993869, 12208007531464953347, 14651975501449610809, 10384298003710994317, 15330372718569145519, 17248847366496290681, 11854891655415812011, 17751134388906831949, 10124732408491652509, 13625466395305938587, 18200378429690571427, 17452972356845950849, 14900945233126132883, 11436315090796776343, 16581798874532357771, 15111242773400135623, 17641315625748809411, 10450595023153090573, 13264757738530097911, 14485829224324514741, 13330871005549345411, 17136650784851341057, 14910153824569971467, 11210011057574992181, 11177037566749571093, 11567028438251098903, 13198253645284080859, 9785835301058295319, 11870911273186997459, 17086899150352287461, 12688798468940186353, 12829816797037704869, 13850020717472465033, 13962611682980549657, 11101821698837041481, 11707465921615682923, 12959209007506476811, 16644144509323715441, 10367003935119200813, 15453978273858403009, 15167350154202134803, 9368800879722378161, 11455175913776290139, 12851750838491254999, 17944785619839501011, 15794784996188333269, 11020878345656646503, 12895215750829198793, 16875096766698669563, 14118851151285954833, 14838789173869952831, 13751766063230858977, 17320191755949110401, 12060022464165785371, 16746856058764394767, 11340262053390390623, 18063813798829005593, 17301743539019024441, 14582876446851166253, 13522319333542791731, 17645483968819162681, 9674664037282811197, 15042492503708901197, 13403260615183814477, 15357650346222449437, 13587415537998132773, 17790598348568475959, 14937073879575692303, 16946217240852764177, 16406234190000264941, 11235987239543284367, 12490317539195443457, 10442876360637230507, 16417744334203076861, 12058149621525280003, 13299492327856068067, 11314451949936901933, 12580137629414492233, 17187303597929461189, 11472019543632605501, 10358023847683468963, 17655020163619780043, 9551405925019296407, 12313496295674301209, 10693093530328277813, 13024645634541678097, 9897976814256674623, 12205181340503455921, 11417228617170103249, 12826004690606531803, 13639934695225511677, 14590472153531475251, 17909159724817643663, 15533310761093773937, 14386571855319704297, 9316892936362161067, 17993944869296641759, 14759692394249822753, 18270460879245227951, 11182120139434421927, 16177012907245614719, 18028663420331019887, 18139576777474000879, 11213134310805448589, 17936183694734803343, 17975442509209584199, 15559262723302226837, 10180836740719706297, 18197598310364802337, 16827523931763080353, 18214986373700605081, 17585494217763004861, 11448026570948864933, 10900056287904330073, 17166645406697902543, 17570484141533117293, 12398389280142315301, 14630567076893376083, 10833999841227994577, 13299004526654333801, 10244054538116403871, 12907824831930739939, 16885467716977238273, 13880284027516293029, 10887546467303319323, 18068389832047177387, 10450635565653187523, 14726030363122148237, 16768133481946424951, 10301298929545489007, 15415018517648901401, 16206238099391413103, 16263750958615351591, 10054000098803084741, 17081860428453965453, 17951459452539869287, 11892815832324644093, 13775418173952588841, 11507176664859257743, 12436316449453831829, 11373445294062449503, 12707349516508026313, 17304366121752246923, 15088976801734008287, 14882686898562658859, 13312883733509401117, 11175338376664870423, 14995241990449050829, 13984129139378165623, 18263293614524334931, 10991047462031450617, 12865816467095731189, 12198009780829783649, 16748296422094146653, 17904593640666707729, 13792268569149446983, 13853849612423089637, 11546534301480400423, 17137023443158040753, 17905444488998063857, 11980813095592929253, 17915972690674748693, 12451065502875272893, 15286203704429102609, 15961659110687401169, 16879684083254701141, 11466389710715075681, 9862223709098321893, 13427540762341339663, 17120171216590076191, 11328200399967258851, 10181508980912484023, 15114850231267812229, 13401368952119603083, 17310327686592116461, 10812290766823212593, 13321530124771363837, 16916384745420105733, 13158876505531892249, 12781125756513915947, 11177172300491135033, 15192519949009579177, 11107570709578280603, 15790871007179692423, 14673525326882261659, 16625393027047576363, 12208173252153948521, 18151011223033756559, 14150927812081733711, 9962724536266278113, 13883267417298402779, 12239907647067385063, 17851351494511502753, 16218780803683512137, 9231060907590526171, 12561800952561489217, 13912140573946770893, 13149132600571773931, 18113853656519618927, 18288722620221293333, 16238398234781792947, 15646176443969341973, 11480617125273259589, 14298265531428974159, 18152443754281945309, 15382191810022993691, 13677302948532689779, 13044467560942628911, 14180490201042674161, 17699382878024999029, 17295445764705446263, 16639917043083590129, 18119370341032732567, 12154128334903051433, 13164685890717792107, 16936772055385035967, 15096483065553525473, 13471209141541779203, 17378837190351254407, 17426974534141344883, 17959141780827119891, 15016498199784708659, 14421160967688875941, 16740532654485547157, 14936157018002326123, 13256118391055166017, 18174072117119534467, 12090575013064577347, 13006876700311968451, 9238945670292014191, 14213473652368499983, 14243331673872027131, 15857539045385929681, 13412686116627591491, 11592325887070165747, 15608925272834295691, 14666236964631839891, 13540685243058340663, 18270373973909961613, 13828282470103450277, 17892440011286210501, 16870901545940692091, 12413729884613628023, 9266844013399220221, 9745512147631925389, 16387537652784438451, 16570045942363855537, 10568791466436873997, 10182396317953610903, 12853823905502858353, 11851841417409724277, 14115519128426356727, 12881420948009143253, 13130088098325861749, 11721786782351310083, 11236214958267547553, 16702899637167067903, 13501762358014708543, 17462031538915936859, 17276389012007923211, 10644899384346664337, 14027005255127061913, 13530526660154644807, 9844415966928882743, 11249128120835910791, 16777866679514313817, 14453045993106743699, 10996863066540575321, 12283642992171368333, 11404591589887867667, 13677761664265732687, 13110578735652791741, 16010046184639114171, 12753941270332721647, 15772567772565704131, 11831712320633880293, 13319727865432694257, 10771551848090338763, 13480980853991727469, 14248794265347244051, 10664170815864253153, 18371374206685581661, 16482126216840379091, 15311554751751063719, 11347740685464268973, 11911625562195859271, 15948182894664837227, 15833902828630883027, 10628744258695587949, 12242229966886189549, 15729900088141513717, 10331962319086103687, 17739760722083508421, 12122206963635673601, 13444533154829926777, 16919840780438603417, 14181132415499287453, 15832764916978218089, 11107329810687234827, 12537867916219452571, 15179335658283523219, 18157750076527384319, 11335208638879830449, 12778309804903027751, 12331094589527085751, 16517169709337458391, 16074354330760224817, 11121010187417970569, 17541225150843770231, 13072072021644732583, 10683918634042372291, 17818396544323153021, 18097213311786551693, 17377696366492674853, 17840289332463757343, 12300868091354913911, 12110148694323274373, 18183424490112093451, 14470426956322731539, 11537900791630973609, 12288308024287816769, 9416608386548247127, 16142185824626408983, 15319391474385481709, 17427093242388654611, 15757681760350596491, 9375203980011408289, 15281050099968592837, 13962807632993334377, 15641960043003280541, 15857385507932475607, 11328494963300401669, 18165773294104417547, 14012380629632910359, 15541214952410221769, 17008189780920470053, 14632891822044772337, 12404052309147249313, 17208994155033269833, 10635749760511488169, 12320122505182031957, 14796692998214399561, 9673910288177915309, 10047903793961297059, 11326483999844129969, 14635083490823091097, 18071773072169124043, 11341815024873111347, 9438792655485507689, 10008152749575925909, 17567654747849893279, 17061517364811209911, 17221503802511195443, 16695681584397997897, 13081948422266488091, 14625725701559358637, 17169462066133068869, 15709579351595465593, 12209792348258846639, 12122275607677157911, 13807547725741290973, 15583160659433004293, 13396260775506371641, 18217020689915921843, 15619329053256302987, 14146270775635402231, 16863952377303204673, 14548776148506068719, 14529188722082059457, 17265380804141201681, 9776286763289778197, 12466859136109077443, 9772744223809808053, 14470786313269634927, 14607320696711471221, 12455737005988354019, 16637246382861080953, 15133708215096275683, 14847081677445301901, 10332654304000904033, 11159603116014973271, 15931004335130864743, 11477160443275710217, 9535586193995849951, 11293175983668556793, 9923153586904495507, 11933006027142853931, 11128574253134634017, 11076766797263201329, 13515870030341559941, 14622814541338434853, 17463892929742334407, 12615007904997547229, 18206100766716434933, 11455838674150852697, 17479338037013854559, 13360281258747049621, 10995035322560010517, 10928474912163737647, 17726175981976035227, 11704404121506907637, 17619146892908914121, 17704564527305769329, 11812175367635269621, 13416429352943032249, 12131563217847962351, 12183503097530938127, 13981143659247294641, 10634933508011331559, 11562423714401189239, 17688490613654951281, 16861173019672178969, 11053050244878979411, 14086304443079658787, 10578453109792325141, 11682151227114266497, 17000674853229930419, 12598355342131798913, 18392805884632295521, 18431468816652818879, 10874622447515914201, 9872938674493987793, 9744625343948785841, 11255274706725187783, 13530191079590038457, 16173365083190310629, 13224430590784162699, 15969778943599937653, 14043089726984416741, 13781348214896464493, 17182476995296609963, 12896436977884956841, 15077836731319621141, 10080593144973733229, 15891293339878516513, 16043377959654964921, 12784208144845810363, 11543219604826483837, 12024729597387644591, 9777324062326177771, 11527333015686779569, 11474993589954273647, 10182859812157362677, 11376680767502967977, 13996225568082222469, 15977867067599549579, 13655821277773358029, 13297113872058771941, 9897159622397740493, 10013043069023436713, 11531819115816693283, 13710715432898401733, 15195815565078492053, 15452255999389129147, 13604937934214924243, 10904911638935266651, 17580607694180244349, 10376618524272533669, 9571446041130564469, 9825683462733434701, 14468571684404171527, 12770922639680720219, 18167455477803076531, 11465084556247891097, 12746847720200807209, 12775769479808373047, 16393448046945064087, 11652620391412172563, 11478574931730042203, 12270257063042073917, 18023307951026693759, 13974408232745028701, 17780249113700985763, 11355073357007701631, 14471311142350516427, 17473300039363624031, 9777054399339418903, 17919523597873134539, 18378677639427969179, 16777121138942295433, 10168805248401432883, 12641872323183817099, 10116977178009093853, 12176766460209633133, 10318924588276162217, 15546400482337419701, 11832021544471242827, 11215298551637042363, 13865628369013960619, 11129154280835514367, 16222330145886628943, 10818887859000996101, 12468152598968308903, 13676585842283059039, 12921766523283173867, 12089564821140624607, 10225474175631159121, 15819547992851766347, 10182914408006996497, 17167878424092859061, 11514181842204916613, 18287116051767400657, 13272824243652359389, 16648019410746154129, 11920726101309487981, 12649244363524402771, 10550622175590275827, 16618529989972308329, 17515407948374854423, 14391969260138111129, 14759186383646463271, 10919403521211062401, 12185965786265832247, 12116710629039649439, 18433362234939139601, 15965694148547533529, 12974211820712657803, 13353321620267206573, 17096739903159443939, 16696518371292656759, 14462358883896548437, 11367744283307543293, 15323226004742755391, 11746436008806326197, 10920871861266559943, 11587724236478293867, 14992265004480347113, 15708312669494860931, 17916196036842304759, 12922134467647572521, 10454128140476511371, 16430520042575406421, 17076469495651100089, 17772189207011073799, 13384875880146838373, 13935012923273198147, 15240883815131987791, 9420660305133379817, 18240375964640868173, 14678307842794601773, 15288259585116606757, 16610633684634874867, 16486217839536541813, 11661546558365415463, 12152118203599876189, 11800253185351909913, 14374602260090605153, 10449913208502792287, 10009143259393434427, 13307738699651704159, 10654277669677635361, 15407444571115834129, 16834689677973985291, 15066169839778509209, 15475733561257809121, 16380412207874211983, 17194107447716508143, 12192621570297038107, 12240237512637106837, 10441056377505748681, 17495542058396571671, 18293106931869404749, 13865897548876531381, 14113466667785343973, 17525437199295255289, 17422068598489386241, 17287527045122701379, 9455908640325923213, 17335751448105539767, 13590715372748461303, 13209806666168836589, 10261162812051097369, 17733334183472849531, 13246213547584426837, 17766000084271444483, 14150582008333438807, 16133690731517495399, 14641711413776366441, 13022351466394992461, 9226681052162486651, 12760195383928077577, 17567872876849046111, 12340487597227543063, 15563748447258497573, 15318459465935920571, 14255243227091610833, 17062529558035843303, 16176535147083208321, 15827087675880312413, 17271698018463248329, 14142147620294354209, 13914535203046847609, 11613211706825082407, 12959862789560256293, 14016596084494475893, 11293492671321492157, 18421116955007051749, 16404448288688945063, 10841598730147032461, 10668072389421742417, 11551364596378565711, 13850029337813227861, 11516141636470693969, 15920496765925322419, 14276274249919823203, 9237568470631580119, 18381932334031688533, 17659877642674983931, 11159795358572892799, 18206258071410742637, 12280903436314972243, 16038761168382463333, 12461628152852020297, 12599866901700933119, 9503462554473103217, 11481782370632833811, 15766095164814323669, 13079723298271643593, 9272657104293910643, 14060047426801456841, 13335454529166743357, 15841992693734542661, 17764709418538501487, 12160915899913859321, 14713689640122062573, 13337663648949716537, 18211158405283472779, 15158622942577374571, 11407833997760128867, 10508929620338632321, 15961989193725497063, 10501876330362297371, 12364784867218660099, 10131314553714497933, 14441100812606959489, 14721325750202554117, 13167419766289684193, 11981676591145933817, 17913851093510662607, 11835488665953985127, 16780953686692778041, 15608609099671724267, 15664551105384515119, 12802145189741653877, 16805549931391100567, 18445301756468541301, 17655249735232734959, 9689891077025566237, 14840484494159775929, 10723334034602592439, 18386904850027413517, 12096629257610342447, 13067964115598968019, 12252109817674770679, 17369822671514623363, 13509155615162956807, 16855863641920860103, 14465746296157191683, 13544016597391911559, 12971969005041850273, 12280334067500075587, 15752570905864769503, 12113525236215732611, 11664013792437359831, 10228837640437031773, 12109791131521690777, 13624111940052646099, 12777090183758952047, 12426963274674728939, 11441470375408996129, 9257227171899364921, 10191312647768104939, 11865326812561002887, 13522604753854591261, 10249599313373359463, 16159615612202096369, 9836233098999799211, 14799557554105507697, 14042255386918619699, 16477871730966758129, 16642525196644416059, 12423008258752432981, 17273875260714952171, 9470913631654644977, 11887078253521363603, 16706376900014360707, 10304459396140054031, 17693305758580051121, 17214391436952288473, 13618743595320511073, 13169249530153192079, 12035858011919909029, 12860667847247804537, 13990854606273162281, 17035861733161781977, 14770109568091276793, 17949815755824751961, 12390337922014329203, 9595001010493198999, 14690160353746242721, 16314094344794415149, 15483233288782887491, 13061397420799425431, 12076045453514601679, 15407273036788472813, 11365402888927879361, 16668884373589636511, 13828335850402659011, 13284203923815359527, 17300809842931614721, 16947803187487136093, 18225750745362866369, 9284672876803885567, 14597852340551274989, 16473939500074387811, 14300584548546758897, 10466932272724101787, 14229473210374543483, 13248150377350757731, 9598039034657163599, 12586816162498814623, 11159150798363316113, 16077108181795072301, 11161401146827356863, 17852976451365316379, 16386970647736403383, 16568117397633516523, 17674878979814499799, 14520861146176965691, 10340053725357332591, 9799386102480704957, 16097477422918098601, 13239453234793950397, 17567007567243212159, 14136045876498729691, 11732340248501116493, 10470310463829179399, 12703325772051719383, 13035241397098055021, 17395156339749341267, 9668529469335994589, 14249010465960845651, 16914660786225731381, 12310520468883701851, 16246592021694289649, 13480017886196771549, 14219082481229344661, 11647439617192501739, 12765954006551032897, 10460413869136300141, 13716846676298104453, 14503448822338349359, 11041742165867028397, 11701704236558588467, 17606212925100148273, 12342707180459270959, 15360511526093354189, 11298030030747659447, 12872763047261841389, 18232938457364630449, 14660255297113325941, 11890851251611038169, 16792857595881777097, 11852378876588707279, 15357599751372293533, 17780342512970330669, 14195457757956580333, 10658400270468681989, 15387143294376736159, 10267219662942666551, 11046696135185833781, 13885088134451378279, 10645311967978806011, 17659494527222079353, 12862971250844658743, 15093229194999614917, 16241065349609244691, 17076182031924555031, 10410526641699080551, 14619036188529238943, 16435691426252481919, 17757270819329871647, 9244265187799778663, 18317093359569022523, 11159244222937462369, 12404088147132662621, 12503445554528532469, 11834507189075821319, 16399491741674305727, 17314200642630424609, 12461073769029981829]
分析
刚才我们说了在P-1光滑攻击中我们要做的就是得到一个可以覆盖所有素因子的数，显然在这里我们已经知道了P-1是由这些素数构成的，所以我们可以直接从primes中选取每个pi进行计算即可。

EXP
from Crypto.Util.number import *
from gmpy2 import *

n = 210488679270475701976181947365152313699517734264122394812492020724654505220623065289117447808270300405893088216711827935540458944042230307295703758023289811232234667671779565383964487868833609515040373751117785890923111021052281871560758159098018301948230396406718130378740957192704249130990473406094468375190967933383609736557
c = 136071043914570532351840574748667342595827512223368889758030473691165475344493240895540489846178990095609930878050872170334417124306746585253763197947342333489768575699470163018093386136808345465103492262428343569799463896437045282842447134475696863670001725029430508792000363373891006638520238615750531296612676072986388618657
primes = [...]

def pollard(N):
    a = 2
    n = 2
    for p in primes:
        a = powmod(a, p, N)
        p = gcd(a-1, N)
        if p != 1 and p != N:
            return p

p = pollard(n)
q = n // p
m = pow(c, inverse(65537, (p-1)*(q-1)), n)
print(long_to_bytes(m))
这里还需要注意的是，这里我们只遍历了一次便成功分解了，则说明再生成p时没有选取到重复的素因子，如果存在重复的素因子那么我们得到的数可能不会完美的覆盖所有因子，此时则需要增加遍历次数以求覆盖掉所有因子。即上述代表中的遍历需要改成

for p in primes+primes:

或者更多。总而言之不管题目如何变化，在p-1光滑攻击中我们的目的便是覆盖所有因子即可。

P+1光滑攻击
例1
from Crypto.Util.number import *
from random import choice

flag = b'NSSCTF{******}'


def getMyPrime(nbits):
    while True:
        p = 1
        while p.bit_length() <= nbits:
            p *= choice(sieve_base)

        if isPrime(p - 1):
            return p - 1


p = getMyPrime(256)
q = getMyPrime(256)

n = p * q
e = 65537
m = bytes_to_long(flag)

c = pow(m, e, n)

print(f'n = {n}')
print(f'e = {e}')
print(f'c = {c}')


n = 63398538193562720708999492397588489035970399414238113344990243900620729661046648078623873637152448697806039260616826648343172207246183989202073562200879290937
e = 65537
c = 26971181342240802276810747395669930355754928952080329914687241779532014305320191048439959934699795162709365987652696472998140484810728817991804469778237933925
EXP
from Cryptodome.Util.number import *
from gmpy2 import *
from itertools import count

n = 63398538193562720708999492397588489035970399414238113344990243900620729661046648078623873637152448697806039260616826648343172207246183989202073562200879290937
e = 65537
c = 26971181342240802276810747395669930355754928952080329914687241779532014305320191048439959934699795162709365987652696472998140484810728817991804469778237933925

def mlucas(v, a, n):
    v1, v2 = v, (v ** 2 - 2) % n
    for bit in bin(a)[3:]: v1, v2 = ((v1 ** 2 - 2) % n, (v1 * v2 - v) % n) if bit == "0" else (
        (v1 * v2 - v) % n, (v2 ** 2 - 2) % n)
    return v1

def primegen():
    yield 2
    yield 3
    yield 5
    yield 7
    yield 11
    yield 13
    ps = primegen()  # yay recursion
    p = ps.__next__() and ps.__next__()
    q, sieve, n = p ** 2, {}, 13
    while True:
        if n not in sieve:
            if n < q:
                yield n
            else:
                next, step = q + 2 * p, 2 * p
                while next in sieve:
                    next += step
                sieve[next] = step
                p = ps.__next__()
                q = p ** 2
        else:
            step = sieve.pop(n)
            next = n + step
            while next in sieve:
                next += step
            sieve[next] = step
        n += 2

def ilog(x, b):  # greatest integer l such that b**l <= x.
    l = 0
    while x >= b:
        x /= b
        l += 1
    return l

def attack(n):
    for v in count(1):
        for p in primegen():
            e = ilog(isqrt(n), p)
            if e == 0:
                break
            for _ in range(e):
                v = mlucas(v, p, n)
            g = gcd(v - 2, n)
            if 1 < g < n:
                return int(g), int(n // g)  # g|n
            if g == n:
                break

p, q = attack(n)


phi = (p-1)*(q-1)
d = invert(e, phi)
m = powmod(c, d, n)
print(long_to_bytes(m))
例题2
from Crypto.Util.number import *
import random

primes = []

for i in range(1000):
    primes.append(getPrime(64))

def getMyPrime(nbits: int):
    while True:
        n = 2
        while n.bit_length() < nbits:
            n *= random.choice(primes)

        if isPrime(n-1):
            return n-1

p = getMyPrime(512)
q = getPrime(512)
n = p*q
e = 65537
flag = b'NSSCTF{******}'
c = pow(bytes_to_long(flag), e, n)

print(f'n = {n}')
print(f'c = {c}')

n = 345799778173748173773868120733939877012606206055022173086869626920649670201345540822551954372166638650313660302429331346299033954403991966160361903811355684857744142271007451931591141051285664283723609717718163872529480367508508005122335725499745970420634995317589843507796161899995004285340611933981932785753209168028330041659
c = 246232608531423461212845855125527519175008303736088113629990791124779986502745272419907699490375796645611551466345965328844415806242069890639077695943105766009969737068824735226917926112338655266209848386322013506145057902662138167248624945138207215690482597144303445656882230801297916736896978224496017358461492736283036138486
[11400500846732211437, 15663612686729436797, 16146509422571674241, 10365633794353033223, 17764432204956231427, 10770086682509726701, 9363619846718624519, 9499148531156874869, 11870308229801920153, 9493684235948177053, 13439889213792762493, 13543824553169466691, 16784144744729574109, 10473345639906795589, 11686628555687269949, 13438006849184657287, 10304115634530565157, 14523860318465391989, 9647953497087513131, 14024608681547907539, 14323731752105690329, 9995822499706628503, 17263798266448817081, 17412342258647700379, 17552446328775319979, 18182174233675599269, 10926506070008989781, 11287875928373292151, 13031874421918467239, 12826862978863344077, 14427019901941927789, 10764280028896236377, 15204422422736985733, 18013581759315499403, 16196860580398627489, 12409133067619366927, 16982209362087366071, 13552847891288053379, 13321664796445708301, 13503601532891509847, 15213413154033638143, 15789125900714604107, 9661259098414185323, 10097901158936073103, 12492567105127893229, 9803017918077701719, 14959766528145744073, 16380271870181847503, 12379170631770822511, 11203599319503847699, 11697577879391178041, 14830577847345979507, 15161718518020147133, 9449134020600011261, 13590570970475252977, 14435422638900288329, 12478310842333840183, 17177994464705553637, 15072278791274696881, 15805713015714544379, 18298117834725348649, 16592677662893953627, 10360712314766543039, 12350365014973219109, 10487476039094034247, 9303193137466554371, 14317509909121736027, 10069727352579607261, 15672913494263557921, 12645137927662029131, 12577294286343986777, 17990217715164074353, 11770491954898217693, 16352325276206313631, 14742366552931089511, 17904845678435279687, 14896783599885913301, 11640348097370069257, 10229197144755015913, 16348769379755789849, 14815902973349076617, 15808546541834061079, 16180999769759067937, 11333835834203173919, 14349619526753022311, 10887563403726040387, 14696465704976418401, 16612699690876026649, 9242002307438002549, 13294711665781655819, 17316060056875475509, 16264270500305765159, 10143806453587312567, 10156382001678762061, 13424697447914832193, 9533479368240114361, 17607602236552058431, 9513935785246155433, 9348999429693542821, 10687833447600343907, 13029642955293734383, 12352583868905249059, 10578933735997257233, 14807418828818185841, 12723999174902787061, 11812631981548150111, 9469570721445804379, 10407923494920638191, 10559989029436270817, 12477140185116458017, 16418595676222668931, 18284009827664751383, 16879482079149887887, 10274017234103862649, 11495861205598434163, 13574496359130781637, 16347895315217629291, 11184342831473200427, 15117572072516544349, 11962165465299205687, 12593274795450046759, 10576401623272055507, 14871424922307314839, 9683965597938835439, 15649192958998385653, 14136512522186754793, 16189574870468706193, 10432462783789785083, 9882402816632001041, 17467673636368162091, 17812738031541243181, 16444195776814377667, 14458128171493667993, 10068762164183818769, 16785805107381133639, 14471872315245024047, 15256999419456872801, 11245045254273493879, 12432915941937754661, 16779879208564650527, 13527359679120520799, 13609212316987142881, 12048851866296673223, 9700737321821517313, 14378798305839284857, 9611124475271266561, 13852359141963480583, 11482735530462856063, 15354806409837420893, 13941285484258063727, 14725649345415301957, 14540375648816209781, 15268062151789994279, 10710080489577786817, 15918894791610440369, 13679067272608182587, 12130148919788574667, 14787273033558048851, 16823039346693535453, 9786912554506032653, 12271391359749298573, 10338204530215094879, 17031700055987188007, 13892013056459801951, 16466462551586874361, 15509765092722859157, 17798707991935554641, 16724399949431954029, 13950635476447170409, 11844033699047785357, 14747361128582919509, 14667470964266641091, 12896901039793154849, 15536822808734549341, 12385771205898361763, 12265293491880919333, 9519013453753799311, 10399041997001597659, 16593843155091891947, 12731251001624534627, 15446540709384042589, 9977945635496326949, 16022582598611495171, 11602170089144567501, 14556919126878807737, 13325795480553101047, 12141291839761394549, 11056079849427396533, 9319147679594339663, 14076618445093460089, 13279302183770932003, 15969822774426507863, 15634577535247166641, 18134435225679362561, 13580840906683365127, 16932745671449749507, 13861858882551833521, 17059312054729866107, 16159631686544375273, 13252534105662820201, 12853863943245116791, 15045628398991754593, 16867564338626531897, 15053346821310993907, 15424243202794355417, 12169322810803770263, 17562408967112815189, 14696130091108860479, 16353873170264652727, 18137634119608386217, 13853870828606368123, 12138232181730621971, 17695562390286922187, 11482149834977336341, 11263040235574897391, 17516386258426598267, 11729599409349513977, 16344325675031393033, 9487998624331072613, 15548753174223167923, 16246946533494280441, 15168068556360396767, 10988949668785042289, 16578604258551502499, 14921063374278681199, 17959209918307585553, 13403422202954306417, 11008060381939288823, 11996269609545097451, 14304683665387573597, 15127244416475972951, 14638939931196152921, 13736677778855498231, 17587444419861411713, 9712574859471189721, 11754669647509862399, 13808458314511168667, 14076346964677125061, 14296229481633724123, 10546969810734077257, 13806516637777666997, 11595089909651297627, 15383693545718169527, 11899557291952040539, 11892231220794860827, 18090056242513773299, 16535424213022634657, 13429292459383177121, 10938466758053648591, 13247568010483593953, 14353179575611187827, 17247884385077903059, 15492418843846011163, 13991533281715009171, 10648224887308767149, 13434464420280213799, 18308741750842750223, 16958163859863247583, 17331583790580132911, 16594103882668531169, 15654309992707438321, 12143487125851071209, 13917462550122657373, 14300594316387726833, 11038403267265055433, 11668215065573927149, 16522831969819412009, 15574426807839180587, 9521082951973994111, 11184051603632666453, 17420808937992910057, 12911596655426162347, 14013571659883359853, 9255799220881949201, 10863148313680771943, 15125487406888857311, 10787391261037964801, 11181016652346500041, 12375758200228628333, 11096658214489080743, 14127930959020578487, 11097748121705255807, 9576959296273172197, 10329268625923900369, 12989481583199396267, 11221816342693962053, 11682824873199396701, 9726906501816888893, 14262866113962178411, 9585657969091757713, 11560990155825686603, 15431631822377633897, 9693653500895246153, 18052885089925870411, 12230353179628084643, 11140231161527021251, 11692996241065359677, 17325167313903580247, 13625405742824607707, 9700735722329114107, 17772484003012329121, 14710477009444476553, 11461459386714361369, 9710381370263165737, 14182228639237393261, 15344135038819224257, 13747712780102897047, 18043450369219899473, 10108489789901066423, 18323581078801222739, 11709502836760188211, 14510120896876508611, 10099898624211195287, 17361096065683222901, 15111530145788039651, 16726669802715322249, 15303048960860878433, 12918404780084443421, 10395837535719074069, 14881964221907324279, 14275096296552385127, 16767210669789926149, 16926825798156482309, 12118163891694788129, 9527147805191785667, 15014015486557066933, 16813575270918372811, 9593601949025443639, 13896995817956105537, 13741986219854107753, 11144899659720022073, 18238128043240764319, 12779733553193717153, 12771981722317523603, 17736020578173685219, 9340904375029821481, 17592111347118520843, 13580882292330428401, 15018369925699389031, 17809424700118883129, 11613026101864549847, 17286309683170750757, 15302812145728958509, 15391566078527070121, 9974325230682765697, 11551570786966900967, 11351003337990798203, 11120412046865048101, 9696688946725965169, 15093528920040797497, 18065996667394084837, 13292251568744035337, 11101213198305556951, 17531999985277474517, 15966406176658019221, 10691542704039725009, 14297474600370306949, 13621179047848909531, 12859649057819536667, 15917449527351930353, 9605987875906658413, 14998884139877113397, 9303906426219476507, 9871680222005313013, 18053630596736423699, 18214702298732770603, 15217549802969404841, 17230806139959259801, 9756053496476979851, 13493983446716093807, 15872062367640353111, 10830618212258286257, 13343744885931835489, 15379338915986533049, 16664848187297516537, 15913611403024361401, 16957002785994856157, 16999268043777708043, 15924602242524984389, 11470115363514206713, 17780900375430786271, 17219602318975762861, 15562078753739245099, 14429908225005981979, 16785776318383823977, 9345347283569848891, 9826037803806928201, 14757441108506302691, 16843056852903557147, 12089182103754698633, 13071844903007200927, 13309532659259919281, 12185211383730425707, 17671246663671372547, 15827919662605196687, 13921392459246207437, 14214028972975886279, 10666188887784923113, 15026095328389680481, 14070638370052382317, 11515225275289974647, 12733768797899627857, 15232090050353579959, 9605577513419872349, 11774332933083185117, 13015628182391854561, 12452018187207611071, 10613040759167447969, 16395318189590579111, 9650312608310268509, 16507662966772496023, 9745403684063805119, 15429094458205621159, 13907939611582114601, 14350669162433050921, 12444630576676286983, 12382608458977480781, 13701560178384085519, 14561536331132891843, 17870839403342285053, 17726305914129360941, 18120422155613702203, 11458486193501014487, 15652084560104054171, 16016407186905293131, 12896826502049676533, 13137573987547216019, 11993148289033574989, 12553485329707332011, 9407004537495583253, 16551197209131499807, 12188240888329030727, 13138059982433827393, 9447792088431441973, 13898552597307352607, 13086125839706222777, 11253297961067347699, 12473509293771699973, 12025629766486534463, 9246425606391056513, 10978614475595947261, 15328005120420669143, 15005188618611818149, 14681521764654667837, 18222824871931463471, 13727103721842925123, 11056314452399736701, 14190514709890056683, 16071925700301971681, 14114206274338698617, 11354892818254049171, 15558048570303377969, 9548803747853081857, 17588526935062502339, 10932175915126889777, 14848760934877079473, 16531929394433046437, 11059255418387621143, 15419998777650574619, 18133329784854851773, 9376742948363866007, 10267333769360440369, 10455930081787849081, 11749403554374261673, 12289480767522531263, 9355881077811916589, 16377906719131687771, 12636537540548202157, 15473661167864858659, 12939130785963130559, 10331428178834892869, 18403302396935375239, 12457052115957020359, 16728650241949106683, 15673023018343436269, 14566008317650142029, 10428852531127223779, 12989287388538384809, 10023218474904646751, 10216986934332559607, 11200524499033897849, 17374818422359302449, 11795887296034843123, 16260134950019402467, 15545049906898796849, 13905976122896835137, 18192952532376915133, 15245754103999312679, 14336092681672892797, 16711051263995536291, 10268633000776041389, 16298601116274769289, 12526591346109970043, 11057407454514514777, 17316528792225617197, 18057651102128098207, 16192203874370581303, 10293184135563422201, 9723556212482431513, 18054422790317350181, 17756547295472446751, 11552860515549111289, 13432033735566726419, 12179716429669289003, 14947157147090126191, 16335353494729459423, 15184076846117432761, 14777743253109667273, 13625241580579004263, 10998645430939015469, 13534322946405781903, 11327079738013968217, 17487263803711590509, 13189162879894145159, 13784538619743485863, 17064328079090046263, 9685004881707057761, 16079690295682955971, 13294545125605834661, 10648658009947462261, 18415164681671251511, 10641837226629144139, 15777331516260137267, 11795948058583766659, 15535152465440663291, 17216667014436648943, 9653047732094860031, 11131348011090342127, 16886193462362116063, 15612491590607382593, 10835879650784394071, 13279435351244340899, 16168298479453780489, 16083456466830550283, 11380553957000451991, 15128521211355953573, 10826365584345090827, 11931387899927297363, 16091037230044064021, 16855367086926162211, 11170558557176459503, 9886757544769944653, 11450033604282275011, 11929757603936817763, 17420827560223252171, 10870631368466407877, 13834307981276745037, 10230994628690765197, 14461440966371289941, 14513569082524554649, 15609519179461790747, 12452462947852628413, 11697783772313307211, 10077360532646539567, 15668479810095426521, 14100390060574107281, 16039433251746746399, 11594255700072389497, 11335433960775286819, 17135850578547822607, 17715472259313599723, 9872560666658691277, 13426738927194861001, 9559405911145488401, 9560643982657333219, 11125735716442543571, 14348305982295065537, 17334821829789014189, 12062975303975394341, 17675818288232614691, 12456667873905594329, 11330845594517002613, 16817880606791218753, 9524369250258419267, 14531988631115581537, 9721408134124289899, 16662586589444720647, 11325110890618816411, 10051647873079811617, 14536021166978233733, 12224386731517653097, 17640459671249984461, 16543114235733129481, 12834813684653021713, 13050693286566514921, 16072783334843947421, 16824355675011368569, 9665639317029622411, 15966237013384955239, 14787243991682533471, 14167620861073328777, 16552060845197660033, 14426640096605498107, 11250797705828570411, 12830939822208389821, 15292466542716343963, 9917855814946199189, 10442126201651355433, 12042544592582006819, 13742543708854176911, 12519797425611830609, 12305049189690830747, 13048815356624492777, 17928797470734483373, 9345743880343852493, 17394449011144997203, 14027454725211775843, 15325951436202259889, 14089580406354666877, 14985891805973997229, 15815861666300600207, 13010491061439139729, 17474295865525658119, 10856321689902733963, 15719997391332198931, 11798694284977436299, 11131916950543733651, 14728548632909038181, 15869387205433439081, 10635187834937273627, 14844816583829681107, 10707745831589845607, 16061495585562724741, 13860352348388954479, 13839169685364641087, 10246021025120950757, 17909700734377694141, 11494364438621610881, 16304619707693032889, 13720492814063169997, 12550911015312791057, 18076672670188884121, 10384906691343925679, 16486782778290044783, 12644175422114478653, 14955139942049789357, 16026396184113858703, 10524600442649861959, 11001050498566874027, 9979271448704886613, 13030132484834300659, 15230981971792316689, 15374177218176283253, 14195651389624938953, 10455638721836517437, 15149204128873840301, 12500463654517686493, 13475842347378678719, 12974353406746765043, 18081547614319419917, 13613920396906170893, 18201655698843944801, 9908359973067294049, 12259133230997142013, 13435886340259808407, 17657174880994459697, 13940231287221357463, 16592426911225206653, 13749631155096260533, 13579552974478309459, 9836712372149870281, 17218778541380165767, 10464000360382809991, 16777832929341727297, 15972158110380610507, 15350561171111592953, 9938731346590575421, 17912262447858075839, 16137701207062825711, 15626368583424185491, 10499152290055372079, 9382357912889286797, 14085852927258985099, 18393486728568017383, 10652476457160311261, 10527374223100330091, 17264120882113825487, 10885171609551829193, 16296935971967210533, 17039844827041640479, 16608078020248577041, 9554142078243712343, 12151602751600242503, 18333639542063204713, 12302756704018880831, 11612577899799494441, 13180093129135727227, 15533144054803240961, 17221156035305318801, 11685681018084321637, 13339338584418108371, 16764312293446072699, 9609715328254190099, 12015164966002919969, 17640110779197465353, 16460183428670473871, 13819867905621355469, 11784001662482246243, 10882776393768075541, 12284523803945957717, 11453117866254103187, 10672997245980076939, 9837424460088812963, 9456987736164381311, 16476068953424599633, 10714497365388454843, 11566321267685570027, 12258500729803839241, 13565509018611395453, 9837508107087665041, 10883021385911688053, 13236085185545218621, 12903549664178814119, 9277313810593502131, 15325552562767494059, 15737855390072711723, 12902145372862611967, 16617731535068412919, 16192918114406845313, 13329973263696065593, 15118904191983404627, 9421694107495493981, 14757389355512560711, 11755446033555771161, 11174113824848691089, 9931655160887834537, 13952179663695071047, 14628647895265937389, 13965103496050821571, 12334188065189399611, 15026324919476931311, 13737352569679199609, 17292288948395152463, 9747700181588759561, 13039199615231288567, 15048237407823618463, 11672237438639568239, 10302962861342428331, 12445128229021135679, 14463159840208815601, 13915082057723091419, 17505306824019415949, 12290525908208358407, 18446406381021364073, 11883272894488841837, 13151315617170041119, 9986202098577177283, 11376286496724079633, 17072429507581144597, 11601908054173197833, 12769100713651410277, 11578625980850143169, 15395413375327895911, 13942489248348359849, 16149741548915905429, 13745316489572365673, 9342391586010481007, 13460580618329867983, 15049385889346014431, 13567657641395719637, 9610206585474156637, 18361259735535581597, 16345044279841976141, 10386175636785013831, 10339319734960152623, 17118190675556320687, 10005962451642889201, 14773420480883046503, 11178361855707216889, 17257848339780864089, 17226047946161423507, 16460175468823544401, 15971530319487090739, 14842029296369602163, 15224121827462937979, 9275527308938870173, 17041103378156856689, 13801145680164940003, 10285279638830544209, 13671894824963549641, 16032778609020511861, 9851225257145555347, 9375022299108554971, 14826523109553586027, 17124217400159528447, 10713407734688191177, 12691625640419643317, 15981484460492567717, 9786795565103681819, 12556711015687803709, 11148645018758728049, 13265323147276427401, 13967986650812662373, 17848752154332550457, 9981768723976662007, 14998022968536079123, 12174071201870356879, 11520148746512983013, 12705359135922834167, 16031947192061029513, 12785255613650486969, 17794207197348321059, 16590130444003836701, 13051020119617841899, 18329540394916509391, 17016883109643488021, 12739110953512934191, 17294655201856917067, 11058626020237830707, 9462906708710154961, 14623360900124309369, 11254845081678452897, 14264002816761276253, 13102001758655038643, 12108869081174715287, 17010826574740201271, 14037017483914942313, 13985137272262919353, 9633084395035385983, 17241078172401921151, 16214027901908512283, 16093436048900321317, 14391957124445034917, 12359483645035302161, 10438778853819832753, 10567110128884566343, 10292970247351191901, 16822209722672159149, 13496565983843091859, 11841500670757876693, 11147505811854389987, 14065276166663767481, 15145625093242694749, 14413829172406893583, 16503017312704021103, 11981873548328345323, 11909212497608981689, 10679989447819664377, 12423178332387828413, 14358836553490758151, 10237468755767323591, 9735039457556049641, 9478522344708755909, 17979691433619404903, 17873209010991434147, 9550618472816953163, 13347619619192035741, 14530641313417809089, 13994703746676143779, 9559733892621448897, 10382805841803379711, 11843672223274874071, 16815833185277434981, 12381223102021820597, 15258305081721389239, 15136515056658706363, 18126727588656279323, 10697455619860328677, 9352124924523425581, 17295005245325754503, 14177782902523557389, 16249970306053067029, 17425431521899489447, 9366637040493563183, 14547545849198299667, 16839246487745686313, 10125673509176340733, 16315331794598305291, 18287303257171869707, 14082462954685803851, 15710924897106988277, 9846789987736297901, 12850810892277384811, 9503762183847119159, 12035363414252005649, 12548445170155094227, 9987078241115445023, 11170994807091443339, 11647765960869059809, 10834387862974757999, 9838865006047239157, 12019744644188767517, 14761339868466177863, 10956244424237933677, 10577167950528154373, 18401121224902652879, 17235712984492843111, 18429975080980393459, 16975328717308835227, 16212745888436855227, 15748060839664004279, 10802710007407091591, 18005654473259312323, 17728864727324757541, 9476823236759120071, 15715719744380211089, 11317957584932242129, 14263043570269209481, 11885161440852975761, 12759119296561192847, 16837757861450897923, 11387051211693970223, 12990690679215047009, 15370437666068796491, 9661293882813929899, 16671594122227576891, 12760716047967713053, 15836846371629855617, 15372573498823277741, 13037801868101928847, 9227832155694778921, 12305150816980735891, 15210658418843137207, 16788466837458690557, 9762486133521181153, 13371940588733082221, 10152546759088309507, 10848887643327358249, 17205964303284825847, 12583799778495365419, 9672644823779940799, 16479122731650726673, 11829095825108299229, 16856643509258471717, 17729801070393904861, 12446898694377908053, 15647792035238488259, 15262980088834134317, 14842714080641230361, 11892658365659114837, 15543608752847397577, 18134628238866132559, 17281754915383504451, 14880763471671790447, 18365273826942699029, 10593576240664735397, 13738012363336486327, 10585528712941671061, 15236197766771889647, 12962016451203849439, 10115648256105130097, 18284391657729233963, 10065785450550899873, 14857920561664507949, 16030693837709372611, 13900562821391763329, 12228162083162590063, 11182799187528291871, 10214055412817190283, 15460696099737060427, 12382626153236584387, 15465251424009421147, 16965031217756582281, 14126243176626361657, 18080871035396853247, 12890579554268090071, 12213352895923847441, 11657388029153192717, 10594146346641284267, 10061199141387371213, 11654321642876196877, 9824908207222632341, 9667965027898668031, 15337259287380080431, 11343809882060699179, 14165912342048965513, 11858958254391153371, 14644267317090978181, 15243216027706161023, 12709086352105620721, 12699306874452850307, 9623280468372066131, 12147185253639241291, 16601705326867205539, 10344891266561865029, 9295392664898294891, 11337442576012179707, 12437074606171059809, 16257047214863286941, 15963251223708366749, 9796716955285549447, 15639176349316312987, 9957650134111703227, 13427963685313160311, 14969656757466500147, 15214704302669139497, 16883998205231447767, 9582306718565802677, 18213300288961503953, 10133964032925729329, 13921564103985671879, 18189260807943763691, 15990390439904555291, 13338552747826262603, 10004697650349190067, 14464165999372352189, 9264423096518569807, 16223738667762317267, 12581099710736152931, 16783603748986153523]
分析
我们将p看作

则我们有p∣Us(Pm)，而这里的Us(Pm)便涉及扩展卢卡斯序列，你会发现其实和p−1光滑攻击类似，只是p−1是利用费马小定理得到整除关系，而这里是利用扩展卢卡斯得到整除关系，我们只需要知道它也是和p+1的每个素因子有关即可。所以我们只需要替换p+1光滑攻击代码中涉及素因子部分的代码即可。

EXP
from itertools import count
from Crypto.Util.number import *
from gmpy2 import *

n = 345799778173748173773868120733939877012606206055022173086869626920649670201345540822551954372166638650313660302429331346299033954403991966160361903811355684857744142271007451931591141051285664283723609717718163872529480367508508005122335725499745970420634995317589843507796161899995004285340611933981932785753209168028330041659
c = 246232608531423461212845855125527519175008303736088113629990791124779986502745272419907699490375796645611551466345965328844415806242069890639077695943105766009969737068824735226917926112338655266209848386322013506145057902662138167248624945138207215690482597144303445656882230801297916736896978224496017358461492736283036138486
primes = [...]

def mlucas(v, a, n):
    """ Helper function for williams_pp1().  Multiplies along a Lucas sequence modulo n. """
    v1, v2 = v, (v ** 2 - 2) % n
    for bit in bin(a)[3:]: v1, v2 = ((v1 ** 2 - 2) % n, (v1 * v2 - v) % n) if bit == "0" else (
        (v1 * v2 - v) % n, (v2 ** 2 - 2) % n)
    return v1

def ilog(x, b):  # greatest integer l such that b**l <= x.
    l = 0
    while x >= b:
        x /= b
        l += 1
    return l

def williams(n):
    for v in count(1):
        for p in primes:
            e = ilog(isqrt(n), p)
            if e == 0:
                break
            for _ in range(e):
                v = mlucas(v, p, n)
            g = gcd(v - 2, n)
            if 1 < g < n:
                return int(g), int(n // g)  # g|n
            if g == n:
                break

p, q = williams(n)
m = pow(c, inverse(65537, (p-1)*(q-1)), n)
print(long_to_bytes(m))
共模攻击
例题1.
from Crypto.Util.number import *

flag = b'NSSCTF{******}'

p = getPrime(512)
q = getPrime(512)

n = p*q
e1 = getPrime(16)
e2 = getPrime(16)

m = bytes_to_long(flag)

c1 = pow(m, e1, n)
c2 = pow(m, e2, n)

print(f'n = {n}')
print(f'e1 = {e1}')
print(f'e2 = {e2}')
print(f'c1 = {c1}')
print(f'c2 = {c2}')


n = 120294155186626082670474649118722298040433501930335450479777638508444129059776534554344361441717048531505985491664356283524886091709370969857047470362547600390987665105196367975719516115980157839088766927450099353377496192206005171597109864609567336679138620134544004766539483664270351472198486955623315909571
e1 = 38317
e2 = 63409
c1 = 42703138696187395030337205860503270214353151588149506110731264952595193757235229215067638858431493587093612397165407221394174690263691095324298012134779703041752810028935711214038835584823385108771901216441784673199846041109074467177891680923593206326788523158180637665813642688824593788192044139055552031622
c2 = 50460092786111470408945316270086812807230253234809303694007902628924057713984397041141665125615735752600114964852157684904429928771531639899496987905067366415806771003121954852465731110629459725994454904159277228514337278105207721011579794604761255522391446534458815389983562890631994726687526070228315925638
在本题中使用了两组公钥对同一消息进行加密，经过观察我们可以发现这两种公钥的n是同一个n，也就是说模数相同，那么此时我们便可以使用共模攻击进行解密。

在此攻击中，我们需要两个使用了同样模数的公钥对同一消息进行加密，同时还需要满足公钥中的e互素（本题e1和e2满足互素）。然后我们考虑方程:​
假设我们能够找到整数解(s1,s2)满足此方程，那么则有​

我们可以发现可以直接解得m而不需要对n进行因数分解，那么我们如何解得(s1,s2)呢？这就是之前为何要互素的条件了，根据翡镯定理我们有:​该方程一定有且仅有一组整数解(x,y)。具体解法我们需要用到扩展欧几里得算法.

EXP
from Crypto.Util.number import *
from gmpy2 import *

n = 120294155186626082670474649118722298040433501930335450479777638508444129059776534554344361441717048531505985491664356283524886091709370969857047470362547600390987665105196367975719516115980157839088766927450099353377496192206005171597109864609567336679138620134544004766539483664270351472198486955623315909571
e1 = 38317
e2 = 63409
c1 = 42703138696187395030337205860503270214353151588149506110731264952595193757235229215067638858431493587093612397165407221394174690263691095324298012134779703041752810028935711214038835584823385108771901216441784673199846041109074467177891680923593206326788523158180637665813642688824593788192044139055552031622
c2 = 50460092786111470408945316270086812807230253234809303694007902628924057713984397041141665125615735752600114964852157684904429928771531639899496987905067366415806771003121954852465731110629459725994454904159277228514337278105207721011579794604761255522391446534458815389983562890631994726687526070228315925638

_, s1, s2 = gcdext(e1, e2)
#e1s1+e2s2=gcd(e1,e2)
#三个返回值分别为
#1：最大公约数
#2.s2
#3.s3

m = powmod(c1, s1, n)*powmod(c2, s2, n) % n
print(long_to_bytes(m))
例题2
from Crypto.Util.number import *

p = getPrime(700)
q = getPrime(700)
n = p*q

e1 = 3*getPrime(16)
e2 = 3*getPrime(16)

flag = b'NSSCTF{******}'
c1 = pow(bytes_to_long(flag), e1, n)
c2 = pow(bytes_to_long(flag), e2, n)

print(f'n = {n}')
print(f'e1 = {e1}')
print(f'e2 = {e2}')
print(f'c1 = {c1}')
print(f'c2 = {c2}')


n = 17258060066893213074755453373218306582162826137762311133274776357570753221703880922246758313805944651653670388312409120584883194670296622866672717977722186711567375015117429341498055534372807872455441738225834253639068425012163751145785603722177526607324435641434593514768226599401862097301050185867830575469303960864978407638846270971263106481892520999227504152184478241946941685206875783621912245612463394268401327595737
e1 = 159897
e2 = 192273
c1 = 4595717262826082372249114022806610849627020753616385658397281529962210282956290111008418210778140550163959636029533312923781864970753502714169965973507425352493857361069899079130259227540344021591878554631845093918021212295485108865566378903346061480239406752062655328184620669486561050933167981474236084817766063901438798437061213111422401822238367462990085699301757131570089105471117732589635966783817714928153442984943
c2 = 6930904879823636264189052321687613173304614320999504775391013591790100775422558030373964338538540537224825701022993433544854997668153296576460906623734663341340853498020227553815076511099480950225109778895193096753014911735040516576988675988526232648772153671745762684830032445024652478629766700037603250123679920127263565322009118867116958069937438887437206234970465675161823446396025302570020058273271974621280101050077
分析
实际本题和以前很多题一样，我们将​看成​即可，这样我们便得到了两个互素的加密指数，再做共模攻击便可以解得​，再进行开方即可。

EXP
from Crypto.Util.number import *
from gmpy2 import *

n = 17258060066893213074755453373218306582162826137762311133274776357570753221703880922246758313805944651653670388312409120584883194670296622866672717977722186711567375015117429341498055534372807872455441738225834253639068425012163751145785603722177526607324435641434593514768226599401862097301050185867830575469303960864978407638846270971263106481892520999227504152184478241946941685206875783621912245612463394268401327595737        
e1 = 159897
e2 = 192273
c1 = 4595717262826082372249114022806610849627020753616385658397281529962210282956290111008418210778140550163959636029533312923781864970753502714169965973507425352493857361069899079130259227540344021591878554631845093918021212295485108865566378903346061480239406752062655328184620669486561050933167981474236084817766063901438798437061213111422401822238367462990085699301757131570089105471117732589635966783817714928153442984943        
c2 = 6930904879823636264189052321687613173304614320999504775391013591790100775422558030373964338538540537224825701022993433544854997668153296576460906623734663341340853498020227553815076511099480950225109778895193096753014911735040516576988675988526232648772153671745762684830032445024652478629766700037603250123679920127263565322009118867116958069937438887437206234970465675161823446396025302570020058273271974621280101050077

_, s1, s2 = gcdext(e1, e2)
m = powmod(c1, s1, n) * powmod(c2, s2, n) % n
print(long_to_bytes(iroot(m, 3)[0]))
dq、dp双泄露
原理
题目中一般给出参数
、
​，且我们发现题目中没有给出e。
我们需要知道
、
​参数的意义：

（
）
（
）
我们在解密时引入
、
​用于快速计算：

即：​

根据欧拉降幂我们有

降幂的核心思想是利用欧拉定理将指数 d缩小到 dp和 dq，从而减少计算量。具体来说：

由于 dp=dmod  (p−1)，我们可以将 d 写成：

​

其中 k是某个整数。

因此：

​

根据欧拉定理，​，所以：

​

我们将此式带入​的式子中有：​

即​

此时我们再将此式带入​的式子(​)中即可消去k：

或
（
）
​

例题1
p = getPrime(512)
q = getPrime(512)

n = p*q
e = getPrime(128)
d = inverse(e, (p-1)*(q-1))

dp = d % (p-1)
dq = d % (q-1)

m = bytes_to_long(flag)

c = pow(m, e, n)

print(f'p = {p}')
print(f'q = {q}')
print(f'c = {c}')
print(f'dp = {dp}')
print(f'dq = {dq}')
EXP
invp = invert(p, q)
m1 = powmod(c, dp, p)#欧拉降幂
m2 = powmod(c, dq, q)#欧拉降幂
m = (((m2 - m1)*invp) % q)*p + m1
#m=(m2 - m1) % q + m1
print(long_to_bytes(m))
dp泄露
此类题目一般给出dp和e,但不给出dq.

分析
对于dp我们有​

有
：
因为有​所以有k<e，则[1,e)的范围遍历k，找到满足等式的整数解，即可解出p.

做个解释为什么​，因为我们上面看到​，我们可以将​看作是​的一个余数，自然小于​

EXP
for k in range(1, e):
    if (e * dp - 1) % k == 0:
        p = (e * dp - 1) // k + 1
        if n % p == 0:
            q = n // p
            d = invert(e, (p - 1) * (q - 1))
            m = powmod(c, d, n)
            break
例题1
from Crypto.Util.number import *

flag = b'NSSCTF{******}' + b'1'*100

p = getPrime(512)
q = getPrime(512)

n = p*q
e = 65537
d = inverse(e, (p-1)*(q-1))

dp = d % (p-1)

m = bytes_to_long(flag)

c = pow(m, e, n)

print(f'n = {n}')
print(f'c = {c}')
print(f'dp = {dp}')


n = 79201858340517902370077926747686673001645933420450220163567700296597652438275339093680329918615445030212417351430952656177171126427547284822789947152085534939195866096891005587613262293569611913019639653984932469691636338705418303482885987114085769045348074530172292982433373154900841135911548332400167290083
c = 70109332985937768446301118795636999352761371683181615470371772202170324747707233792154935611826981798791499937601162039878070094663516868746240133223110650205575807753345252087103328657073552992431511929172241702073381723302143955977662087561904058172777520360991685289300855900793806183473523998422682944404
dp = 3098334089252415941833934532457314870210700261428241562420857845879512952043729097866485406309479489101668423603305497982177150304625615059119312238777275
EXP
from Cryptodome.Util.number import *
from gmpy2 import *

e = 65537
n = 79201858340517902370077926747686673001645933420450220163567700296597652438275339093680329918615445030212417351430952656177171126427547284822789947152085534939195866096891005587613262293569611913019639653984932469691636338705418303482885987114085769045348074530172292982433373154900841135911548332400167290083
c = 70109332985937768446301118795636999352761371683181615470371772202170324747707233792154935611826981798791499937601162039878070094663516868746240133223110650205575807753345252087103328657073552992431511929172241702073381723302143955977662087561904058172777520360991685289300855900793806183473523998422682944404
dp = 3098334089252415941833934532457314870210700261428241562420857845879512952043729097866485406309479489101668423603305497982177150304625615059119312238777275
for k in range(1, e):
    if (e * dp - 1) % k == 0:
        p = (e * dp - 1) // k + 1
        if n % p == 0:
            q = n // p
            d = invert(e, (p - 1) * (q - 1))
            m = powmod(c, d, n)
            break
print(long_to_bytes(m))
例题2
from Crypto.Util.number import *

flag = b'NSSCTF{******}' + b'1'*80

p = getPrime(512)
q = getPrime(512)

n = p*q
e = getPrime(128)
d = inverse(e, (p-1)*(q-1))

dp = d % (p-1)

m = bytes_to_long(flag)

c = pow(m, e, n)

print(f'n = {n}')
print(f'e = {e}')
print(f'c = {c}')
print(f'dp = {dp}')


n = 108280026722298796068968170303156759745471686664814404724171434502249429011870583595808692893118419248225924869164875379709992190884930717654004006466664403479467573176438601715156464950045121937338569942817256182277141174728470067308962244296992229214749863655518517510026063088263849891990324547823192559069
e = 305691242207901867366357529364270390903
c = 26537258289122728220745496185201994733321402056894636636642710319261241111675937946139938310952968353253866895253865273981912174303818938005932883052177988834834575591342856235464380238486868448329727891268391728758132913642966389278296932186703733187105516710825918064228397602264185334108934765627411913661
dp = 2656631506624565349527023729530989647164022271235521672257622068579788839123502046687139927161669209201953909023994372208117081512139181611949631467292513
在此题中我们看到e很大，区别于例题1（e较小，可以在[1,e)中遍历解得k） ，此题不能遍历爆破，但我们还有上一题的关系​.

我们继续思考其他方法，由欧拉降幂有：

显然说明：​

有：​，显然我们已经攻破了本题，接下来我们需要求解和n的最大公因数即可.

EXP
from Cryptodome.Util.number import *
from gmpy2 import *

n = 108280026722298796068968170303156759745471686664814404724171434502249429011870583595808692893118419248225924869164875379709992190884930717654004006466664403479467573176438601715156464950045121937338569942817256182277141174728470067308962244296992229214749863655518517510026063088263849891990324547823192559069
e = 305691242207901867366357529364270390903
c = 26537258289122728220745496185201994733321402056894636636642710319261241111675937946139938310952968353253866895253865273981912174303818938005932883052177988834834575591342856235464380238486868448329727891268391728758132913642966389278296932186703733187105516710825918064228397602264185334108934765627411913661
dp = 2656631506624565349527023729530989647164022271235521672257622068579788839123502046687139927161669209201953909023994372208117081512139181611949631467292513

a = 2
p = gcd(powmod(a, e*dp, n) - a, n)
q = n // p
d = invert(e, (p - 1) * (q - 1))
m = powmod(c, d, n)
print(long_to_bytes(m))
显然我们会发现此法还需要一个存在条件便是​，因为如果不满足将不能那样使用欧拉降幂，详见欧拉降幂的定义。所以本方法一般e都比较大，如果不满足则e很小用P10方法即可（这里还存在dp很小的可能，这种情况我们之后会继续讨论）

d泄露
![image-20241113175533327](../../AppData/Roaming/Typora/typora-user-images/image-20241113175533327.png)

例题1
from Crypto.Util.number import *
from gmpy2 import *

p = getPrime(512)
q = getPrime(512)

assert p < q

n = p*q
e = 65537
phi = (p-1)*(q-1)
d = invert(e, phi)

print(f'n = {n}')
print(f'd = {d}')
print('flag is NSSCTF{md5(p)}')


n = 113917408220469425995764932761465306974540330325378601642830241920567032775895088098706711486764203845425248022960733155994427766750033219106642310531864450654102562104771892268897793145789045570107312401570269581223945259704851104645493075550316424129401227653740942495625720165869565257394427181127734628103
d = 15762135247924329080208071933121250646888501386858311483546464344350547831176536290630826247188272280853810047335214127264865205744683174860903496832368687060941437002920094364116706593296591581117381565805322046922482804679245558495134876677733584718947309975077159564300049936769192724856722338627154192353
flag is NSSCTF{md5(p)}
EXP
from Cryptodome.Util.number import *
from gmpy2 import *
import hashlib

n = 113917408220469425995764932761465306974540330325378601642830241920567032775895088098706711486764203845425248022960733155994427766750033219106642310531864450654102562104771892268897793145789045570107312401570269581223945259704851104645493075550316424129401227653740942495625720165869565257394427181127734628103
d = 15762135247924329080208071933121250646888501386858311483546464344350547831176536290630826247188272280853810047335214127264865205744683174860903496832368687060941437002920094364116706593296591581117381565805322046922482804679245558495134876677733584718947309975077159564300049936769192724856722338627154192353
e = 65537


t = e*d - 1
s = 0

while t % 2 == 0:
    s += 1
    t //= 2

found = False

for i in range(1, s):
    c1 = powmod(2, powmod(2, i-1, n)*t, n)
    c2 = powmod(2, powmod(2, i, n)*t, n)
    if c1 != 1 and c1 != (-1 % n) and c2 == 1:
        p = gcd(c1 - 1, n)
        q = n // p
        break

if p > q:
    p, q = q, p

print('NSSCTF{%s}' % hashlib.md5(str(p).encode()).hexdigest())
 

拓展欧几里得
例题1.
from Crypto.Util.number import *
flag = b'******'

m1 = bytes_to_long(flag[:len(flag)//2])
m2 = bytes_to_long(flag[len(flag)//2:])

assert 18608629446895353521310408885845687520013234781800558*m1-14258810472138345414555137649316815272478951117940067*m2 == 1
分析
我们可以计算发现题目中约束的两个值其最大公因数为1，所以我们是可以算出未知数的，我们可以利用扩展欧几里得算法进行该约束方程。

裴蜀引理：对于整数域中的不定方程​，其有解的充要条件是​.

def gcd(a, b):
return a if b == 0 else gcd(b, a%b)
以上是欧几里得算法的python实现，其原理利用了递归的思想：

设置一个边界值

设置递归量，并且不断地归约。

设​的最大公约数为g，当b!=0,a>b时有：​

则可以将问题转化为​即：

因为g|b,g|a,则有​，即说明​是整数，有​，到这里我们证明了​的最大公因数还是g，也就说明了
和
​等价，所以我们便可以按照此方式不断的进行归约最终直到到达边界值即​时，则说明此时的b是原式的最大公因数。

现在考虑拓展欧几里得，在外面前面所说的边界值（a=g,b=0）时有：

即此时解为x=1,y=0，这同样也是扩欧的边界条件，那么我们从边界值往回看代入上上面我们所述的等价关系中可以得到：

那么现在我们要做的就是寻找这两个式子中的转移关系，从而找到
和
​的联系，
和
​的联系，从而和欧几里得一样写出转移式便可以得到完整实现了.

我们知道​，代入上述关系中则有：

显然我们便得到了关系式：

#代码实现为：
def extgcd(a, b):
    if b == 0:
        return a, 1, 0

    g, x, y = extgcd(b, a%b)
    return g, y, x - (a//b)*y
后面的过程便很简单了，我们通过extgcd直接求解即可。不过这里还有个值得注意的是你会发现得到的值不是flag，因为(x+kb,y+ka)依然是原方程的解，所以我们得到的只是一组解，后续我们可以通过遍历的手段找到我们想要的那一组即可。

EXP
from Crypto.Util.number import *

def extgcd(a, b):
    if b == 0:
        return a, 1, 0
    
    g, x, y = extgcd(b, a%b)
    return g, y, x - (a//b)*y

solve = extgcd(18608629446895353521310408885845687520013234781800558,14258810472138345414555137649316815272478951117940067)
a = abs(solve[1])
b = abs(solve[2])

for _ in range(10):
    b += 18608629446895353521310408885845687520013234781800558
    a += 14258810472138345414555137649316815272478951117940067
    if b'NSSCTF' in long_to_bytes(a):
        print(long_to_bytes(a)+long_to_bytes(b))
        break
CRT
题目
from Crypto.Util.number import getPrime
from secret import falg
pad = lambda s:s + bytes([(len(s)-1)%16+1]*((len(s)-1)%16+1))

n = getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2
e = 3

flag = pad(flag)
print(flag)
assert(len(flag) >= 48)
m = int.from_bytes(flag,'big')
c = pow(m,e,n)

print(f'n = {n}')
print(f'e = {e}')
print(f'c = {c}')


n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001
e = 3
c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149
分析
解法一：
我们看到​.

我们可以先尝试将n进行分解，利用yafu或factordb.com。

分解得到4个数：

q=223213222467584072959434495118689164399
p=260594583349478633632570848336184053653
t=218566259296037866647273372633238739089
r=225933944608558304529179430753170813347
其中我们通过​函数得到：

print(gcd(e,p-1),gcd(e,q-1),gcd(e,r-1),gcd(e,t-1))
#1，1，3，3
知道​整除
和
​.

所以由于
和
​不互质，无法直接解密，类似的，模t也无法直接解密。因此解密只能依赖于p和q的部分。但为了保持模数的阶，可能需要使用 ​作为模数，其 ​是 ​

使用 ​可能是为了确保：

模数的阶足够大，能够恢复原始消息 m。

phi(p^2 * q^2) 提供了与 e 互质的可能性（如果 e 与 (p - 1)*(q - 1)互质）

EXP
from Cryptodome.Util.number import long_to_bytes
from gmpy2 import iroot, gcd, invert

n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001
e = 3
c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149

#print(iroot(n,2))
q=223213222467584072959434495118689164399
p=260594583349478633632570848336184053653
t=218566259296037866647273372633238739089
r=225933944608558304529179430753170813347

print(gcd(e,p-1),gcd(e,q-1),gcd(e,r-1),gcd(e,t-1))
phi = (p-1)*(q-1)*p*q
t = gcd(e, phi)
print(t)
d = invert(e,phi)
m = pow(c,d,p*p*q*q)
print(m)
print(long_to_bytes(m))
解法二（sagemath   CRT_list() ）
正常情况下的RSA都要求e和phi(n)要互素，不过也有一些e和phi(n)有很小的公约数的题目，这些题目可以通过计算e对phi(n)的逆元d来求解。但是本题则为e和phi(n)的最大公约数就是e本身，也就是说e | p-1，只有对c开e次方根才行,到这里就是一个有限域开3次方根的问题了。
PS:上述中的phi(n)也可以是，（p-1）或者（q-1）或者（r-1）或者（t-1）

将同余方程
​简化为：
​
​
​
​

然后分别在GF（p）、GF(q)、GF（r）、GF(t)上对c开e=3次方根，再用CRT组合一下即可得到在mod n下的解

EXP
#sagemath
import libnum
n = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001
e = 3
c = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149
p = 225933944608558304529179430753170813347
q = 260594583349478633632570848336184053653
r = 218566259296037866647273372633238739089
t = 223213222467584072959434495118689164399

R.<x> = Zmod(p)[]
f = x^e-c#x满足x^e-c=0 pmod (p)的所有根
f = f.monic()
results1 = f.roots()

R.<x> = Zmod(q)[]
f = x^e-c
f = f.monic()
results2 = f.roots()

R.<x> = Zmod(r)[]
f = x^e-c
f = f.monic()
results3 = f.roots()

R.<x> = Zmod(t)[]
f = x^e-c
f = f.monic()
results4 = f.roots()
for i in results1:
    for j in results2:
        for l in results3:
            for k in results4:
                param1 = [int(i[0]),int(j[0]),int(l[0]),int(k[0])]
                param2 = [p,q,r,t]
                m = CRT_list(param1,param2)
                flag = libnum.n2s(int(m))
                if b'flag' or b'gwb' or b'FLAG' or b'GWB' in flag:
                    print(flag)

拓展CRT
例题1
from Crypto.Util.number import *
from gmpy2 import *
import random
flag = b'******'
flag = bytes_to_long(flag)
nl = []
cl = []

def getn(bits):
    n = 1
    while n.bit_length() < bits:
        n *= random.choice(sieve_base)
    return n

for i in range(8):
    n = getn(flag.bit_length())
    c = pow(flag, 7, n)

    nl.append(n)
    cl.append(c)

print(nl)
print(cl)


nl = [48900330639594979739701067783234903348599405413588466525574910520196852415104874636276388006189258357683981763, 52184798260918956005878710130354843122927544013692595240956998112200987084814453592388074200951779840156511, 57591305346419909943538345276263585821186563609432856462492112562586368230163591993342956384688555395772999, 1391052858660682537388264601016075339528373211889618359237336378385137832855656756800539626220549334300176727, 8401669052993451281764489325068020625937224410830694438332016050030698435746929661939302694116817188225591, 66809775375777747860816961274643428927028556487820183599747024350362932190079439298182707730302976119988715497, 41209230281867957743385705727577318625405890894626062454495908709761427062490881938652489884059847194603237277, 31140089821370202352241944402736292072447365626312703496944186462246895695650729682254970622208848300946861]
cl = [26617913696414745819584063604277199673357890677059949687794606743781436349829925794253672010780125661705587071, 6332739614121961923948917957498597962902897015582697635859365080803944882904908423983706426654363433337197, 46154051334276357655176765655327305918368830821288083739892570534253190653909520953027859629573215723954424, 2800905135165447908315158053695706832127646195243072751493365013371469263897970241141686022109978485359114, 3597083928897756955519089479028751799504001377334447013725903377254761160933418420625119547713455139382114, 17032086144873551648611964054579542303630306316746409528107026138674853298939194425805809444921339677455174485, 36111201824253386572496248461433786832561483450731317363761227351689971628309683994429845284904292821369745345, 28548175317543234723297895187238113463350377151401226415566179373530461612253257137535830491771909906093171]
分析 
本题目是一个广播攻击的题目，我们利用CRT便可得到通解但是在本题直接套用之前的exp我们会发现报错了，你会得到提示逆元不存在，这便是本题的考点，不互素的CRT。

在一般CRT中我们需要求解逆元​,当我们遇到不互素，便不能求出逆元，这时我们有一种朴素的做法，设​，则有：

，
，
这样我们便得到了两个新的同余方程，并且他们的模​是互素的，这种做法是没有问题的但多组模数互相包含多个因子时，这种做法便变得非常繁琐，因为只得到上述式子的话实际上是丢失信息的，你还需要得到对于​的每个同余式,即：

这样的到的所有式子做CRT才能够得到足够多的有效值。

现在我们寻求一种通解的手段：

我们先考虑两个方程的情况：

其中​，则有：

式
式
即​,移项得到：​

此等式成立则说明
裴
蜀
引
理
​，则有：

即：

有：

带入1式得：

整理得：

即：

这样我们便合并了两个模不互素的同余式得到了一个方程。

(注：​不能直接写成​而将g直接抵消，因为：逆元时的模是​而最后的模是​，即前后的模数不同)

EXP
#法一：sympy里面的crt模块
# from sympy.ntheory.modular import crt
# from gmpy2 import iroot
# from Cryptodome.Util.number import *
#
# nl = [48900330639594979739701067783234903348599405413588466525574910520196852415104874636276388006189258357683981763, 52184798260918956005878710130354843122927544013692595240956998112200987084814453592388074200951779840156511, 57591305346419909943538345276263585821186563609432856462492112562586368230163591993342956384688555395772999, 1391052858660682537388264601016075339528373211889618359237336378385137832855656756800539626220549334300176727, 8401669052993451281764489325068020625937224410830694438332016050030698435746929661939302694116817188225591, 66809775375777747860816961274643428927028556487820183599747024350362932190079439298182707730302976119988715497, 41209230281867957743385705727577318625405890894626062454495908709761427062490881938652489884059847194603237277, 31140089821370202352241944402736292072447365626312703496944186462246895695650729682254970622208848300946861]
# cl = [26617913696414745819584063604277199673357890677059949687794606743781436349829925794253672010780125661705587071, 6332739614121961923948917957498597962902897015582697635859365080803944882904908423983706426654363433337197, 46154051334276357655176765655327305918368830821288083739892570534253190653909520953027859629573215723954424, 2800905135165447908315158053695706832127646195243072751493365013371469263897970241141686022109978485359114, 3597083928897756955519089479028751799504001377334447013725903377254761160933418420625119547713455139382114, 17032086144873551648611964054579542303630306316746409528107026138674853298939194425805809444921339677455174485, 36111201824253386572496248461433786832561483450731317363761227351689971628309683994429845284904292821369745345, 28548175317543234723297895187238113463350377151401226415566179373530461612253257137535830491771909906093171]
#
# M = crt(nl,cl)[0]
# m = iroot(M,7)[0]
#
# print(long_to_bytes(m))

#法二 拓展CRT
from Cryptodome.Util.number import *
from gmpy2 import *
nl = [48900330639594979739701067783234903348599405413588466525574910520196852415104874636276388006189258357683981763, 52184798260918956005878710130354843122927544013692595240956998112200987084814453592388074200951779840156511, 57591305346419909943538345276263585821186563609432856462492112562586368230163591993342956384688555395772999, 1391052858660682537388264601016075339528373211889618359237336378385137832855656756800539626220549334300176727, 8401669052993451281764489325068020625937224410830694438332016050030698435746929661939302694116817188225591, 66809775375777747860816961274643428927028556487820183599747024350362932190079439298182707730302976119988715497, 41209230281867957743385705727577318625405890894626062454495908709761427062490881938652489884059847194603237277, 31140089821370202352241944402736292072447365626312703496944186462246895695650729682254970622208848300946861]
cl = [26617913696414745819584063604277199673357890677059949687794606743781436349829925794253672010780125661705587071, 6332739614121961923948917957498597962902897015582697635859365080803944882904908423983706426654363433337197, 46154051334276357655176765655327305918368830821288083739892570534253190653909520953027859629573215723954424, 2800905135165447908315158053695706832127646195243072751493365013371469263897970241141686022109978485359114, 3597083928897756955519089479028751799504001377334447013725903377254761160933418420625119547713455139382114, 17032086144873551648611964054579542303630306316746409528107026138674853298939194425805809444921339677455174485, 36111201824253386572496248461433786832561483450731317363761227351689971628309683994429845284904292821369745345, 28548175317543234723297895187238113463350377151401226415566179373530461612253257137535830491771909906093171]

def excrt(m, r):
    lcm = m[0]# 初始最小公倍数为第一个模数
    R = r[0]# 初始解为第一个余数
    for i in range(1, len(m)):
        d, x, y = gcdext(lcm, m[i])# 使用扩展欧几里得算法，计算 gcd 和贝祖系数
        c = R - r[i]
        if c % d:#如果c%d!=0,说明方程无解，直接返回-1
            return -1
        x = x * c // d % (m[i] // d)
        #R -= lcm * x  #更新当前解R，将新模数的余数条件合并到R中
        R=R-lcm*x
        lcm = lcm * m[i] // d#更新最小公倍数lcm，以适应新增的模数m[i]
        R %= lcm#将解R归一化到范围[0,lcm)内，保证结果是一个标准的同余解
    return (R + lcm) % lcm#归一化R，使R是正数解

m = excrt(nl, cl)
print(m.bit_length()//7)
print(long_to_bytes(iroot(m, 7)[0]))
Franklin-Reiter相关消息攻击
攻击条件
当Alice使用同一公钥对两个具某种线性消息​与​进行加密，并将加密后的消息​，​发送给了Bob时，我们就可以获得对应的消息​与​，这里我们假设模数为N，两者之间的线性关系如下：

其中f为一个线性函数，比如说​

这一攻击由Franklin-Reiter提出

攻击原理
假设：

两个消息​和​满足​其中a和b已知。

用相同的RSA公钥（e,N）加密，得到密文​和​

目标：解出​

数学推导：

1：关系表达

​

因此：​

2：构造多项式

定义多项式​，有​

定义多项式​，有​

3：计算GCD

​是
和
​的公共根，因此​会包含​作为因子。

计算​，如果​是线性的，则可以直接求解出​

例题1（2025TGCTF——tRwSiAns）
题目
from flag import FLAG
from Crypto.Util.number import getPrime, bytes_to_long
import hashlib

def generate_key(bits=512):
    p = getPrime(bits)
    q = getPrime(bits)
    return p * q, 3


def hash(x):
    return int(hashlib.md5(str(x).encode()).hexdigest(), 16)


def encrypt(m, n, e):
    x1, x2 = 307, 7
    c1 = pow(m + hash(x1), e, n)
    c2 = pow(m + hash(x2), e, n)
    return c1, c2


m = bytes_to_long(FLAG)
n, e = generate_key()
c1, c2 = encrypt(m, n, e)
print(f"n = {n}")
print(f"e = {e}")
print(f"c1 = {c1}")
print(f"c2 = {c2}")
'''
n = 100885785256342169056765112203447042910886647238787490462506364977429519290706204521984596783537199842140535823208433284571495132415960381175163434675775328905396713032321690195499705998621049971024487732085874710868565606249892231863632731481840542506411757024315315311788336796336407286355303887021285839839
e = 3
c1 = 41973910895747673899187679417443865074160589754180118442365040608786257167532976519645413349472355652086604920132172274308809002827286937134629295632868623764934042989648498006706284984313078230848738989331579140105876643369041029438708179499450424414752031366276378743595588425043730563346092854896545408366
c2 = 41973912583926901518444642835111314526720967879172223986535984124576403651553273447618087600591347032422378272332279802860926604693828116337548053006928860031338938935746179912330961194768693506712533420818446672613053888256943921222915644107389736912059397747390472331492265060448066180414639931364582445814
'''
分析
思路1：Franklin-Reiter相关消息攻击
我们看到代码：

def encrypt(m, n, e):
    x1, x2 = 307, 7
    c1 = pow(m + hash(x1), e, n)
    c2 = pow(m + hash(x2), e, n)
    return c1, c2
知道对两个不同的信息用相同公钥进行加密，其中容易看出两个信息存在线性相关
（信息1：​，信息2：​）

故考虑Franklin-Reiter相关消息攻击

EXP
#sagemath
from Crypto.Util.number import *

n = 100885785256342169056765112203447042910886647238787490462506364977429519290706204521984596783537199842140535823208433284571495132415960381175163434675775328905396713032321690195499705998621049971024487732085874710868565606249892231863632731481840542506411757024315315311788336796336407286355303887021285839839
c1 = 41973910895747673899187679417443865074160589754180118442365040608786257167532976519645413349472355652086604920132172274308809002827286937134629295632868623764934042989648498006706284984313078230848738989331579140105876643369041029438708179499450424414752031366276378743595588425043730563346092854896545408366
c2 = 41973912583926901518444642835111314526720967879172223986535984124576403651553273447618087600591347032422378272332279802860926604693828116337548053006928860031338938935746179912330961194768693506712533420818446672613053888256943921222915644107389736912059397747390472331492265060448066180414639931364582445814
x1=189543988020763859054201121867732572001
x2=190188081314515644627836686569786975555
e=3
def franklinReiter(n,e,c1,c2):
    PR.<x> = PolynomialRing(Zmod(n))
    g1 = (x+x1)^e - c1
    g2 = (x+x2)^e - c2

    def gcd(g1, g2):
        while g2:
            g1, g2 = g2, g1 % g2
        return g1.monic()
    return -gcd(g1, g2)[0]

m=franklinReiter(n,e,c1,c2)
flag = long_to_bytes(int(m))
print(flag)
思路2
我们看到e很小，可以直接展开​表达式。

​

其中​展开得到：​

​同理展开

然后进行​得到一元二次方程，进行求解即可

EXP
import hashlib
import math
from Cryptodome.Util.number import long_to_bytes

print("x1=",int(hashlib.md5(str(307).encode()).hexdigest(), 16))
print("x2=",int(hashlib.md5(str(7).encode()).hexdigest(), 16))
x1=189543988020763859054201121867732572001
x2=190188081314515644627836686569786975555
n = 100885785256342169056765112203447042910886647238787490462506364977429519290706204521984596783537199842140535823208433284571495132415960381175163434675775328905396713032321690195499705998621049971024487732085874710868565606249892231863632731481840542506411757024315315311788336796336407286355303887021285839839
e = 3
c1 = 41973910895747673899187679417443865074160589754180118442365040608786257167532976519645413349472355652086604920132172274308809002827286937134629295632868623764934042989648498006706284984313078230848738989331579140105876643369041029438708179499450424414752031366276378743595588425043730563346092854896545408366
c2 = 41973912583926901518444642835111314526720967879172223986535984124576403651553273447618087600591347032422378272332279802860926604693828116337548053006928860031338938935746179912330961194768693506712533420818446672613053888256943921222915644107389736912059397747390472331492265060448066180414639931364582445814
cha=c1-c2
mm=cha-(x1**3-x2**3)
print("mm=",mm)
from sympy import symbols, Eq, solve
# 定义变量
m = symbols('x')
# 定义方程
equation = Eq(3*m**2*(x1-x2)+3*m*(x1**2-x2**2),mm )
# 解方程
solutions = solve(equation, m)
# 打印解
print("方程的解为:", solutions)
m=solutions[1]
#m=934704341809188566136104161085954963681535062511867825458866876852347092885690638603811614685284692453168523873036202765260225065341
print(long_to_bytes(m))
P高位泄露  小根攻击
例题
from Crypto.Util.number import *
from secret import flag

assert len(flag[8:-1])==23 #说明m比特位是256位
m = bytes_to_long(flag)
p = getPrime(1024)
q = getPrime(1024)
n = p*q
e = 65537
c1 = m^p
c2 = pow(m,e,n)
print(f'c1 = {c1}')
print(f'c2 = {c2}')
print(f'n = {n}')

c1 = 151198307301713399973545627808177783191262282577048906899567665485020342464366268384613589477129150406859219553325982275344405383612415523342568367197935454935162234419239807109194526080836070453102172720442102673200212658553214847476648456720629906051324248179394810385918370092764118401652990951968387233220
c2 = 7894512574379281106340582833782408137686355961537832816105517328532111343730615739255485918919146012721446905489729048235088965936700563973759759039693443386542070451737445467143517377017890468837697907596398070608179281207203217576205857817411996178441661371846647602166663752324880657668362355493701482869858528298247422875427747085642627978367348931707497113936723122393282697211257939351221141536029828744507560524637999804394951722319070365576391442828074457050403771353328835153787572457070779602728359333021922987279454923820866436212282592764768470608545881718922440010751845730974331917142224339664090863915
n = 20873587976264698212013861921447267548758723109929620330136081844796427967720295581580927324390713931549639540337285515365487607593546367886570408812338077846317206794057714877394609181224434104303259411081376607299962306250984285173463537669954845497211859940191392861121877814873939865829555350848523691546006073264112091406848179785659505299775196062799482197712761744192962658799557108701192680225134300686608396391566674966897700511638643429161735764600752699251493599533703928135311599575989253347234975026924804433742500175666009324057320386262109587593814197687132304704244158862263859846356497849518103755981
分析
c1=m^p，异或运算是针对二进制的逐一异或，这里告诉了m的比特位是256位，p的比特位1024位，那么c1前1024-256位是等于p的1024-256位的，那么只需要求p后面的256位即可，那么就可以联想到p的高位攻击，需要对c1进行变形成(c1>>256)<<256，那么自需要在sagemath进行p高位攻击求解p。

EXP（sagemath）
#sagemath
from Crypto.Util.number import *
import gmpy2
c1 = 151198307301713399973545627808177783191262282577048906899567665485020342464366268384613589477129150406859219553325982275344405383612415523342568367197935454935162234419239807109194526080836070453102172720442102673200212658553214847476648456720629906051324248179394810385918370092764118401652990951968387233220
c2 = 7894512574379281106340582833782408137686355961537832816105517328532111343730615739255485918919146012721446905489729048235088965936700563973759759039693443386542070451737445467143517377017890468837697907596398070608179281207203217576205857817411996178441661371846647602166663752324880657668362355493701482869858528298247422875427747085642627978367348931707497113936723122393282697211257939351221141536029828744507560524637999804394951722319070365576391442828074457050403771353328835153787572457070779602728359333021922987279454923820866436212282592764768470608545881718922440010751845730974331917142224339664090863915
n = 20873587976264698212013861921447267548758723109929620330136081844796427967720295581580927324390713931549639540337285515365487607593546367886570408812338077846317206794057714877394609181224434104303259411081376607299962306250984285173463537669954845497211859940191392861121877814873939865829555350848523691546006073264112091406848179785659505299775196062799482197712761744192962658799557108701192680225134300686608396391566674966897700511638643429161735764600752699251493599533703928135311599575989253347234975026924804433742500175666009324057320386262109587593814197687132304704244158862263859846356497849518103755981
e = 65537
R.<x> = PolynomialRing(Zmod(n), implementation='NTL')
c3=(c1>>256)<<256  #相当于p高位攻击
p = c3 + x
x0 = p.small_roots(X = 2^256, beta = 0.1)[0]
P = int(p(x0))
Q = n//P
phi=(P-1)*(Q-1)
d=inverse(e,phi)
m=gmpy2.powmod(c2,d,n)
print(long_to_bytes(m))
低加密指数攻击+共模攻击+P高位泄露
from flag import text,flag
import md5
from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrime

assert md5.new(text).hexdigest() == flag[6:-1]

msg1 = text[:xx]
msg2 = text[xx:yy]
msg3 = text[yy:]

msg1 = bytes_to_long(msg1)
msg2 = bytes_to_long(msg2)
msg3 = bytes_to_long(msg3)

p1 = getPrime(512)
q1 = getPrime(512)
N1 = p1*q1
e1 = 3
print pow(msg1,e1,N1)
print (e1,N1)

p2 = getPrime(512)
q2 = getPrime(512)
N2 = p2*q2
e2 = 17
e3 = 65537
print pow(msg2,e2,N2)
print pow(msg2,e3,N2)
print (e2,N2)
print (e3,N2)

p3 = getPrime(512)
q3 = getPrime(512)
N3 = p3*q3
print pow(msg3,e3,N3)
print (e3,N3)
print p3>>200

19105765285510667553313898813498220212421177527647187802549913914263968945493144633390670605116251064550364704789358830072133349108808799075021540479815182657667763617178044110939458834654922540704196330451979349353031578518479199454480458137984734402248011464467312753683234543319955893
(3, 123814470394550598363280518848914546938137731026777975885846733672494493975703069760053867471836249473290828799962586855892685902902050630018312939010564945676699712246249820341712155938398068732866646422826619477180434858148938235662092482058999079105450136181685141895955574548671667320167741641072330259009L)
54995751387258798791895413216172284653407054079765769704170763023830130981480272943338445245689293729308200574217959018462512790523622252479258419498858307898118907076773470253533344877959508766285730509067829684427375759345623701605997067135659404296663877453758701010726561824951602615501078818914410959610
91290935267458356541959327381220067466104890455391103989639822855753797805354139741959957951983943146108552762756444475545250343766798220348240377590112854890482375744876016191773471853704014735936608436210153669829454288199838827646402742554134017280213707222338496271289894681312606239512924842845268366950
(17, 111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977L)
(65537, 111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977L)
59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646
(65537, 113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147L)
7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902

EXP
from hashlib import md5

import gmpy2
from Cryptodome.Util.number import *
from gmpy2 import iroot, gcdext

n1=123814470394550598363280518848914546938137731026777975885846733672494493975703069760053867471836249473290828799962586855892685902902050630018312939010564945676699712246249820341712155938398068732866646422826619477180434858148938235662092482058999079105450136181685141895955574548671667320167741641072330259009
c1=19105765285510667553313898813498220212421177527647187802549913914263968945493144633390670605116251064550364704789358830072133349108808799075021540479815182657667763617178044110939458834654922540704196330451979349353031578518479199454480458137984734402248011464467312753683234543319955893
e1=3
k=0
while(1):
    ret=iroot(c1+k*n1,e1)
    if(ret[1]==True):
        m1=ret[0]
        print(long_to_bytes(m1))
        break
    k=k+1

c21=54995751387258798791895413216172284653407054079765769704170763023830130981480272943338445245689293729308200574217959018462512790523622252479258419498858307898118907076773470253533344877959508766285730509067829684427375759345623701605997067135659404296663877453758701010726561824951602615501078818914410959610
c22=91290935267458356541959327381220067466104890455391103989639822855753797805354139741959957951983943146108552762756444475545250343766798220348240377590112854890482375744876016191773471853704014735936608436210153669829454288199838827646402742554134017280213707222338496271289894681312606239512924842845268366950
e2=17
e3=65537
n2=111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977
s, s1, s2 = gcdext(e2, e3)
m2 = pow(c21, s1, n2)*pow(c22, s2, n2) % n2
print(long_to_bytes(m2))

c3=59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646
e3=65537
n3=113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147
p3= 11437038763581010263116493983733546014403343859218003707512796706928880848035239990740428334091106443982769386517753703890002478698418549777553268906496423
q3= 9918033198963879798362329507637256706010562962487329742400933192721549307087332482107381554368538995776396557446746866861247191248938339640876368268930589
phi=(p3-1)*(q3-1)
d = gmpy2.invert(e3, phi)
m3 = pow(c3, d, n3)
print(long_to_bytes(m3))
text=long_to_bytes(m1)+long_to_bytes(m2)+long_to_bytes(m3)
print(md5(text).hexdigest())#最后将每一段的明文m用md5加密后转为16进制
P高位攻击的sage脚本

n = 113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147
p4 = 7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902
e = 65537
pbits = 512
kbits = pbits - p4.nbits()
print(p4.nbits())
p4 = p4 << kbits
PR.<x> = PolynomialRing(Zmod(n))
f = x + p4
roots = f.small_roots(X=2^kbits, beta=0.4)
if roots:
    p = p4+int(roots[0])
    print("n: "+str(n))
    print("p: "+str(p))
    print("q: "+str(n//p))
二次剩余
Schmidit-Samoa密码系统
例题
from secret import flag
from Crypto.Util.number import*
from gmpy2 import*

flag = b'D0g3xGC{****************}'

def gen_key(p, q):
    public_key = p*p*q
    e = public_key
    n = p*q
    phi_n = (p-1)*(q-1)
    private_key = inverse(e,phi_n)
    return public_key,private_key,e

p = getPrime(512)
q = getPrime(512)

N,d,e = gen_key(p,q)

c = gmpy2.powmod(bytes_to_long(flag),e,N)

print(N)
print(d)
print(c)


n = 539403894871945779827202174061302970341082455928364137444962844359039924160163196863639732747261316352083923762760392277536591121706270680734175544093484423564223679628430671167864783270170316881238613070741410367403388936640139281272357761773388084534717028640788227350254140821128908338938211038299089224967666902522698905762169859839320277939509727532793553875254243396522340305880944219886874086251872580220405893975158782585205038779055706441633392356197489
d = 58169755386408729394668831947856757060407423126014928705447058468355548861569452522734305188388017764321018770435192767746145932739423507387500606563617116764196418533748380893094448060562081543927295828007016873588530479985728135015510171217414380395169021607415979109815455365309760152218352878885075237009
c = 82363935080688828403687816407414245190197520763274791336321809938555352729292372511750720874636733170318783864904860402219217916275532026726988967173244517058861515301795651235356589935260088896862597321759820481288634232602161279508285376396160040216717452399727353343286840178630019331762024227868572613111538565515895048015318352044475799556833174329418774012639769680007774968870455333386419199820213165698948819857171366903857477182306178673924861370469175
分析：
我们看到有

看3式，

可
以
拆
分
成
：
和
由欧拉定理（​，n=p*q）得到：

有
：
结
合
欧
拉
定
理
得
到
：
有
：
即
：
所以：

因
为
的
取
值
可
以
是
，
，
，
，
这
里
方
便
计
算
我
们
取
；
EXP
from Cryptodome.Util.number import *
from gmpy2 import*
c =82363935080688828403687816407414245190197520763274791336321809938555352729292372511750720874636733170318783864904860402219217916275532026726988967173244517058861515301795651235356589935260088896862597321759820481288634232602161279508285376396160040216717452399727353343286840178630019331762024227868572613111538565515895048015318352044475799556833174329418774012639769680007774968870455333386419199820213165698948819857171366903857477182306178673924861370469175
n =539403894871945779827202174061302970341082455928364137444962844359039924160163196863639732747261316352083923762760392277536591121706270680734175544093484423564223679628430671167864783270170316881238613070741410367403388936640139281272357761773388084534717028640788227350254140821128908338938211038299089224967666902522698905762169859839320277939509727532793553875254243396522340305880944219886874086251872580220405893975158782585205038779055706441633392356197489
d =58169755386408729394668831947856757060407423126014928705447058468355548861569452522734305188388017764321018770435192767746145932739423507387500606563617116764196418533748380893094448060562081543927295828007016873588530479985728135015510171217414380395169021607415979109815455365309760152218352878885075237009
pq=gcd(pow(2,n*d,n)-2,n)
m=pow(c,d,pq)
print(long_to_bytes(m))
AMM算法
LSB Oracle Attack
概念
假设现在有一个oracle(预言机)，它会对一个给定的密文进行解密，但并不会直接返回解密结果，而是检验解密的明文的奇偶性，并根据奇偶性返回相应的值，比如1表示奇数，0表示偶数，即最低位(LSB, least significant bit )。

那么给定任意一个消息被加密后的密文，只需要log(N)次oracle询问，就可以解密出明文消息。(例如当N是1024位时，只需要大约1024次左右的oracle询问，就可以解密出明文。)

![image-20250112151028471](../../AppData/Roaming/Typora/typora-user-images/image-20250112151028471.png)

![image-20250112151014372](../../AppData/Roaming/Typora/typora-user-images/image-20250112151014372.png)

RSA的积性（乘法同态）
证明：

利用这个性质，可以选择一个s，并计算​，将c'发送给服务器，服务器会返回c'解密结果m·s的奇偶性。通过不断巧妙地继续选取s，就可以恢复出m。

推导例：
假设我们现在已经获取到了明文m加密所得的密文c。
第一次选择s=2，并向服务器发送

服务器解密得到

并会返回​的奇偶性

由于​，所以​有两种情况：

1.返回偶数：

			说明没有被mod n，就是​，说明2·m<n，即​

2.返回奇数：

			说明被mod n，揭秘结果为​，由于​为偶数n为奇数，因此服务器返回奇数，说明​，即​

第二次选择s=4，并向服务器发送

服务器解密得到

并会返回​的奇偶性。

如果​：

			服务器返回“偶数”，说明没有被mod n，由4·m<n，也就是说​

			服务器返回“奇数”，说明4·m>n，也就是说​

如果​：

			服务器返回“偶数”，说明​，即​

			服务器返回“奇数”，说明​，即​

通过上述方法，可以将m的取直范围缩小一半.

之后，仍然可以继续类似的操作，通过选取​，服务器会返回​的奇偶性，从而可以不断地将范围缩小一半，直至最后范围缩小到1、即为正确的m.

例题：
题目：

![image-20250112155408496](../../AppData/Roaming/Typora/typora-user-images/image-20250112155408496.png)

oracle会将给定的任意密文解密，并将奇偶性反馈。

![image-20250112155518808](../../AppData/Roaming/Typora/typora-user-images/image-20250112155518808.png)

Coppersmith定理
1996年，Don Coppersmith借助LLL法构造格子，发现了一种可以求解任意多项式小根的算法即Coppersmith定理。

Coppersmith将这个算法应用在了RSA上面，从而打开了RSA的一个新的利用面，可以在已知某些关键信息(例如明文的部分bit、p的部分bit )的情况下，实现对RSA的破解(解密密文/分解模数)，这种利用手法被称为Coppersmith利用。

推导
假设N为一个未知分解情况的合数，并定义：

为一个最高次数为k的整系数多项式。

现假设这个多项式存在一个根​，即

满足​。

Coppersmith给出了一个算法，可以很快地求出这个小根。（如：当N为1024bit，k=3时，
小
于
​）

令p(x)为一个最高次数为k的首一多项式，N为一个未知其分解情况的正合数，​为一个极小的量。那么在多项式时间（算法复杂度较低）内，我们可以找到​的整数解​，满足

（证明过于复杂，涉及到格构造、LLL算法等知识点）

![image-20250112212949238](../../AppData/Roaming/Typora/typora-user-images/image-20250112212949238.png)

带入RSA的情景，如果我们可以获得到​的明文信息​，并且RSA的加密指数e=3，加密结果为c，现在需要求解另外​的明文信息，从而恢复出整个明文信息。

假设未知明文信息为x，那么根据：

即：

借助Coppersmith的算法，可以将这个多项式中的未知量x(小根)很快的求解出来。

例题1：已知m的高位攻击
题目场景：假设模数n为1024bit，e=3，现在已知m的高位​，只有低72位未知，未知量符合小根的条件（小于341bit）.

解：

设未知量为x，构造如下mod n的多项式：

使用Coppersmith定理求解x.

![image-20250112213812748](../../AppData/Roaming/Typora/typora-user-images/image-20250112213812748.png)

![image-20250112213822067](../../AppData/Roaming/Typora/typora-user-images/image-20250112213822067.png)

例题2
from Crypto.Util.number import *
import os

from flag import flag
def gen():
    e = 3
    while True:
        try:
            p = getPrime(512)
            q = getPrime(512)
            n = p*q
            phi = (p-1)*(q-1)
            d = inverse(e,phi)
            return p,q,d,n,e
        except:
            continue
    return
p,q,d,n,e = gen()
r = getPrime(512)
m = bytes_to_long(flag+os.urandom(32))
M = m%r
c = pow(m,e,n)
print("r = %d"%r)
print("M = %d"%M)
print("n = %d"%n)
print("e = %d"%e)
print("c = %d"%c)
r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473
M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558
n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287
e = 3
c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282
分析
考虑：​

则有：​

构造模多项式：​

CopperSmith求解即可。

EXP
#sagemath
from Crypto.Util.number import *

r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473
M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558
n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287
e = 3
c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282

PR.<x> = PolynomialRing(Zmod(n))
#定义多项式环，Zmod(n)表示模数n的整数环，也就是说所有系数和运算都是在模n下进行的
f = (M + x*r)**e - c 
#构造一个多项式方程f(x)=(M+x*r)**e-c
f = f.monic()   
#monic()方法将多项式算法f(x)归一化，使得最高次项的系数为1，因为 small_roots() 需要多项式是首一多项式
k = f.small_roots()
#small_roots()方法用于求解多项式方程f(x)=0 (mod n)的小整数根
m = M + k[0]*r
print(long_to_bytes(int(m)))
例题3（星盟面试1）
题目
from Crypto.Util.number import *
from secret import flag


p = getPrime(512)
q = getPrime(512)
n = p * q
e = 65537
assert GCD(e, (p - 1) * (q - 1)) == 1

secret = bytes_to_long(flag)

c = pow(secret, e, n)

x = bytes_to_long(urandom(64))
y = bytes_to_long(urandom(64))
gift = crt([x, y], [p, q])

n = n >> 440 << 440

print('n = 0x{:x}'.format(n))
print('e = 0x{:x}'.format(e))
print('c = 0x{:x}'.format(int(c)))
print('gift = 0x{:x}, 0x{:x}, 0x{:x}'.format(x, y, gift))


n = 0x96ec5a787fe02affea57b535d2ca3475612722967c8d67d2dc950ee7a67dcb432690bbf3ebbab64f1676956ed022d4c3e6fa075cc8f3e83dbb69e17aa8298f21e0fb03f5f119522ce800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
e = 0x10001
c = 0x45ed5cfedd662bc76cae0ec229b3d81328cffd1237640f1866fe4f33cd78ef7a2a3d8566e189cc284d9a901fc2de361ef50910df0830cec7fc02a34a6917107e2926a006fb38db9d2c8f5031c4445e0819a07632e19020f3076b2e1e311ee11f961204016464f7c8cb7a3c87b7571690f25db6bc7427b4156117776f16f6faef
gift = 0x44b13cd3bccf0839cf7a4570f320a3588b7a6177a8b30237e2d3ccad6966db732e019a9e23312ff35171c2da9f1464f3249b77e67fff76c3f2e9b6390f6b5ec, 0xb168b2fcab63103ee619f387a20bbfcfeb0a87bf7f339dd6f84d5f93187c27a0bafa1e0317dc5a02055a6867810fdb0c1976fa9e0101278cafa8e778f4f6cf95, 0x648019c4947179187e1b091941e1b02579e6553935cd4a062a518e3a887e63f7bf7fae48f8aae6920349d0bfc2e43a3bb6dc0fa65fd9f8200e87b7c349313fd8ccbc5ed9397a15cf5f7e10634d9bebc62ddaca921fc91879d1c51c14f03231ca037bcb0858f0dfe5a0cabdd3a83cff3012babaf4792b8906291bfccfe4ec3e43
分析
拿到题目我们看到题目有两段主要运算加密代码：

gift = crt([x, y], [p, q])
n = n >> 440 << 440
且给出了​的信息。其中n给出了部分高位，低位440位未知，由此我们可以想到利用coppersmith的小根攻击来进行破解n，拿到n之后在进行后续的破解。

利用小根攻击，我们需要找到在一个模数n的整数域内进行运算，例如在一般高位泄露攻击中：如P的高位泄露，我们一般找到的整数域是n，因为这里n是p的倍数，利用小根攻击可以进行破解。同理我们在这里也需要构造一个整数域来对n进行破解(即找到一个已知的数是n的倍数)。

寻找过程：
我们已知：

推导得到：

(注：gift,x,y已知，故kn可以表示出来，这里的kn即我们要找的n的倍数)

#sagemath
n = 0x96ec5a787fe02affea57b535d2ca3475612722967c8d67d2dc950ee7a67dcb432690bbf3ebbab64f1676956ed022d4c3e6fa075cc8f3e83dbb69e17aa8298f21e0fb03f5f119522ce800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
N=(gift-x)*(gift-y)
R.<x> = PolynomialRing(Zmod(N), implementation='NTL')
c3=(n>>440)<<440
n = c3 + x
x0 = n.small_roots(X = 2^440, beta = 0.4)[0]
#small_roots()参数：
#X：指定根的预期上界，这里440即未知的数的位数
#beta：控制算法对模数 N 的依赖程度，即已知位数在模数域中的占比，一般在0.4左右。
nn = int(n(x0))
print("nn=",nn)
将n进行求解之后，我们在分析后面部分：

在前面求解n的过程中，我们知道

这时我们便容易联想到gcd的妙用：

p=gcd(n,(gift-x))
q=gcd(n,(gift-y))
求得了p和q剩下的就是RSA解密了。

例题4（星盟面试2）
题目
import gmpy2, libnum
from secret import flag1, flag2

m = libnum.s2n(flag1)
assert m.bit_length() < 200
B = gmpy2.next_prime(libnum.s2n(flag2))
A = (2022 - 2023 * m) % B
leak = pow(2, 2023, B)
print(A)
print(leak)
# 493275281479560936332761096886786925792234184811353209227551802099268192839677496844153534128991899414803550843408607188612593757622064753867565869035222715177143938385039508273050267347710495512806264863554858016145161165422812554800693811328453743229819656381224407015421235005940088439590887928051969351426291843586132741521121351667152673680122929827805479163871436776753859965413192837591532468372
# 238829196127128263156194898141748280130190920343265228257398802867203846004703877952990524473329125233083096275276064071930416561616135910190674099345267027039386328203653489152769309498199556401574021633071022874689081585677578010276529507102304828451681000682208089162940529052283763507244593173690786957816545746540436261888398732172965945762569416702401859253725696471593023885944262561159982327952
分析
我们看到题目将flag分为了两部分，且给出了关于
和
​的等式和值。

由2式得：
即
：
​

变形1式得：​
（注：这里的k_1和k_2不相等但是不重要，因为由上一题我们知道这里我们只是为了构造出一个模数域，使其能够使用小根算法进行求解，即这里的​即可作为所需要的一个大的模数域。）

A = 493275281479560936332761096886786925792234184811353209227551802099268192839677496844153534128991899414803550843408607188612593757622064753867565869035222715177143938385039508273050267347710495512806264863554858016145161165422812554800693811328453743229819656381224407015421235005940088439590887928051969351426291843586132741521121351667152673680122929827805479163871436776753859965413192837591532468372
leak = 238829196127128263156194898141748280130190920343265228257398802867203846004703877952990524473329125233083096275276064071930416561616135910190674099345267027039386328203653489152769309498199556401574021633071022874689081585677578010276529507102304828451681000682208089162940529052283763507244593173690786957816545746540436261888398732172965945762569416702401859253725696471593023885944262561159982327952
n = 2 ^ 2023 - leak
PR.<x>= PolynomialRing(Zmod(n))
f = 2022 - 2023 * x - A
#构造函数:f%n=0
ans = f.monic().small_roots(X=2 ^ 201, beta=0.48)[0]
print(bytes.fromhex(hex(ans)[2::]))
求得m1后，继续进行m2的破解，m2的破解即对B的破解。

利用上面1式和2式构造关于B的等式，利用gcd求解即可。

leak = 238829196127128263156194898141748280130190920343265228257398802867203846004703877952990524473329125233083096275276064071930416561616135910190674099345267027039386328203653489152769309498199556401574021633071022874689081585677578010276529507102304828451681000682208089162940529052283763507244593173690786957816545746540436261888398732172965945762569416702401859253725696471593023885944262561159982327952
c = 2**2023 - leak
m = 2438621860802508754666419561610531898810985542251330229087
A = 493275281479560936332761096886786925792234184811353209227551802099268192839677496844153534128991899414803550843408607188612593757622064753867565869035222715177143938385039508273050267347710495512806264863554858016145161165422812554800693811328453743229819656381224407015421235005940088439590887928051969351426291843586132741521121351667152673680122929827805479163871436776753859965413192837591532468372
f = 2022-2023*m-A
print(gmpy2.gcd(c, f))
B = gmpy2.gcd(c, f)
print(gmpy2.is_prime(B))
print(long_to_bytes(int(B)))
除了已知m的高位这种利用场景，Coppersmith还适用于很多其他场景：

			已知p的高位

			已知d的高位

			Padding过短

结合具体情况，构造多项式进行求解。

Boneh & Durfee（小逆元攻击）
概述
Boneh-Durfee 攻击是一种针对 RSA 密码系统的攻击方法，主要用于在 RSA 私钥 d 较小的情况下恢复私钥。该攻击由 Dan Boneh 和 Glenn Durfee 在 1999 年提出，是对 Wiener 攻击 的改进和扩展。

攻击详情
属性	描述
攻击目标	恢复 RSA 私钥 d，当 d较小时（​）。
适用范围	私钥 d较小，且公钥 e和模数 n已知。
核心思想	利用 格基规约（Lattice Reduction） 技术（如 LLL 算法）求解与 dd 相关的方程。
关键方程	​，其中 k是未知整数。
攻击步骤	1. 构造方程。 <br />2. 构造格（Lattice）。 <br />3. 使用 LLL 算法找到短向量，恢复 d**。
计算复杂度	较高，尤其是当 d接近 ​ 时。
防御措施	1. 使用较大的私钥 d。 <br />2. 使用随机化的 RSA 密钥生成方法。 <br />3. 使用 ECC 替代 RSA。
攻击步骤详解
步骤	描述
1. 构造方程	从 RSA 定义出发，构造方程​，其中 k是未知整数。
2. 构造格（Lattice）	构造一个由向量组成的格，例如：​
3. 使用 LLL 算法	通过 LLL 算法找到格中的短向量，这些短向量可能包含 d和 k。
4. 恢复私钥 d	从短向量中提取 d，恢复 RSA 私钥。
1. 推导关键方程
步骤	公式	描述
1. 从 RSA 定义出发	e⋅d=k⋅ϕ(n)+1	根据 RSA 定义，私钥 d 满足此方程，其中 k是未知整数。
2. 代入 ϕ(n)*ϕ*(*n*)	ϕ(n)=n−(p+q)+1	将 ϕ(n) 表示为 n、p 和 q的函数。
3. 代入并整理	e⋅d=k⋅(n−(p+q)+1)+1	将 ϕ(n) 代入方程。
4. 展开方程	e⋅d=k⋅n−k⋅(p+q)+k+1	展开方程，得到关于 d、k、p 和 q的关系。
5. 近似处理	e⋅d−k⋅n≈1−k⋅(p+q)+k	由于 p+q的值与 n相关，且 p+q≈n，可以进行近似处理。
6. 最终方程	e⋅d−k⋅n≈1	忽略 k⋅(p+q)的高阶项，得到近似方程。
2. 构造格（Lattice）
步骤	描述
1. 构造格	构造一个由以下向量组成的格： ​
2. 目标	找到格中的短向量，这些短向量可能包含 d和 k。
3. 使用 LLL 算法	通过 LLL 算法对格进行规约，找到短向量。
3. 求解私钥 d
步骤	描述
1. 找到短向量	通过 LLL 算法找到格中的短向量，这些短向量可能包含 d和 k。
2. 提取 d	从短向量中提取 d，恢复 RSA 私钥。
攻击的适用范围与局限性
属性	描述
适用范围	私钥 d较小（​），且公钥 e和模数 n已知。
与 Wiener 攻击对比	Wiener 攻击仅适用于 ​，Boneh-Durfee 攻击适用范围更广。
局限性	1. 需要 d较小。 2. 计算复杂度较高，尤其是当 d接近 ​时。
防御措施
措施	描述
使用较大的私钥 d*d*	确保 dd 不满足 ​。
随机化密钥生成	使用随机化的 RSA 密钥生成方法，避免 d过小。
使用替代方案	使用其他加密方案（如 ECC）替代 RSA。
总结
Boneh-Durfee 攻击是一种基于格基规约的 RSA 攻击方法，适用于私钥 d较小的情况。通过构造与 d和 k相关的格，并利用 LLL 算法找到短向量，攻击者可以恢复 RSA 私钥。为了防止这种攻击，应确保私钥 d足够大。

出题脚本
from Crypto.Util.number import getPrime, long_to_bytes as ltb, bytes_to_long as btl 
from gmpy2 import invert, powmod

DEBUG = True 
flag = b'flag{AL3XEI_FAKE_FLAG}' 

p,q = [getPrime(1024) for _ in "pq"] 
D = getPrime(540) 
phi = ( p - 1 ) * ( q - 1 ) 
n = p * q 
d = phi - D 
e = invert( d , phi ) 
m = btl(flag) 
c = powmod( m, e, n ) 

print(f"n = { n }") 
print(f"e = { e }") 
print(f"c = { c }") 

if DEBUG: 
    print(D > int(( 1 / 3 ) * ( n ** ( 1 / 4) ))) # True
    print(D < int(n ** 0.292)) # True 
    print(d > int(( 1 / 3 ) * ( n ** ( 1 / 4) ))) # True
解题脚本
from Crypto.Util.number import long_to_bytes
import itertools


def small_roots(f, bounds, m=1, d=None):
    if not d:
        d = f.degree()

    R = f.base_ring()
    N = R.cardinality()

    f /= f.coefficients().pop(0)
    f = f.change_ring(ZZ)

    G = Sequence([], f.parent())
    for i in range(m + 1):
        base = N ^ (m - i) * f ^ i
        for shifts in itertools.product(range(d), repeat=f.nvariables()):
            g = base * prod(map(power, f.variables(), shifts))
            G.append(g)

    B, monomials = G.coefficients_monomials()
    monomials = vector(monomials)

    factors = [monomial(*bounds) for monomial in monomials]
    for i, factor in enumerate(factors):
        B.rescale_col(i, factor)

    B = B.dense_matrix().LLL()

    B = B.change_ring(QQ)
    for i, factor in enumerate(factors):
        B.rescale_col(i, 1 / factor)

    H = Sequence([], f.parent().change_ring(QQ))
    for h in filter(None, B * monomials):
        H.append(h)
        I = H.ideal()
        if I.dimension() == -1:
            H.pop()
        elif I.dimension() == 0:
            roots = []
            for root in I.variety(ring=ZZ):
                root = tuple(R(root[var]) for var in f.variables())
                roots.append(root)
            return roots

    return []


n = 
e = 
c = 


P = Zmod(ZZ(e))["k,s"]
k, s = P.gens()
f = 1 + k * (n - s)
rs = small_roots(f, (2**540, 2**1025), m=4, d=5)
print(rs)
k, s = map(int, rs[0])
phi = n - s
d = pow(e, -1, phi)
m = pow(c, d, n)
print(long_to_bytes(int(m)))
# b'flag{AL3XEI_FAKE_FLAG}'
威尔逊定理
例题1
from Crypto.Util.number import *
from secret import flag
p = getPrime(1024)
q = getPrime(16)
n = p*q
m = bytes_to_long(flag)
for i in range(1,p-q):
    m = m*i%n
e = 1049
print(pow(2,e,n))
print(pow(m,e,n))
#4513855932190587780512692251070948513905472536079140708186519998265613363916408288602023081671609336332823271976169443708346965729874135535872958782973382975364993581165018591335971709648749814573285241290480406050308656233944927823668976933579733318618949138978777831374262042028072274386196484449175052332019377
#3303523331971096467930886326777599963627226774247658707743111351666869650815726173155008595010291772118253071226982001526457616278548388482820628617705073304972902604395335278436888382882457685710065067829657299760804647364231959804889954665450340608878490911738748836150745677968305248021749608323124958372559270
分析
威尔逊定理：当P是质数时有：​

由题目我们知道q很小，所以我们可以从q入手：

kn = (1<<1049) - c2#1<<1049相当于1*2**1049

for q in range(1<<15, 1<<16):
    if isPrime(q) and kn % q == 0:#（注：这里思考一下为什么kn一定整除p和q）
        p = factor.attack(kn // q)[-1]
        if powmod(2, e, p*q) == c2:
            break       
factor.attack 函数通常会返回一个包含所有因数的列表。由于我们已经知道 q，所以我们只需要 kn // q 的其他因数，即 p。[-1] 是取列表的最后一个元素，通常这个元素就是我们需要的 p。

例如，如果 factor.attack(kn // q) 返回一个列表：

[1, 3, 5, 7, 11, 13, 17, 19]
我们希望得到的是 p，因此通过 [-1] 取最后一个元素，得到 p = 19。

求出p和q之后我们可以求出​(因为加密算法是对m进行阶乘运算后的​进行的RSA加密)
为了求出m，我们需要对​的阶乘运算进行解密：

已知​满足：​

通过解密我们要得到：​

由于 ​，且 ​ 和 ​互质，我们可以将模 ​ 的运算分解为模 ​和模 ​ 的运算。这里我们只关注模 ​ 的部分，即​

解密过程在模 ​ 下为：​

将加密过程带入解密过程：

合并有：​

根据威尔逊定理，当p是素数是有：

因此有：​

最后再将​乘以-1的逆元即可。（-1的逆元就是-1）

EXP
from xenny.ctf.crypto.modern.asymmetric.rsa import factor
from Cryptodome.Util.number import isPrime, long_to_bytes
from gmpy2 import *

c2 = 4513855932190587780512692251070948513905472536079140708186519998265613363916408288602023081671609336332823271976169443708346965729874135535872958782973382975364993581165018591335971709648749814573285241290480406050308656233944927823668976933579733318618949138978777831374262042028072274386196484449175052332019377
c = 3303523331971096467930886326777599963627226774247658707743111351666869650815726173155008595010291772118253071226982001526457616278548388482820628617705073304972902604395335278436888382882457685710065067829657299760804647364231959804889954665450340608878490911738748836150745677968305248021749608323124958372559270
e = 1049

kn = (1<<1049) - c2#1<<1049相当于1*2**1049

for q in range(1<<15, 1<<16):
    if isPrime(q) and kn % q == 0:
        p = factor.attack(kn // q)[-1]
        if powmod(2, e, p*q) == c2:
            break

n = p*q
d = invert(e, (p-1)*(q-1))
t = 1
m = powmod(c, d, n)
# for i in range(1,p-q):
#     m = m*i%n
for i in range(p-q, p):
    m = m * i % p
print(long_to_bytes(m*invert(-1, p) %p))
证书类密码题型
说明
本类题我们将来了解关于RSA的证书格式，之前我们所有的题目都是给出具体的数字，然后在这些数字上面做操作，但是在现实世界中不可能直接传输数字来进行操作的，因为这太不稳定了，例如某处出现错误、出现截断、顺序颠倒等等都会导致整个传输过程出现不可查的错误。所以会有统一的格式对这些数字进行封装，而这种封装之后的内容我们就称之为证书。

我们常见的证书有两种格式，一种叫做PEM另一种为DER，实际上不管使用的是哪种格式，证书的内容最后都是我们那些数字，而且我们可以很轻松的在不同的证书之间进行转换。

例题1
题目给了两个文件：一个是public.key，txt打开是：

-----BEGIN PUBLIC KEY-----
MIIBJDANBgkqhkiG9w0BAQEFAAOCAREAMIIBDAKCAQMlsYv184kJfRcjeGa7Uc/4
3pIkU3SevEA7CZXJfA44bUbBYcrf93xphg2uR5HCFM+Eh6qqnybpIKl3g0kGA4rv
tcMIJ9/PP8npdpVE+U4Hzf4IcgOaOmJiEWZ4smH7LWudMlOekqFTs2dWKbqzlC59
NeMPfu9avxxQ15fQzIjhvcz9GhLqb373XDcn298ueA80KK6Pek+3qJ8YSjZQMrFT
+EJehFdQ6yt6vALcFc4CB1B6qVCGO7hICngCjdYpeZRNbGM/r6ED5Nsozof1oMbt
Si8mZEJ/Vlx3gathkUVtlxx/+jlScjdM7AFV5fkRidt0LkwosDoPoRz/sDFz0qTM
5q5TAgMBAAE=
-----END PUBLIC KEY-----
另一个文件是flag.enc，txt打开是：（明显用base64加密，需要先解密）

GVd1d3viIXFfcHapEYuo5fAvIiUS83adrtMW/MgPwxVBSl46joFCQ1plcnlDGfL19K/3PvChV6n5QGohzfVyz2Z5GdTlaknxvHDUGf5HCukokyPwK/1EYU7NzrhGE7J5jPdi0Aj7xi/Odxy0hGMgpaBLd/nL3N8O6i9pc4Gg3O8soOlciBG/6/xdfN3SzSStMYIN8nfZZMSq3xDDvz4YB7TcTBh4ik4wYhuC77gmT+HWOv5gLTNQ3EkZs5N3EAopy11zHNYU80yv1jtFGcluNPyXYttU5qU33jcp0Wuznac+t+AZHeSQy5vk8DyWorSGMiS+J4KNqSVlDs12EqXEqqJ0uA==
分析：
给出了一个PEM格式的公钥证书public.key。
这种格式的证书解密有两种方法（我知道的）：

1：使用SSL在线工具-公钥解析网站|

2：利用openssl工具

3：kali终端：​

4：python脚本：

from Cryptodome.PublicKey import RSA

with open("地址","r") as f:
key = RSA.import_key(f.read())
print(key.e)
print(key.n)
解密之后我们可以得到n和e，通过分解n（注：本题n可以分解，但并不一定所有的n都可以）得到p和q，进行下面运算。

后面运算看脚本。

EXP
(下面脚本的n,e,p,q,d都经过前面的运算得到，其中d需要先由e,p,q计算出来)

from base64 import b64decode
from Cryptodome.Cipher import PKCS1_OAEP
from Cryptodome.PublicKey import RSA
from gmpy2 import gmpy2


n=79832181757332818552764610761349592984614744432279135328398999801627880283610900361281249973175805069916210179560506497075132524902086881120372213626641879468491936860976686933630869673826972619938321951599146744807653301076026577949579618331502776303983485566046485431039541708467141408260220098592761245010678592347501894176269580510459729633673468068467144199744563731826362102608811033400887813754780282628099443490170016087838606998017490456601315802448567772411623826281747245660954245413781519794295336197555688543537992197142258053220453757666537840276416475602759374950715283890232230741542737319569819793988431443
p=3133337
q=25478326064937419292200172136399497719081842914528228316455906211693118321971399936004729134841162974144246271486439695786036588117424611881955950996219646807378822278285638261582099108339438949573034101215141156156408742843820048066830863814362379885720395082318462850002901605689761876319151147352730090957556940842144299887394678743607766937828094478336401159449035878306853716216548374273462386508307367713112073004011383418967894930554067582453248981022011922883374442736848045920676341361871231787163441467533076890081721882179369168787287724769642665399992556052144845878600126283968890273067575342061776244939
e=65537
phi=(p-1)*(q-1)
d=406853230956379689450620815713768871010712825839536410687962650677800895818003893712259622281477453292088146173840036827322518131453630576229976208523593618949818777897059256426591560532784635697190752924923710375949616954069804342573867253630978123632384795587951365482103468722384133084798614863870775897915929475258974188300927376911833763105616386167881813301748585233563049693794370642976326692672223638908164822104832415788577945314264232531947860576966629150456995512932232264881080618006698700677529111454508900582785420549466798020451488168615035256292977390692401388790460066327347700109341639992159475755036449
print(d)

key = RSA.construct((n, e, d, p, q))
#RSA.construct()：使用给定的参数构造一个RSA密钥对象
key = RSA.importKey(key.exportKey())
#key.exportKey()：将RSA密钥对象导出为PEM格式的字符串。RSA.importKey()：将导出的PEM格式字符串重新导入为一个RSA密钥对象。

key = PKCS1_OAEP.new(key)
#PKCS1_OAEP.new(key)：使用RSA密钥对象创建一个PKCS1_OAEP解密器对象。

f = 'GVd1d3viIXFfcHapEYuo5fAvIiUS83adrtMW/MgPwxVBSl46joFCQ1plcnlDGfL19K/3PvChV6n5QGohzfVyz2Z5GdTlaknxvHDUGf5HCukokyPwK/1EYU7NzrhGE7J5jPdi0Aj7xi/Odxy0hGMgpaBLd/nL3N8O6i9pc4Gg3O8soOlciBG/6/xdfN3SzSStMYIN8nfZZMSq3xDDvz4YB7TcTBh4ik4wYhuC77gmT+HWOv5gLTNQ3EkZs5N3EAopy11zHNYU80yv1jtFGcluNPyXYttU5qU33jcp0Wuznac+t+AZHeSQy5vk8DyWorSGMiS+J4KNqSVlDs12EqXEqqJ0uA=='
c = b64decode(f)
#b64decode(f)：将Base64编码的字符串解码为字节形式的密文c。
flag = key.decrypt(c)
print(flag)
例题2[RSA3]P11 | NSSCTF
本题给出了一个.pem的证书，同时给出了enc文件，但是没有给出具体的加密逻辑，此时我们只能先将证书的内容提取出来再做下一步判断。对于这些各类证书，我们都可以使用openssl工具进行提取.(这道题似乎不能用SSL在线网站打开)

.pem证书文件如下

-----BEGIN RSA PRIVATE KEY-----
MIICWwIBAAKBgHBkeHn6Q67opdN4V1S3mI0SsUuYzzm+IbXZDz4yZOMWz5nDBYuJ
SA8rRqDtqb7mtNdTGZZx7xe6tOwleqvkXn629mgUZZegyaBdBSPnUR6IUqduqpLo
HRavrHr1IkI6oAmDEQzi1lCZ03x0jMKuoOKp9LBhP9ijCoy9iRh9tH+FAgMBAAEC
gYAvLn5E9oKjUpcKh2Jh9hDcaBR1n9iebOrJ5C059v3TNyg/bFdPlHnjpE8qD5tK
wJ76JbCAL6QnWgHJgJJWxq/EAy/9SG+eApaBo94Sb2B2A1WceDf8F1idkXUOvU/3
kd/wbw/gLZLya8WCFF4SUZx09TToMqSWDEJI4kN17pU5AQJBAJv9ShfSbaMNK31O
kg9LSI7wFLq7iiFRl5kXvSKLsYB3HAKHNlV6/ZL1TV2jg37yf9Mi2f0Gx5AVXbwi
/1ef9R0CQQC4c5EkR8VAw8lqePLwCkCJisXKAEOqPZFOiSCCIVnY+5J4kgiZiS33
rskWwsYAIBHVKiXSy+5NdvWk51MeYi+JAkBiZNvmuOJVVkpXaUcyhH9JQmEhBIj1
yVzBwbqY3trhOMCfS6DXPJRUrYzWgvzAB8Dfcn1kYHFjDkcpFD5SjGB1AkBtyKNH
w8v820tjqu91vbRh6Q4GSBf+GL0G0IlfyrfudPXd+5VQxRxuAkM/39f3tR7IEFkI
2UZSJw7YArMvL2N5AkEAmVGTH6DU3ygzjCtdl4/2dhonSHcEovCFWGZuCqBjYEw6
IGYAlpOiv/BICMXrOBsdd1+4j6n1edxHSGH9q4Aoug==
-----END RSA PRIVATE KEY-----
分析
OPENSSL工具使用：

选项	描述
-help	显示帮助信息
-inform format	指定输入格式，可选值为 DER 或 PEM
-outform format	指定输出格式，可选值为 DER、PEM 或 PVK
-in val	指定输入文件
-out outfile	指定输出文件
-pubin	期望输入文件是一个公钥
-pubout	输出一个公钥文件
-passout val	给输出文件设置密码
-passin val	输入文件的密码
-RSAPublicKey_in	指定输入是一个RSA公钥
-RSAPublicKey_out	指定输出是一个RSA公钥
-noout	不要打印输入的密钥内容
-text	用文本格式打印密钥内容
-modulus	打印RSA密钥的模数
-check	检测密钥是否一致
-*	其他支持的参数
-pvk-strong	启用“强”PVK编码级别（默认）
-pvk-weak	启用“弱”PVK编码级别
-pvk-none	不强制执行PVK编码
-engine val	指定解析引擎，可能是一个硬件设备
这里列出了和rsa证书有关的项，那么我们要查看密钥内容的话直接

openssl rsa -in key.pem -inform PEM
会发现他将密钥内容又打印了一遍，这是因为它默认就是只做解析不会有其他操作，我们需要具体指定我们想要的操作，例如-text以文本内容输出参数，

openssl rsa -in key.pem -inform PEM -text
此时我们得到输出:

RSA Private-Key: (1023 bit, 2 primes)
modulus:
70:64:78:79:fa:43:ae:e8:a5:d3:78:57:54:b7:98:
8d:12:b1:4b:98:cf:39:be:21:b5:d9:0f:3e:32:64:
e3:16:cf:99:c3:05:8b:89:48:0f:2b:46:a0:ed:a9:
be:e6:b4:d7:53:19:96:71:ef:17:ba:b4:ec:25:7a:
ab:e4:5e:7e:b6:f6:68:14:65:97:a0:c9:a0:5d:05:
23:e7:51:1e:88:52:a7:6e:aa:92:e8:1d:16:af:ac:
7a:f5:22:42:3a:a0:09:83:11:0c:e2:d6:50:99:d3:
7c:74:8c:c2:ae:a0:e2:a9:f4:b0:61:3f:d8:a3:0a:
8c:bd:89:18:7d:b4:7f:85
publicExponent: 65537 (0x10001)
privateExponent:
2f:2e:7e:44:f6:82:a3:52:97:0a:87:62:61:f6:10:
dc:68:14:75:9f:d8:9e:6c:ea:c9:e4:2d:39:f6:fd:
d3:37:28:3f:6c:57:4f:94:79:e3:a4:4f:2a:0f:9b:
4a:c0:9e:fa:25:b0:80:2f:a4:27:5a:01:c9:80:92:
56:c6:af:c4:03:2f:fd:48:6f:9e:02:96:81:a3:de:
12:6f:60:76:03:55:9c:78:37:fc:17:58:9d:91:75:
0e:bd:4f:f7:91:df:f0:6f:0f:e0:2d:92:f2:6b:c5:
82:14:5e:12:51:9c:74:f5:34:e8:32:a4:96:0c:42:
48:e2:43:75:ee:95:39:01
prime1:
00:9b:fd:4a:17:d2:6d:a3:0d:2b:7d:4e:92:0f:4b:
48:8e:f0:14:ba:bb:8a:21:51:97:99:17:bd:22:8b:
b1:80:77:1c:02:87:36:55:7a:fd:92:f5:4d:5d:a3:
83:7e:f2:7f:d3:22:d9:fd:06:c7:90:15:5d:bc:22:
ff:57:9f:f5:1d
prime2:
00:b8:73:91:24:47:c5:40:c3:c9:6a:78:f2:f0:0a:
40:89:8a:c5:ca:00:43:aa:3d:91:4e:89:20:82:21:
59:d8:fb:92:78:92:08:99:89:2d:f7:ae:c9:16:c2:
c6:00:20:11:d5:2a:25:d2:cb:ee:4d:76:f5:a4:e7:
53:1e:62:2f:89
exponent1:
62:64:db:e6:b8:e2:55:56:4a:57:69:47:32:84:7f:
49:42:61:21:04:88:f5:c9:5c:c1:c1:ba:98:de:da:
e1:38:c0:9f:4b:a0:d7:3c:94:54:ad:8c:d6:82:fc:
c0:07:c0:df:72:7d:64:60:71:63:0e:47:29:14:3e:
52:8c:60:75
exponent2:
6d:c8:a3:47:c3:cb:fc:db:4b:63:aa:ef:75:bd:b4:
61:e9:0e:06:48:17:fe:18:bd:06:d0:89:5f:ca:b7:
ee:74:f5:dd:fb:95:50:c5:1c:6e:02:43:3f:df:d7:
f7:b5:1e:c8:10:59:08:d9:46:52:27:0e:d8:02:b3:
2f:2f:63:79
coefficient:
00:99:51:93:1f:a0:d4:df:28:33:8c:2b:5d:97:8f:
f6:76:1a:27:48:77:04:a2:f0:85:58:66:6e:0a:a0:
63:60:4c:3a:20:66:00:96:93:a2:bf:f0:48:08:c5:
eb:38:1b:1d:77:5f:b8:8f:a9:f5:79:dc:47:48:61:
fd:ab:80:28:ba
我们可以看到，它解析出了这个一个RSA的私钥文件，里面包含

modulus - 模数 - n
publicExponent - 加密指数 - e
privateExponent - 解密指数 - d
prime1 - 素因子 - p
prime2 - 素因子 - q
可以发现这里面直接包含了我们涉及到的所有RSA参数，除了这些我们已经见过的参数之外，还包含一些其他参数，这些参数是用来进行快速解密的CRT参数，实际上他们分别是

exponent1 - dp
exponent2 - dq
coefficient - invert(p, q)
这是一个非常完整的私钥，有时候提取出来的内容并不那么完整，例如只涉及其中的部分参数，此时这需要我们利用得到的参数进一步考察参数之前的关系，再使用我们之前所学习过的各类攻击手段对密文进行解密。

这里的输出实际上就是16进制值，你只需要把所有的:去掉并粘连为一行即可使用。

对于密文的话，我们直接从文件读取然后使用bytes_to_long转为数字处理即可。

EXP
from Crypto.Util.number import *
from gmpy2 import *

n = 0x70647879fa43aee8a5d3785754b7988d12b14b98cf39be21b5d90f3e3264e316cf99c3058b89480f2b46a0eda9bee6b4d753199671ef17bab4ec257aabe45e7eb6f668146597a0c9a05d0523e7511e8852a76eaa92e81d16afac7af522423aa00983110ce2d65099d37c748cc2aea0e2a9f4b0613fd8a30a8cbd89187db47f85


c = open('./enc', 'rb').read()
c = bytes_to_long(c)

d = 0x2f2e7e44f682a352970a876261f610dc6814759fd89e6ceac9e42d39f6fdd337283f6c574f9479e3a44f2a0f9b4ac09efa25b0802fa4275a01c9809256c6afc4032ffd486f9e029681a3de126f607603559c7837fc17589d91750ebd4ff791dff06f0fe02d92f26bc582145e12519c74f534e832a4960c4248e24375ee953901

print(long_to_bytes(pow(c, d, n)))
以上是手动提取字段的方案，实际上在Crypto包中已经包含了关于各类证书的解析，我们也可以使用exp

from Crypto.Util.number import *
from gmpy2 import *
from Crypto.PublicKey import RSA

rsa = RSA.importKey(open('key.pem', 'rb').read())

print(rsa.n, rsa.d, rsa.p)  # 提取具体值

c = open('./enc', 'rb').read()
c = bytes_to_long(c)
m = rsa._decrypt(c)

print(long_to_bytes(m))
关于openssl我们还可以使用它进行转换各类密钥格式，例如我们将密钥转换为DER格式

openssl rsa -in key.pem -inform PEM -outform DER -out key.der

又或者从私钥生成公钥文件

openssl rsa -in key.pem -inform PEM -pubout

证书部分损坏
题目
enc = 2329206064672111950904450292941421573350591294207157652026787098178545948258554492347649016030892000747909819064473414536692222493030122267884839986067073054508582403564557167583565364976046083954888777809177108315052118912603290095925912298584322873410379937455462434313487981715516761071523410121549134193124709612876311518391130974466069686830456036397449773159386026998482557500868323733155606973727191287617806211911722356975478414165867941665666556476756617951672736466672410799762479373101996896644454778482896784598378016390592459460753042458284030795009957030383305268628413551730442224404807955926606496353


我们还得到了半截密钥，请你解密上述密文

Oh17ELp/n2Urnqg/gaFbKWHgDNYzdPNGqNePgdrRtpfzq+js7QAiYNifLRK8k5XC
MwErb3RKOA0dCu14yftSoo2V+FjGML07Fk6Fe0BvVBMRQm1k1fC24NECgYEAvv/5
kH91u3rVYRMbXHauE3vWeuDjK5D5K5l7BEJ3yrPf64TyVROBJ+Gk5TdRpo23Q6AO
2KzFjzMQf+NdtrSBO8BI20i9UwvLNfukNNu3DifXiu3i3g1HRd81okVBe4x0oxp7
Vad9tF69btHcSz3KpDWnnb9yQNlndTcuZLWLCAMCgYB3pVRhTBEbUd6pA6joIivn
lbRZSIBfxvXqZ+YK1JPxF7MDPqLuhNh8CimofqOJCKk+MT4I/oPckbqGlbqWnUDy
Q63f9iDuQL2oVi/1OJZh79i51ZdrrPK8mhz8VNdwTHCYRBseclN2D8fbzvekFwgu
dJLo4ICPNNgwx3LoAHFPQQKBgBwQBf3qDEVAdetuYD3Eniz0q/2f3yC+iy2RvlZQ
4cLhjMvQ274OQJK4f37CEvgSqFOCR8wkDl7M1ObFZDZ87OP3i3zUgiSaff/veh/e
DFZDGlMqQoP3lXo5omq2HDnn2BdCw85A7qI6rUCECwbvDD/2NitiPooypxW8xs87
MTM7AoGBAISI776nLpq6x/cQhbhukHG+zhcPjJKjh669zIn4kVwzc5YJpzys1VWb
Olb9WQgu0xG6tJ9C6gumvl4lNFPbD8i1tqq0WBY7igExIf1cVU3MUdgcV+YPWdnX
+PTUX6skNl2gOe2PtUAc+v8Miq4hka6L10I1HREDT/Dwwy+wWGgQ
-----END RSA PRIVATE KEY-----
分析
在本题中我们得到的是一个破损的证书文件，此时我们无法直接使用openssl提取出想要的信息，但是信息就在里面，所以我们要了解PEM的证书编码格式。

首先我们要知道PEM文件是按照ASN.1标准进行DER编码后再进行Base64编码得到的内容，所以PEM和DER本质是一家，只是在DER的基础上添加了Base64编码。

证书格式举例讲解
首先我们先以一个完整证书为例说明证书格式，首先我们将证书解base64后在转换为16进制输出

from base64 import b64decode
import binascii

s = '''MIICWwIBAAKBgHBkeHn6Q67opdN4V1S3mI0SsUuYzzm+IbXZDz4yZOMWz5nDBYuJ
SA8rRqDtqb7mtNdTGZZx7xe6tOwleqvkXn629mgUZZegyaBdBSPnUR6IUqduqpLo
HRavrHr1IkI6oAmDEQzi1lCZ03x0jMKuoOKp9LBhP9ijCoy9iRh9tH+FAgMBAAEC
gYAvLn5E9oKjUpcKh2Jh9hDcaBR1n9iebOrJ5C059v3TNyg/bFdPlHnjpE8qD5tK
wJ76JbCAL6QnWgHJgJJWxq/EAy/9SG+eApaBo94Sb2B2A1WceDf8F1idkXUOvU/3
kd/wbw/gLZLya8WCFF4SUZx09TToMqSWDEJI4kN17pU5AQJBAJv9ShfSbaMNK31O
kg9LSI7wFLq7iiFRl5kXvSKLsYB3HAKHNlV6/ZL1TV2jg37yf9Mi2f0Gx5AVXbwi
/1ef9R0CQQC4c5EkR8VAw8lqePLwCkCJisXKAEOqPZFOiSCCIVnY+5J4kgiZiS33
rskWwsYAIBHVKiXSy+5NdvWk51MeYi+JAkBiZNvmuOJVVkpXaUcyhH9JQmEhBIj1
yVzBwbqY3trhOMCfS6DXPJRUrYzWgvzAB8Dfcn1kYHFjDkcpFD5SjGB1AkBtyKNH
w8v820tjqu91vbRh6Q4GSBf+GL0G0IlfyrfudPXd+5VQxRxuAkM/39f3tR7IEFkI
2UZSJw7YArMvL2N5AkEAmVGTH6DU3ygzjCtdl4/2dhonSHcEovCFWGZuCqBjYEw6
IGYAlpOiv/BICMXrOBsdd1+4j6n1edxHSGH9q4Aoug=='''

s = b64decode(s)

print(binascii.hexlify(s))
得到

3082025b02010002818070647879fa43aee8a5d3785754b7988d12b14b98cf39be21b5d90f3e3264e316cf99c3058b89480f2b46a0eda9bee6b4d753199671ef17bab4ec257aabe45e7eb6f668146597a0c9a05d0523e7511e8852a76eaa92e81d16afac7af522423aa00983110ce2d65099d37c748cc2aea0e2a9f4b0613fd8a30a8cbd89187db47f8502030100010281802f2e7e44f682a352970a876261f610dc6814759fd89e6ceac9e42d39f6fdd337283f6c574f9479e3a44f2a0f9b4ac09efa25b0802fa4275a01c9809256c6afc4032ffd486f9e029681a3de126f607603559c7837fc17589d91750ebd4ff791dff06f0fe02d92f26bc582145e12519c74f534e832a4960c4248e24375ee9539010241009bfd4a17d26da30d2b7d4e920f4b488ef014babb8a2151979917bd228bb180771c028736557afd92f54d5da3837ef27fd322d9fd06c790155dbc22ff579ff51d024100b873912447c540c3c96a78f2f00a40898ac5ca0043aa3d914e8920822159d8fb9278920899892df7aec916c2c6002011d52a25d2cbee4d76f5a4e7531e622f8902406264dbe6b8e255564a57694732847f494261210488f5c95cc1c1ba98dedae138c09f4ba0d73c9454ad8cd682fcc007c0df727d646071630e4729143e528c607502406dc8a347c3cbfcdb4b63aaef75bdb461e90e064817fe18bd06d0895fcab7ee74f5ddfb9550c51c6e02433fdfd7f7b51ec8105908d94652270ed802b32f2f63790241009951931fa0d4df28338c2b5d978ff6761a27487704a2f08558666e0aa063604c3a2066009693a2bff04808c5eb381b1d775fb88fa9f579dc474861fdab8028ba
这便是原始的ASN.1格式内容，首先我们要知道ASN.1是一种用来描述数据结构的抽象语法，它并不是只用来存储密钥，在ASN.1中你可以自定义你的数据类型和数值约束等条件，你可以把它理解为一种序列化数据的格式。其中数据格式如下

数据	长度	名称	含义
30	1	标记符	代表ASN.1结构的开始
82	1	长度类型	代表后面跟着一个双字节长度
025b	2	长度	代表后续内容的总长度为603字节
02	1	类型	代表整型
01	1	长度	代表1字节
00	1	值	代表整数0
02	1	类型	代表整型
81	1	长度类型	代表后面跟着一个单字节长度
80	1	长度	代表数据长度为128字节
…	128	值	数据值1
…			
以此往复，所以除了最开始的标识符外，后续的内容都是由

类型 + 长度 + 值 构成的，而这些值根据他们出现的位置不同有着不同的含义，例如最开始出现的值0在PEM中代表版本号信息。

随后的数据值1代表模数。完整顺序如下

版本
模数 - n
加密指数 - e
解密指数 - d
素因子1 - p
素因子2 - q
指数1 - dp
指数2 - dq
系数 - invert(q, p)
其他额外信息
标识头 30
总长度 82 025b
版本信息 0201 00
n 028180 70647879fa43aee8a5d3785754b7988d12b14b98cf39be21b5d90f3e3264e316cf99c3058b89480f2b46a0eda9bee6b4d753199671ef17bab4ec257aabe45e7eb6f668146597a0c9a05d0523e7511e8852a76eaa92e81d16afac7af522423aa00983110ce2d65099d37c748cc2aea0e2a9f4b0613fd8a30a8cbd89187db47f85
e 0203 010001
d 028180 2f2e7e44f682a352970a876261f610dc6814759fd89e6ceac9e42d39f6fdd337283f6c574f9479e3a44f2a0f9b4ac09efa25b0802fa4275a01c9809256c6afc4032ffd486f9e029681a3de126f607603559c7837fc17589d91750ebd4ff791dff06f0fe02d92f26bc582145e12519c74f534e832a4960c4248e24375ee953901
p 0241 009bfd4a17d26da30d2b7d4e920f4b488ef014babb8a2151979917bd228bb180771c028736557afd92f54d5da3837ef27fd322d9fd06c790155dbc22ff579ff51d
q 0241 00b873912447c540c3c96a78f2f00a40898ac5ca0043aa3d914e8920822159d8fb9278920899892df7aec916c2c6002011d52a25d2cbee4d76f5a4e7531e622f89
dp 0240 6264dbe6b8e255564a57694732847f494261210488f5c95cc1c1ba98dedae138c09f4ba0d73c9454ad8cd682fcc007c0df727d646071630e4729143e528c6075
dq 0240 6dc8a347c3cbfcdb4b63aaef75bdb461e90e064817fe18bd06d0895fcab7ee74f5ddfb9550c51c6e02433fdfd7f7b51ec8105908d94652270ed802b32f2f6379
inv(q,p) 0241 009951931fa0d4df28338c2b5d978ff6761a27487704a2f08558666e0aa063604c3a2066009693a2bff04808c5eb381b1d775fb88fa9f579dc474861fdab8028ba
现在回到本题我们也先进行base64解码得到，因为这里是密钥的后半截，所以我们不能从前往后直接解析，需要先找到一个定位锚点，我们可以按照02先给数据初步分段

3a1d7b10ba7f9f652b9ea83f81a15b2961e00cd63374f346a8d78f81dad1b697f3abe8eced0
02260d89f2d12bc9395c233012b6f744a380d1d0aed78c9fb52a28d95f858c630bd3b164e857b406f541311426d64d5f0b6e0d1
02818100befff9907f75bb7ad561131b5c76ae137bd67ae0e32b90f92b997b044277cab3dfeb84f255138127e1a4e53751a68db743a00ed8acc58f33107fe35db6b4813bc048db48bd530bcb35fba434dbb70e27d78aede2de0d4745df35a245417b8c74a31a7b55a77db45ebd6ed1dc4b3dcaa435a79dbf7240d96775372e64b58b0803
02818077a554614c111b51dea903a8e8222be795b45948805fc6f5ea67e60ad493f117b3033ea2ee84d87c0a29a87ea38908a93e313e08fe83dc91ba8695ba969d40f243addff620ee40bda8562ff5389661efd8b9d5976bacf2bc9a1cfc54d7704c7098441b1e7253760fc7dbcef7a417082e7492e8e0808f34d830c772e800714f41
0281801c1005fdea0c454075eb6e603dc49e2cf4abfd9fdf20be8b2d91be5650e1c2e18ccbd0dbbe0e4092b87f7ec212f812a8538247cc240e5eccd4e6c564367cece3f78b7cd482249a7dffef7a1fde0c56431a532a4283f7957a39a26ab61c39e7d81742c3ce40eea23aad40840b06ef0c3ff6362b623e8a32a715bcc6cf3b31333b
028181008488efbea72e9abac7f71085b86e9071bece170f8c92a387aebdcc89f8915c33739609a73cacd5559b3a56fd59082ed311bab49f42ea0ba6be5e253453db0fc8b5b6aab458163b8a013121fd5c554dcc51d81c57e60f59d9d7f8f4d45fab24365da039ed8fb5401cfaff0c8aae2191ae8bd742351d11034ff0f0c32fb0586810
不一定数据中出现了02就代表是数据开始的地方，因为也有可能数据中也包含02，我们要一一检验02后面的长度标识定义的长度时候符合后续数据的长度，我们会发现第一块后面的长度标识以及长度都不符合正常的定义，所以其实第一块这里的02是上一块数据中的内容而非新数据的开始标识。最终我们可以得到

3a1d7b10ba7f9f652b9ea83f81a15b2961e00cd63374f346a8d78f81dad1b697f3abe8eced002260d89f2d12bc9395c233012b6f744a380d1d0aed78c9fb52a28d95f858c630bd3b164e857b406f541311426d64d5f0b6e0d1
q 028181 00befff9907f75bb7ad561131b5c76ae137bd67ae0e32b90f92b997b044277cab3dfeb84f255138127e1a4e53751a68db743a00ed8acc58f33107fe35db6b4813bc048db48bd530bcb35fba434dbb70e27d78aede2de0d4745df35a245417b8c74a31a7b55a77db45ebd6ed1dc4b3dcaa435a79dbf7240d96775372e64b58b0803
dp 028180 77a554614c111b51dea903a8e8222be795b45948805fc6f5ea67e60ad493f117b3033ea2ee84d87c0a29a87ea38908a93e313e08fe83dc91ba8695ba969d40f243addff620ee40bda8562ff5389661efd8b9d5976bacf2bc9a1cfc54d7704c7098441b1e7253760fc7dbcef7a417082e7492e8e0808f34d830c772e800714f41
dq 028180 1c1005fdea0c454075eb6e603dc49e2cf4abfd9fdf20be8b2d91be5650e1c2e18ccbd0dbbe0e4092b87f7ec212f812a8538247cc240e5eccd4e6c564367cece3f78b7cd482249a7dffef7a1fde0c56431a532a4283f7957a39a26ab61c39e7d81742c3ce40eea23aad40840b06ef0c3ff6362b623e8a32a715bcc6cf3b31333b
inv(q,p) 028181 008488efbea72e9abac7f71085b86e9071bece170f8c92a387aebdcc89f8915c33739609a73cacd5559b3a56fd59082ed311bab49f42ea0ba6be5e253453db0fc8b5b6aab458163b8a013121fd5c554dcc51d81c57e60f59d9d7f8f4d45fab24365da039ed8fb5401cfaff0c8aae2191ae8bd742351d11034ff0f0c32fb0586810
所以我们发现有用的数据为q,dp,dq,inv(q,p)，显然此时我们连n都没有，但是我们有dq，我们知道它满足

​

如果我们的​，则此时得到的解​就等于m。最终exp如下

from Crypto.Util.number import *

q = 0x00befff9907f75bb7ad561131b5c76ae137bd67ae0e32b90f92b997b044277cab3dfeb84f255138127e1a4e53751a68db743a00ed8acc58f33107fe35db6b4813bc048db48bd530bcb35fba434dbb70e27d78aede2de0d4745df35a245417b8c74a31a7b55a77db45ebd6ed1dc4b3dcaa435a79dbf7240d96775372e64b58b0803
dq = 0x1c1005fdea0c454075eb6e603dc49e2cf4abfd9fdf20be8b2d91be5650e1c2e18ccbd0dbbe0e4092b87f7ec212f812a8538247cc240e5eccd4e6c564367cece3f78b7cd482249a7dffef7a1fde0c56431a532a4283f7957a39a26ab61c39e7d81742c3ce40eea23aad40840b06ef0c3ff6362b623e8a32a715bcc6cf3b31333b
c = 2329206064672111950904450292941421573350591294207157652026787098178545948258554492347649016030892000747909819064473414536692222493030122267884839986067073054508582403564557167583565364976046083954888777809177108315052118912603290095925912298584322873410379937455462434313487981715516761071523410121549134193124709612876311518391130974466069686830456036397449773159386026998482557500868323733155606973727191287617806211911722356975478414165867941665666556476756617951672736466672410799762479373101996896644454778482896784598378016390592459460753042458284030795009957030383305268628413551730442224404807955926606496353

m = pow(c, dq, q)

print(long_to_bytes(m))
所以当得到破损的证书后，我们也能够通过证书格式得到其中的有效信息，再加上其他攻击方法便可以对消息进行解密，当然这里我们得到的是后半截所以可以直接知道每个位置数据代表什么，如果是给出中间部分的证书，此时我们则需要通过逐一分析来进行检验，例如如果数是一个素数，则可能是素因子，如果相邻两个数差的非常大，则可能是e和d，最后我们总能找到有效信息。

流密码LCG
例题1：循环移位
from secret import flag

ror = lambda x, l, b: (x >> l) | ((x & ((1<<l)-1)) << (b-l))
#ror 函数：这是一个循环右移（Rotate Right）函数。
#参数：
#x：要位移的整数。
#l：位移的位数。
#b：整数的总位数。
#将 x 向右循环移动 l 位。
#例如，ror(0b1101, 1, 4) 的结果是 0b1110。
N = 1
for base in [2, 3, 7]:
    N *= pow(base, random.randint(123, 456))
#即：2^a * 3^b * 7^c,范围在[123, 456]，可以看出N是2的倍数.
e = random.randint(271828, 314159)

m = int.from_bytes(flag, byteorder='big')
#使用大端序（byteorder='big'）将 flag 转换为整数。
assert m.bit_length() < N.bit_length()

for i in range(m.bit_length()):
    print(pow(ror(m, i, m.bit_length()), e, N))
分析
我们知道在二进制中，一个数是偶数的话那么它的二进制值无论多少次方的最后一位一定是0，如果是奇数，那么其二进制值无论多少次方最后一位一定是1。

我们现在知道N是偶数，那么在二进制下​，m是偶数，那么其结果c的最后一位也是偶数，m是奇数，那么其结果c的最后一位也是奇数。

所以我们取chall每个数的二进制最后一位拼起来，因为打印的时候是从m的低位开始打的，所以将二进制倒序才是真正的m。

for i in range(m.bit_length()):
    print(pow(ror(m, i, m.bit_length()), e, N))
#这段代码其实就是将m进行循环右移0--（m-1）位，后面的RSA加密作用不大。
EXP
from Cryptodome.Util.number import *
import random

f = open('C:/Users/liyunfei/Desktop/chall.txt', 'r').readlines()
s=''
for i in f:
    #print(i)
    #print(bin(int(i.strip()))[-1])
    s += bin(int(i.strip()))[-1]

print(long_to_bytes(int(s[::-1], 2)))
OPT（一次一密本）
原理
一次一密（OTP）加密是信息理论上最安全的加密方式，

其特点是：
密钥与明文等长。
密钥完全随机，且仅能使用一次。
加密过程使用按位异或（XOR）运算：C=M⊕K
其中，( C ) 为密文，( M ) 为明文，( K ) 为密钥。

特性	OTP（一次一密）
密钥长度	与明文等长
密钥随机性	完全随机且每次不同
密钥使用次数	每次加密操作只能使用一次
加密方式	按位异或（XOR）
安全性	信息理论上绝对安全
应用场景	高度保密通信（如军事、政府）
密钥管理	极其困难，尤其是在大规模通信时
例题1
出题人:6c73d5240a948c86981bc294814d
某不知名收件人：收到消息attack at dawn
出题人:xxxxxxxxxxxxxxxxxxxxxxxxxxxx
某不知名收件人：收到消息Monday or Thur
已知出题人和收件人手中的密钥相同，请解出出题人第二次发送的密文呢（16进制，字母小写，解得的结果记得要加上LitCTF{}哦。）
分析
这道题实际上是对一个密钥重复使用了两次，故产生漏洞，而根据异或的原理我们可以知道如何轻松获取KEY。

EXP
from operator import xor
m1='6c73d5240a948c86981bc294814d'
c1='61747461636b206174206461776e'
c2='4d6f6e646179206f722054687572'
m2=''
key=xor(m1,c1)
m2=xor(key,c2)
print(m2)
LCG对称密码/迭代 
题目1
from Crypto.Util.number import *

flag = b'NSSCTF{******}'

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed  # 初始种子
        self.a = a  # 乘数
        self.b = b  # 增量
        self.m = m  # 模数

    def generate(self):
        self.seed = (self.a * self.seed + self.b) % self.m
        return self.seed


lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))

for i in range(getPrime(16)):
    lcg.generate()

print(f'a = {lcg.a}')
print(f'b = {lcg.b}')
print(f'm = {lcg.m}')
print(lcg.generate())


'''
a = 113439939100914101419354202285461590291215238896870692949311811932229780896397
b = 72690056717043801599061138120661051737492950240498432137862769084012701248181
m = 72097313349570386649549374079845053721904511050364850556329251464748004927777
9772191239287471628073298955242262680551177666345371468122081567252276480156
'''
分析
经典LCG算法，我们知道LCG加密是一种对称密码，我们只需要把加密方式逆过来不断循环，即可找到flag

这道题目信息全都给了，所以我们直接逆着来就OK了.

EXP
from Cryptodome.Util.number import *

a = 113439939100914101419354202285461590291215238896870692949311811932229780896397
b = 72690056717043801599061138120661051737492950240498432137862769084012701248181
m = 72097313349570386649549374079845053721904511050364850556329251464748004927777
x = 9772191239287471628073298955242262680551177666345371468122081567252276480156

inva = inverse(a, m)#求a的逆元

for i in range(2**16):
    x = (x-b)*inva % m

    flag = long_to_bytes(x)
    if b'NSSCTF' in flag:
        print(flag)
题目2
from Crypto.Util.number import *

flag = b'NSSCTF{******}'

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed  # 初始种子
        self.a = a  # 乘数
        self.b = b  # 增量
        self.m = m  # 模数

    def generate(self):
        self.seed = (self.a * self.seed + self.b) % self.m
        return self.seed


lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))

for i in range(getPrime(16)):
    lcg.generate()

print(f'a = {lcg.a}')
print(f'm = {lcg.m}')
print(lcg.generate())
print(lcg.generate())


a = 83968440254358975953360088805517488739689448515913931281582194839594954862517
m = 77161425490597512806099499399561161959645895427463118872087051902811605680317
43959768681328408257423567932475057408934775157371406900460140947365416240650
8052043336238864355872102889254781281466728072798160448260752595038552944808
分析
这道题目给出了a和m，缺少b，但同时给出了两组加密结果，我们知道在加密过程中循环轮数取决于函数getprime(16)，所以我们可以认为第二组加密结果是对第一组结果加密循环的延续。由此我们可以构造数学式：

可以得出

得出b之后按照第一题的解密思路即可.

EXP
b=(x2-x1*a)%m
print("b=",b)
a1=invert(a,m)

for i in range(2**16):
    x1=(x1-b)*a1%m
    flag=long_to_bytes(x1)
    if b'NSSCTF'in flag:
        print(flag)
题目3
from Crypto.Util.number import *

flag = b'NSSCTF{******}'

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed  # 初始种子
        self.a = a  # 乘数
        self.b = b  # 增量
        self.m = m  # 模数

    def generate(self):
        self.seed = (self.a * self.seed + self.b) % self.m
        return self.seed


lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))

for i in range(getPrime(16)):
    lcg.generate()

print(f'm = {lcg.m}')
print(lcg.generate())
print(lcg.generate())
print(lcg.generate())


m = 96343920769213509183566159649645883498232615147408833719260458991750774595569
10252710164251491500439276567353270040858009893278574805365710282130751735178     x1=(xa+b)%m
45921408119394697679791444870712342819994277665465694974769614615154688489325     x2=(x1a+b)%m
27580830484789044454303424960338587428190874764114011948712258959481449527087     x3=(x2a+b)%m
'''
分析
题目给了三组LCG结果，但未给出a,b我们先求出a,b在解决.

我们可以构造三组等式：(1式的x即可视为flag)

由3式减去2式得：

我们看到这时已经消去了b，也很容易求出a，剩下的参照第二题解即可。

EXP
from Cryptodome.Util.number import long_to_bytes
from gmpy2 import invert
m = 96343920769213509183566159649645883498232615147408833719260458991750774595569
x1 = 10252710164251491500439276567353270040858009893278574805365710282130751735178  # x1=(xa+b)%m
x2 = 45921408119394697679791444870712342819994277665465694974769614615154688489325  # x2=(x1a+b)%m
x3 = 27580830484789044454303424960338587428190874764114011948712258959481449527087  # x3=(x2a+b)%m     x3-x2=a(x2-x1)%m
x=invert(x2-x1,m)
a=((x3-x2)*x)%m
#print("a=",a)
b=(x2-x1*a)%m
a1=invert(a,m)
for i in range(2**16):
    x1=((x1-b)*a1)%m
    flag=long_to_bytes(x1)
    if b'NSSCTF'in flag:
        print(flag)
题目4
from Crypto.Util.number import *

flag = b'NSSCTF{******}'

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed  # 初始种子
        self.a = a  # 乘数
        self.b = b  # 增量
        self.m = m  # 模数

    def generate(self):
        self.seed = (self.a * self.seed + self.b) % self.m
        return self.seed


lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))

for i in range(getPrime(16)):
    lcg.generate()

print(lcg.generate())
print(lcg.generate())
print(lcg.generate())
print(lcg.generate())
print(lcg.generate())


47513456973995038401745402734715062697203139056061145149400619356555247755807
57250853157569177664354712595458385047274531304709190064872568447414717938749
30083421760501477670128918578491346192479634327952674530130693136467154794135
38739029019071698539301566649413274114468266283936163804522278316663267625091
42506270962409723585330663340839465445484970240895653869393419413017237427900
分析
我们看到a,b,m都未知，只给出了5组LCG结果.

这次给了我们五组输出，其他什么参数也没有给，需要我们恢复初始种子，我们还是先列出它们的关系：

此时你会发现现在模数也没有给我们，我们首先肯定需要考虑恢复模数，而恢复模数则和之前几道题不同了，我们回顾一下RSA中的思路，在RSA中我们经常利用构造另一个数，然后和模数做GCD得到其中的因子，那么这里我们也可以考虑同样的实现，我们没有办法通过解方程直接得到模数（因为模数并不是方程的一部分，你当然可以展开成​，但是这样又会引入新的未知数k1），所以我们可以考虑得到模数的某个整除关系，例如假设我们构造的​满足​，那么我们则可以在​之间求解最大公因数得到​。

这里我们一个很普遍的思路是先转化为同级运算符，即不要出现对数、加减、乘除、指数我们可以看成不同的运算等级，只保留一种等级，因为在同一种等级中我们可以更加方便的转换，这里既然是构造​的倍数，则我么考虑只保留乘除运算，则令​，则：

当然值得注意的是，上述所有式子都是在模m意义下才成立，此时我们可以发现我们通过构造邻项相减，把增量b给消掉了，并且得到的新数列​还是一个等比数列，那么根据等比数列的性质我们有：

我们将取模添加到式子中并移项则有：

显然我们得到了​，得到了这个整除关系，我们便可以求解m的倍数的公因数从而得到m。

还有值得注意的点便是代码中的m //= 2，为什么要进行除2操作呢，这是因为虽然我们得到了mm的倍数，通过求解它们之间的GCD确实能够得到mm，但当数据不够多的情况下，例如本题泄露的五组输出恰好只够进行两次GCD，则可能它们的最大公因数是kmkm，也就是说还带有其他因子，我们必须手动清除掉这些因子，因子不是所有的情况下都是2，你可以通过遍历一些小素数来清除它们，只是在本题的输出中，多余的因子刚好是2。

上题WP中我们还提出了一个问题，最少需要几组输出，实际上通过刚才我们的描述其实只需要4组输出就能够得到mm的一个倍数，但是它太大了，里面包含了大量其他素因子，所以我们不能100%将其找出来正确的mm，而对于两组或者更多组倍数进行GCD后，一般就可以清除掉其他绝大部分的素因子，只剩下一些小素因子手动清除一下即可。

EXP
from Crypto.Util.number import *
x1 = 47513456973995038401745402734715062697203139056061145149400619356555247755807
x2 = 57250853157569177664354712595458385047274531304709190064872568447414717938749
x3 = 30083421760501477670128918578491346192479634327952674530130693136467154794135
x4 = 38739029019071698539301566649413274114468266283936163804522278316663267625091
x5 = 42506270962409723585330663340839465445484970240895653869393419413017237427900

x = [x1, x2, x3, x4, x5]
t = []

#求t
for i in range(1, len(x)):
    t.append(x[i] - x[i-1])

#求最大公约数m
m = 0
for i in range(1, len(t)-1):
    m = GCD(t[i+1]*t[i-1] - t[i]*t[i], m)

m //= 2  # 注意这里，这里不一定是2可能是一些别的素数，这道题正好为2
print(m)
assert isPrime(m)
a = (x3 - x2) * inverse(x2 - x1, m)
b = (x2 - a*x1) % m

inva = inverse(a, m)

for i in range(2**16):
    x1 = (x1-b)*inva % m

    flag = long_to_bytes(x1)
    if b'NSSCTF' in flag:
        print(flag)
题目5
from Crypto.Util.number import *

flag = b'NSSCTF{******}'

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed  # 初始种子
        self.a = a  # 乘数
        self.b = b  # 增量
        self.m = m  # 模数

    def generate(self):
        self.seed = self.a * (self.seed - self.b) % self.m
        return self.seed


lcg = LCG(bytes_to_long(flag), getPrime(256), getPrime(256), getPrime(256))

for i in range(getPrime(16)):
    lcg.generate()

print(lcg.generate())
print(lcg.generate())
print(lcg.generate())
print(lcg.generate())
print(lcg.generate())


57648351648792284446777383544515312078150027665462203747924668509833442797796
90378879763416486117626477831653213918315023665514305359005153448529276829825
21826576702665114807208181233864324586557058567478767825970403161758214940301
47594460970742467761038407996122637655856234121180714918606854365482948918701
11871076497267630136796123094001159466754095580273018347962555675375123133730
分析
本题还是和上题一样恢复参数，但是我们观察发现这里的LCG递推方程为：

如果我们能把这题转化为LCG标准形式，我们就可以把本题转化为上题进行恢复参数，实际上上式可以转变为：

此时我们将​看作一个整体，你会发现其实就变成了我们之前的标准形式，接下来我们就可以转化为P5进行求解模数，最终得到初始种子。

EXP
from Crypto.Util.number import *
x1 = 57648351648792284446777383544515312078150027665462203747924668509833442797796
x2 = 90378879763416486117626477831653213918315023665514305359005153448529276829825
x3 = 21826576702665114807208181233864324586557058567478767825970403161758214940301
x4 = 47594460970742467761038407996122637655856234121180714918606854365482948918701
x5 = 11871076497267630136796123094001159466754095580273018347962555675375123133730

x = [x1, x2, x3, x4, x5]
t = []

for i in range(1, len(x)):
    t.append(x[i] - x[i-1])

m = 0
for i in range(1, len(t)-1):
    m = GCD(t[i+1]*t[i-1] - t[i]*t[i], m)

for p in sieve_base:
    while m % p == 0: m //= p
assert isPrime(m)
a = (x3 - x2) * inverse(x2 - x1, m)
b = (x2 - a*x1) % m

inva = inverse(a, m)

for i in range(2**16):
    x1 = (x1-b)*inva % m

    flag = long_to_bytes(x1)
    if b'NSSCTF' in flag:
        print(flag)
所以本题代码和P5完全一致，同时我们增加了排除公因数中额外因子的代码：

for p in sieve_base:
while m % p == 0: m //= p
对于LCG来说，只要符合线性同余，我们都可以变为标准型​的形式，你只需要变成标准型求解即可，因为这里我们只需要恢复原始种子，所以代码都不需要改变，若是这里需要我们求bb的话，则原始的​，其中​便是我们上述变成标准型之后的​。

题目6
from Crypto.Util.number import *

flag = b'NSSCTF{******}'

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed  # 初始种子
        self.a = a  # 乘数
        self.b = b  # 增量
        self.m = m  # 模数

    def generate(self):
        self.seed = (self.a * self.seed + self.b) % self.m
        self.seed = (self.a * self.seed + self.b) % self.m
        return self.seed


lcg = LCG(bytes_to_long(flag), getPrime(255), getPrime(255), getPrime(256))

for i in range(getPrime(16)):
    lcg.generate()

print(lcg.generate())
print(lcg.generate())
print(lcg.generate())
print(lcg.generate())
print(lcg.generate())


25445927935559969212648839062255651208014967526951331344342413906051118248013
81572970970116732975667604095930675262596098540738447440566868976253289440293
6956793925625110803779114150160476498676179542815207353218944386232051429289
88042506866508011592456777776490262927213783361334741921985316105965255450508
5652832125321707726481846809536180176877263519327268361130605456255558285092
分析（没看懂）
Crypto系列——LCG | NSSCTF

EXP
(此题用第5题的EXP也可)

from Cryptodome.Util.number import *

x1 = 25445927935559969212648839062255651208014967526951331344342413906051118248013
x3 = 81572970970116732975667604095930675262596098540738447440566868976253289440293
x5 = 6956793925625110803779114150160476498676179542815207353218944386232051429289
x7 = 88042506866508011592456777776490262927213783361334741921985316105965255450508
x9 = 5652832125321707726481846809536180176877263519327268361130605456255558285092

x = [x1, x3, x5, x7, x9]
t = []

def legendre(a, p):
    return pow(a, (p - 1) // 2, p)
def tonelli(n, p):
    assert legendre(n, p) == 1, "not a square (mod p)"
    q = p - 1
    s = 0
    while q % 2 == 0:
        q //= 2
        s += 1
    if s == 1:
        return pow(n, (p + 1) // 4, p)
    for z in range(2, p):
        if p - 1 == legendre(z, p):
            break
    c = pow(z, q, p)
    r = pow(n, (q + 1) // 2, p)
    t = pow(n, q, p)
    m = s
    t2 = 0
    while (t - 1) % p != 0:
        t2 = (t * t) % p
        for i in range(1, m):
            if (t2 - 1) % p == 0:
                break
            t2 = (t2 * t2) % p
        b = pow(c, 1 << (m - i - 1), p)
        r = (r * b) % p
        c = (b * b) % p
        t = (t * c) % p
        m = i
    return r

for i in range(1, len(x)):
    t.append(x[i] - x[i-1])

m = 0
for i in range(1, len(t)-1):
    m = GCD(t[i+1]*t[i-1] - t[i]*t[i], m)

for p in sieve_base:
    while m % p == 0: m //= p
assert isPrime(m)
a = (x7 - x5) * inverse(x5 - x3, m) % m
a = tonelli(a%m, m)
b = (x3 - a*a*x1)*inverse(a+1, m) % m

inva = inverse(a, m)

for i in range(2**17):
    x1 = (x1-b)*inva % m

    flag = long_to_bytes(x1)
    if b'NSSCTF' in flag:
        print(flag)
题目7
from Crypto.Util.number import *

flag = b'NSSCTF{******}'

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed  # 初始种子
        self.a = a  # 乘数
        self.b = b  # 增量
        self.m = m  # 模数
        self.flag = False

    def generate(self):
        self.seed = (self.a * self.seed + self.b) % self.m
        res = self.seed

        if self.flag:
            self.seed = (self.a * self.seed + self.b) % self.m
            res ^= self.seed
            self.flag = False
        else:
            self.flag = True

        return res


lcg = LCG(getPrime(255), getPrime(255), getPrime(255), getPrime(256))

c = []

for i in flag:
    c.append(lcg.generate() ^ i)
print(c)
print(lcg.m)

[81584814741951826167713561762884044749048079878360104563221563015822544621540, 93774760261034631093081035207221372813019987098149361262601038324099824472054, 53112192781012087485274553474853632087816801546442125719635637229018761488068, 2924887129824568911354849666428337550752599339091846591306018510128364566374, 21489990371365635422785076328770373828885757507356970523345619197796699087823, 45879660646340087141208055037066375147112612144063751742878749538204227647223, 68489396663324980653667192480812664021869948970659960358303067756448465248962, 106889067933287464289046552070470006133240972888450185109202715048686699770828, 45880917337468560299586085034530981103079386360947740224437019696010705713504, 44264427891073836008413354425617411470794292209211384045023099147459280509219, 24230854692675475429275139738088072605035575993176371386080324243155457150129, 8324829808769566925849341513418987623474730556806514831163330951245904438885, 13973295373237298763688022823721063100979589794182834257587248359004917441233, 40946970689568765965479545541224654394849339592509835480100207197078299041359, 41840081504865349688826985386071119017476641799355114557538740232932639805078, 20173660813342267765549269084351072606374939924324411963087931476551280937102, 33606081253499380984005089985487426429461377845068803275630456930310532986647, 21863306888078087145487841917128593612722746009415567682629070350617384468865, 37705360427047642228657480542621387728505622206223322417535025830856191360682, 76394681592345473096361076203950244792678301231422301484911180053914754005660, 14445142875816535158206035170377032683179793846233008705044594781585126076422, 76399214426521271006629720299525001174165796205749509219669267796220760134668, 48963361037454561463427264514426072688886329876142403917863459848710167638299, 109755604120091903232536460005725058368768352544336587465785487037503069265532, 17629553207776828354200662140051287891918116980656890326744743673721478286748, 64351418114534266602263136861745778649986755405007304878601484056610206992412, 1747194514208114750564282571686979051305610098513675807068241335365552682058, 56440847349017714736424452565973705850353327138481306660630101075958036251012, 18938739898623474715723504727391335128374527047687506411988651179137118171744, 34278503747994897302186149009581131251220326132850950491516438997495387264420, 72969803022057770880126275760677059716202452292880774447222892410118789218019, 19417982285559688444222393534193336662626856272322246741671289881637819984704, 38932105919523769034923643449893605497694818272441279941830436762371582468828, 24487288126435161549395310046903919643631441162265499768468716075450020699817, 77947965534521507739806158990664078948320830860457514407123697810624486050992, 93592878110302845089477843503011449712615737528118407775734483884221947105328, 32343810136347248011294525044239112669043703094468690713290095304517010526441, 4266795492711034746844951873371293640112776112917444572367841878085540177393, 6300133545866819909237032926248008487617976145506739614351429803502021968529, 26352416759406189276920683254378055106857652225447447091766229194386845355426, 68287091881944595556206987513213507798534966894295689804598980654045436174566, 62270136231836751497834210500471298464586030814010376146250902975780514165809, 85625702418726025519718781583849588251758820858251438931591819496539009280818, 113920561374108800569700231300461418282579193845321015637813953548023720736907]
85862744900431564568351211721208164015422102334384451423751646954931287835189
分析
本题便是大部分LCG题目出题方式，它不会直接给你一堆加密值让你恢复参数或种子，而是在题目的某个部分使用了LCG加密，而我们要从得到的数据中先找到LCG的原始输出，再利用恢复参数等方式进行预测随机数。

这里是输出值和flag进行加密，但是我们知道flag的前几位是NSSCTF{（题目中给出），这也就等于得到了前7位的明文值，而这几位的加密情况为：

显然我们发现通过这样的方式可以得到1,4,7,10位的LCG原始输出。同理列出式子:

二式减一式得：

即：

d = inverse(3, m-1)
a = pow((x7 - x4)*inverse(x4 - x1, m), d, m)
EXP
from Crypto.Util.number import *

c = [81584814741951826167713561762884044749048079878360104563221563015822544621540, 93774760261034631093081035207221372813019987098149361262601038324099824472054, 53112192781012087485274553474853632087816801546442125719635637229018761488068, 2924887129824568911354849666428337550752599339091846591306018510128364566374, 21489990371365635422785076328770373828885757507356970523345619197796699087823, 45879660646340087141208055037066375147112612144063751742878749538204227647223, 68489396663324980653667192480812664021869948970659960358303067756448465248962, 106889067933287464289046552070470006133240972888450185109202715048686699770828, 45880917337468560299586085034530981103079386360947740224437019696010705713504, 44264427891073836008413354425617411470794292209211384045023099147459280509219, 24230854692675475429275139738088072605035575993176371386080324243155457150129, 8324829808769566925849341513418987623474730556806514831163330951245904438885, 13973295373237298763688022823721063100979589794182834257587248359004917441233, 40946970689568765965479545541224654394849339592509835480100207197078299041359, 41840081504865349688826985386071119017476641799355114557538740232932639805078, 20173660813342267765549269084351072606374939924324411963087931476551280937102, 33606081253499380984005089985487426429461377845068803275630456930310532986647, 21863306888078087145487841917128593612722746009415567682629070350617384468865, 37705360427047642228657480542621387728505622206223322417535025830856191360682, 76394681592345473096361076203950244792678301231422301484911180053914754005660, 14445142875816535158206035170377032683179793846233008705044594781585126076422, 76399214426521271006629720299525001174165796205749509219669267796220760134668, 48963361037454561463427264514426072688886329876142403917863459848710167638299, 109755604120091903232536460005725058368768352544336587465785487037503069265532, 17629553207776828354200662140051287891918116980656890326744743673721478286748, 64351418114534266602263136861745778649986755405007304878601484056610206992412, 1747194514208114750564282571686979051305610098513675807068241335365552682058, 56440847349017714736424452565973705850353327138481306660630101075958036251012, 18938739898623474715723504727391335128374527047687506411988651179137118171744, 34278503747994897302186149009581131251220326132850950491516438997495387264420, 72969803022057770880126275760677059716202452292880774447222892410118789218019, 19417982285559688444222393534193336662626856272322246741671289881637819984704, 38932105919523769034923643449893605497694818272441279941830436762371582468828, 24487288126435161549395310046903919643631441162265499768468716075450020699817, 77947965534521507739806158990664078948320830860457514407123697810624486050992, 93592878110302845089477843503011449712615737528118407775734483884221947105328, 32343810136347248011294525044239112669043703094468690713290095304517010526441, 4266795492711034746844951873371293640112776112917444572367841878085540177393, 6300133545866819909237032926248008487617976145506739614351429803502021968529, 26352416759406189276920683254378055106857652225447447091766229194386845355426, 68287091881944595556206987513213507798534966894295689804598980654045436174566, 62270136231836751497834210500471298464586030814010376146250902975780514165809, 85625702418726025519718781583849588251758820858251438931591819496539009280818, 113920561374108800569700231300461418282579193845321015637813953548023720736907]
m = 85862744900431564568351211721208164015422102334384451423751646954931287835189

class LCG:
    def __init__(self, seed, a, b, m):
        self.seed = seed  # 初始种子
        self.a = a  # 乘数
        self.b = b  # 增量
        self.m = m  # 模数
        self.flag = False

    def generate(self):
        self.seed = (self.a * self.seed + self.b) % self.m
        res = self.seed

        if self.flag:
            self.seed = (self.a * self.seed + self.b) % self.m
            res ^= self.seed
            self.flag = False
        else:
            self.flag = True

        return res

x1 = c[0]^ord('N')
x4 = c[2]^ord('S')
x7 = c[4]^ord('T')

d = inverse(3, m-1)
a = pow((x7 - x4)*inverse(x4 - x1, m), d, m)

b = (x4 - a*a*a*x1)*inverse(a*a+a+1, m) % m
x0 = (x1-b)*inverse(a, m) % m
lcg = LCG(x0, a, b, m)
for i in c:
    print(chr(lcg.generate()^i))
格密码
定义：
格是一个系数为整数的向量空间，完整定义：m维欧式空间​的​个线性无关向量​的所有整系数的线性组合。（注：完整定义先初学可以先抛开）

：
SVP问题和CVP问题
SVP
最短向量问题
在格L中找到一个最短非零向量​，满足
且
最
小
​.
最短向量显然可能不止一个，例如在第一节的示例：

在格L中​都是最短向量，所以SVP只要求我们找到其中任意一个即可.

CVP
最近向量问题
给定一个不在格L中的向量​，找到一个向量​，满足​最小.

 

Hermite定理
最短向量到底多长？

Hermite定理：对于n维的格L，都包含一个非零向量​满足：

其中​代表计算L的行列式。于是我们知道了一个关于最短向量的上界。实际上对于这里还有衍生Hermite常熟​，其中​.

格基规约
​是格L的一组基.
显然一个格可以有很多基，而在密码学中我们则是要找到一组特殊的基.

正交基
对于一组基​满足
（
基
互
相
垂
直
）
，
​，则称其为一组正交基.

有
：
格基规约
上面我们在Hermite定理中讨论了最短向量的上界，对于一组基来说也有定理：

同时还有Hadamard不等式给出了下界：

此时我们引入Hadamard比率，定义为：

当​越接近1，则这组向量越接近正交基。

那么对于格基规约来说，我们希望找到越接近正交基的基向量越好，这里我们可以通过LLL算法来找到这组基。

这组基和SVP有什么联系？

假设我们找到了一组正交基或者说最接近正交基的基。

对于最短向量vv来说，它和这组基之间的关系有两种可能

假设vv是这个基中的某个向量，显然此时该向量在其他向量上的投影长度都为0（因为两两垂直），符合SVP的要求。

假设vv不是基中的向量，显然我们发现此时该向量一定可以通过在其他基向量方向的投影来得到一个更短的向量。

所以SVP的解一定是最接近正交基的基向量。

例题1（NTRU密码）
from Crypto.Util.number import *

p = getPrime(1024)

f = getPrime(400)
g = getPrime(512)
r = getPrime(400)

h = inverse(f, p) * g % p

m = b'******'
m = bytes_to_long(m)

c = (r*h + m) % p

print(f'p = {p}')
print(f'h = {h}')
print(f'c = {c}')


p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031
h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065
c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483
分析
简单讲解什么是NTRU密码：

参数：
模数：p
私钥：​
公钥：​
临时密钥：r
加密：​
解密：​在乘上
在
模
下
​即可得到m

看到此题典型的NTRU密码，考虑构造格。

有关系式：​

即：​

有​

我们构造格L：

由(1)(2)两式，矩阵相乘有​([f,g]是L的一组基（可能最短）)

故我们根据LLL算法得到f,g.

#sagemath
L=Matrix(ZZ,[[1,h],
             [0,p]])
f,g=L.LLL()[0]
EXP
#sagemath
from Crypto.Util.number import *
p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031
h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065
c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483

L = Matrix(ZZ, [[1, h],
                [0, p]])

f, g = L.LLL()[0]

m = (f*c) % p % g * inverse_mod(f, g) % g

print(long_to_bytes(m))
例题2（背包密码）
from Crypto.Util.number import *
import random
from gmpy2 import *

flag = bytes_to_long(b'******')
flag = bin(flag)[2:]
n = len(flag)

a = [random.randint(1, 4**n)]
s = a[0]
for i in range(1, n):
    a.append(random.randint(s+1, 4**(n+i)))
    s += a[i]#超递增序列

m = random.randint(a[-1] + 1, 2*a[-1])
w = random.randint(1, m)

assert gcd(w, m) == 1
b = [w*i % m for i in a]#公钥b

c = 0
for i in range(len(b)):
    c = (c + b[i]*int(flag[i]))
with open('output', 'w+') as f:
    print(f'b = {b}', file=f)
    print(f'c = {c}', file=f)
#此题由于b太大太长，影响代码阅读，故以公式形式放在下面
b=[...]
c = 77376628019376673311531372348992445286793908614402191070546463231960965338625068420461932939579722257775290977616105002692887174722021983488949847381336050095777423958441982516041992872955033649666952328953257159369139125539634644867633316155815015993888621265583027756314957956170658163788675253859998755953779446426429307769521896999789665107673
分析
构造格：

L=Matrix(ZZ,n+1,n+1)#n+1行n+1列矩阵
for i in range(n):
    L[i][i]=1
    L[i][-1]=b[i]
    L[-1][-1]=-c
EXP
from Crypto.Util.number import *

b = [...]
c = ...

n = len(b)
print(n)
L = Matrix(ZZ, n+1, n+1)

for i in range(n):
    L[i,i] = 1
    L[i,-1] = b[i]
L[-1,-1] = -c

res = L.LLL()

for i in range(n + 1):
    M = res.row(i).list()#在上我们构造的格中，结果不一定在第一行，即第一行不一定是最短的，故在此进行遍历每一行，并转化为列表。
    flag = True
    for m in M:
        if m != 0 and m != 1:
            flag = False
            break
    if flag:
        print(i, M)

# flag =  [1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1]

# flag = int(''.join(list(map(str, flag))), 2)

# print(long_to_bytes(flag))
例题3
from Crypto.Util.number import *
import random

flag = b'******'
m = bytes_to_long(flag)

a = getPrime(1024)
b = getPrime(1536)

p = getPrime(512)
q = getPrime(512)
r = random.randint(2**14, 2**15)
assert ((p-r) * a + q) % b < 50

c = pow(m, 65537, p*q)

print(f'c = {c}')
print(f'a = {a}')
print(f'b = {b}')


c = 78168998533427639204842155877581577797354503479929547596593341570371249960925614073689003464816147666662937166442652068942931518685068382940712171137636333670133426565340852055387100597883633466292241406019919037053324433086548680586265243208526469135810446004349904985765547633536396188822210185259239807712
a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587
b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609
分析
我们看到有断言：

assert ((p-r) * a + q) % b < 50
即：​，令​

即：​

其中我们看到r和x的范围很小，故在爆破的情况下我们可以将r和x认为已知。

考虑等式​，其中a,b,r,x已知，需要求得：
和
​

构造格L：

满足​

且：​

EXP
#sagemath
from Crypto.Util.number import *
from tqdm import tqdm

c = ...
a = ...
b = ...

L = Matrix(ZZ, [[1, a],
                [0, b]])

p, q = L.LLL()[0]
p, q = abs(p), abs(q)#求绝对值

for r in tqdm(range(2**14, 2**15)):
    for h in range(50):
        pp = p+r
        qq = q+h#在上面对q进行了求绝对值，即|x-q|=q-x,故此处qq如此求得.
        phi = (pp-1)*(qq-1)
        if gcd(phi, 65537) != 1:
            continue
        m = power_mod(c, inverse_mod(65537, phi), pp*qq)
        #在sagemath中原本的pwn和invert修改为此处power_mod，inverse_mod
        if b'NSSCTF' in long_to_bytes(m):
            print(long_to_bytes(m))
            exit(0)
例题4
题目
from Crypto.Util.number import *
from gmpy2 import *

flag = b'******'
flag = bytes_to_long(flag)

p = getPrime(1024)
r = getPrime(175)
a = inverse(r, p)
a = (a*flag) % p

print(f'a = {a}')
print(f'p = {p}')

a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247
p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591
分析
我们看到给出等式​，其中a和p已知。

进行简单变换：​(注：这里的k不同于上式的k，这里的k是乘以r之后的)

我们在此构造格L：

有：​

且​

这里为什么要乘上​：

我们知道flag一般为一个UUID的格式即一般为350位，而此时我们的结果​，为了平衡结果中r和flag的大小，即为了使得最短向量相对于上界的比率非常非常小甚至达到最小，所以需要平衡。

这里v的近似值可以粗略表示为​即二者是个相加的关系，而v的上界可以粗略表示为​是个相乘的关系，此时将a或b变大，对相乘影响更大，即将上界变的更大，从而使得比率变小。

#sagemath
from Crypto.Util.number import *
a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247
p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591
L=Matrix(ZZ,[[2^175,a],
             [0,p]])
v=L.LLL()[0]
print(long_to_bytes(abs(v[1])))
例题5
题目
from Crypto.Util.number import *
from gmpy2 import *

flag = b'******'
m = bytes_to_long(flag)

assert m.bit_length() == 351
p = getPrime(1024)
b = getPrime(1024)
c = getPrime(400)

a = (b*m + c) % p

print(f'a = {a}')
print(f'b = {b}')
print(f'p = {p}')


a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592
b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663
p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783
分析
我们看到等式​，其中a，b，p已知。

进行简单换算：​

构造格L：

发现有​

且​

这里乘以​与例题4的作用一样。

#sagemath
from Crypto.Util.number import *
a = ...
b = ...
p = ...

L = Matrix(QQ, [[2^351, 0, a],
                [0, 1, -b],
                [0, 0, p]])

v = L.LLL()[0]
print(v)
print(long_to_bytes(abs(int(v[1]))))
例题6（论文：基于格的公共私有指数攻击）
题目
from Crypto.Util.number import *

flag = b'******'
flag = bytes_to_long(flag)
d = getPrime(400)




for i in range(4):
    p = getPrime(512)
    q = getPrime(512)
    n = p * q
    e = inverse(d, (p-1)*(q-1))
    c = pow(flag, e, n)
    print(f'e{i} =', e)
    print(f'n{i} =', n)
    print(f'c{i} =', c)

'''
e0 = 14663634286442041092028764808273515750847961898014201055608982250846018719684424125895815390624536073501623753618354026800118456911536861815261996929625814961086913500837475340797921236556312296934664701095834187857404704711288771338418177336783911864595983563560080719582434186801068157426993026446515265411
n0 = 104543450623548393448505960506840545298706691237630183178416927557780858213264769135818447427794932329909731890957245926915280713988801182894888947956846369966245947852409172099018409057129584780443712258590591272371802134906914886744538889099861890573943377480028655951935894660286388060056770675084677768397
c0 = 66400441793466385558399002350812383744096354576421495899465166492721568297592616443643465864544107914461044325088868615645524260480104397769130582397209585192620565774001015221725536884170662700337565613181799442382460047295553807602785067421981837709831158111951991854109179278733629950271657405211417740374
e1 = 62005504700456859456675572895620453845623573672275890584145949847469951381521709553504593023003977393014834639251022203398533914340078480147377747715528821418445514563871411209895815634752533151145061594791024551625615960423026244560340983481137777162236719939420428613005457949228517914830194749293637917667
n1 = 89410873947410184231222334229470195622685051370058935269198780539059522679122059486414591834635266301335656798768270022060656655274640699951736588085471509424575027153387518893978494158981314217195561629375189515702124478687925014362857206223379284909134299260355456357407022417434961226383007916607728238843
c1 = 75133250536426006056029454024900058936095761927174304108454764308417889983571094946046507426319589437822458959089546795698076608690695326741772662156830944126301658579142020817338297043884836598263468494533324693019866746045910394812656639124276516075062088756043949581789436307373276242558429450971458945061
e2 = 5365316217065391632204029784515519544882379449147835081003675696051077792179684123668298103660153980837519314114793091112163153158510344440829742753002176560016265852613076363394396640641504813912550948776926622696268531691467015580417575287779607009068332802842890478748171958455354463809356050553832863427
n2 = 53325942266099921615667538877103327425435396909592382386684073177331528393295928518724880712900970020425481561110366696624090824641115147978830715508666547064446891727446073538022824237798568413003419382767587742032676311751819789672319289920011033523044026418650515529084031754775286163358926609712626506433
c2 = 22289960513520782629306709529908652726794465066357062923684089176607114605563538085483920152508469429311012652149406853144200001391310165612163442404181970125704785325670969551080086517236489885046039799676581310781945432599048686184762485374030278657826206433571162451649808912276118945302558580745346371321
e3 = 57257245945110486431680573908783487217316546039634811903637650579658516537372808464426294780698320301497615457264001148504941375058983426920721566040576604013497311914160175024860226623138659970105781812246471618831032554729317463745699993647224910498474869868186318188994237457335796911524629938029123055027
n3 = 97233843381238063550322854422952777734101562842513647224354265328843953949189054347560960321126304504554067163501318212533606313039536188796999575130115659250566231010092273206623114900781284076452654791214088764465615154940874231056251107863895697778665275804663487113266180838319536762473697586368100928379
c3 = 56606672064789484727896188434430896229911224588055894584797861263107870392831242138537980507537270618683458635389444257040355313948352917061971042629958646854593628522401074068536976581232979947149230764268377747754284783531803366391759725774562719884482404532619163798580872386794273190532863916038929461465
'''
分析
论文参考如下：# https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf

主要步骤：image-20250523151448051

EXP
#sagemath
import libnum
from gmpy2 import isqrt

e0 = 14663634286442041092028764808273515750847961898014201055608982250846018719684424125895815390624536073501623753618354026800118456911536861815261996929625814961086913500837475340797921236556312296934664701095834187857404704711288771338418177336783911864595983563560080719582434186801068157426993026446515265411
n0 = 104543450623548393448505960506840545298706691237630183178416927557780858213264769135818447427794932329909731890957245926915280713988801182894888947956846369966245947852409172099018409057129584780443712258590591272371802134906914886744538889099861890573943377480028655951935894660286388060056770675084677768397
c0 = 66400441793466385558399002350812383744096354576421495899465166492721568297592616443643465864544107914461044325088868615645524260480104397769130582397209585192620565774001015221725536884170662700337565613181799442382460047295553807602785067421981837709831158111951991854109179278733629950271657405211417740374
e1 = 62005504700456859456675572895620453845623573672275890584145949847469951381521709553504593023003977393014834639251022203398533914340078480147377747715528821418445514563871411209895815634752533151145061594791024551625615960423026244560340983481137777162236719939420428613005457949228517914830194749293637917667
n1 = 89410873947410184231222334229470195622685051370058935269198780539059522679122059486414591834635266301335656798768270022060656655274640699951736588085471509424575027153387518893978494158981314217195561629375189515702124478687925014362857206223379284909134299260355456357407022417434961226383007916607728238843
c1 = 75133250536426006056029454024900058936095761927174304108454764308417889983571094946046507426319589437822458959089546795698076608690695326741772662156830944126301658579142020817338297043884836598263468494533324693019866746045910394812656639124276516075062088756043949581789436307373276242558429450971458945061
e2 = 5365316217065391632204029784515519544882379449147835081003675696051077792179684123668298103660153980837519314114793091112163153158510344440829742753002176560016265852613076363394396640641504813912550948776926622696268531691467015580417575287779607009068332802842890478748171958455354463809356050553832863427
n2 = 53325942266099921615667538877103327425435396909592382386684073177331528393295928518724880712900970020425481561110366696624090824641115147978830715508666547064446891727446073538022824237798568413003419382767587742032676311751819789672319289920011033523044026418650515529084031754775286163358926609712626506433
c2 = 22289960513520782629306709529908652726794465066357062923684089176607114605563538085483920152508469429311012652149406853144200001391310165612163442404181970125704785325670969551080086517236489885046039799676581310781945432599048686184762485374030278657826206433571162451649808912276118945302558580745346371321
e3 = 57257245945110486431680573908783487217316546039634811903637650579658516537372808464426294780698320301497615457264001148504941375058983426920721566040576604013497311914160175024860226623138659970105781812246471618831032554729317463745699993647224910498474869868186318188994237457335796911524629938029123055027
n3 = 97233843381238063550322854422952777734101562842513647224354265328843953949189054347560960321126304504554067163501318212533606313039536188796999575130115659250566231010092273206623114900781284076452654791214088764465615154940874231056251107863895697778665275804663487113266180838319536762473697586368100928379
c3 = 56606672064789484727896188434430896229911224588055894584797861263107870392831242138537980507537270618683458635389444257040355313948352917061971042629958646854593628522401074068536976581232979947149230764268377747754284783531803366391759725774562719884482404532619163798580872386794273190532863916038929461465
M=isqrt(n0)
L=matrix(ZZ,[[M,e0,e1,e2,e3],
             [0,-n0,0,0,0],
             [0,0,-n1,0,0],
             [0,0,0,-n2,0],
             [0,0,0,0,-n3]])
d=L.LLL()[0][0]//M
m = power_mod(c0,d,n0)
print(libnum.n2s(int(m)))
例题7（论文：拓展维纳攻击）
题目
from Crypto.Util.number import *

flag = b'******'
flag = bytes_to_long(flag)

p = getPrime(512)
q = getPrime(512)
n = p * q
c = pow(flag, 65537, n)
print(f'n =', n)
print(f'c =', c)
for i in range(2):
    d = getPrime(350)
    e = inverse(d, (p-1)*(q-1))
    print(f'e{i} =', e)


n = 110697784133988071803253124431092603234028687101567047811203431433689306543322837414808117411806181193598553341878079973980865551938790090419082150555675782822484149943421418447579383449269148197087985041351210982545320569973241390962326458234562044133505940521052500278777242988196544039226173227204865907343
c = 3281096209929505523196793672137624804022934270452947405454462490250571524417033484978613243658208567511735641542935158434165363547355697159503378251318054879687577130170122911449101189974762808655638497967674004219512386442280269940950792767174561412932638740423542930763914255112354969122157915514816022159
e0 = 28562806554366667733480283991307446762365777397933141571728113235368201162305126722188842319240464207580134816039095093401651171977877327756351539588974913736802534970867173212883308325913939353140276201705478124488858328502643345172188729914731042179091733244225184522680724392375975935305371163502863968963
e1 = 28572469216883232254074869113744730984165641173439644880182528671699871929340616919028955398474678696802739685594548793470261306125219888911330937557582939811068530294470712859439149735950996866732508004061234613146407591546995439312326450834903885979660916965052092661398640105827442036234500556755520316031
分析
参考论文：Extending Wiener’s Attack in the Presence of Many Decrypting Exponents（已收集：拓展维纳攻击.pdf）

参考资料：CTFwiki  扩展维纳攻击 - CTF Wiki

太难了，后面再看

EXP
#sagemath
from Crypto.Util.number import *
n = 110697784133988071803253124431092603234028687101567047811203431433689306543322837414808117411806181193598553341878079973980865551938790090419082150555675782822484149943421418447579383449269148197087985041351210982545320569973241390962326458234562044133505940521052500278777242988196544039226173227204865907343
c = 3281096209929505523196793672137624804022934270452947405454462490250571524417033484978613243658208567511735641542935158434165363547355697159503378251318054879687577130170122911449101189974762808655638497967674004219512386442280269940950792767174561412932638740423542930763914255112354969122157915514816022159
e0 = 28562806554366667733480283991307446762365777397933141571728113235368201162305126722188842319240464207580134816039095093401651171977877327756351539588974913736802534970867173212883308325913939353140276201705478124488858328502643345172188729914731042179091733244225184522680724392375975935305371163502863968963
e1 = 28572469216883232254074869113744730984165641173439644880182528671699871929340616919028955398474678696802739685594548793470261306125219888911330937557582939811068530294470712859439149735950996866732508004061234613146407591546995439312326450834903885979660916965052092661398640105827442036234500556755520316031

a = 5/14
D = diagonal_matrix(ZZ, [n, int(n^(1/2)), int(n^(1+a)), 1])
M = Matrix(ZZ, [[1, -n, 0, n^2],
                [0, e0, -e0, -e0*n],
                [0,  0, e1,  -e1*n],
                [0,  0,  0,  e0*e1]])*D
L = M.LLL()
t = vector(ZZ, L[0])
x = t * M^(-1)

#x * M = t
phi = int(x[1]/x[0]*e0)

d = inverse_mod(65537, phi)
m = power_mod(c, d, n)
print(long_to_bytes(m))
例题8
题目
from Crypto.Util.number import *

flag = b'******'
m = bytes_to_long(flag)

p = getPrime(512)
s = [getPrime(32) for i in range(3)]
a = [getPrime(512) for i in range(3)]

c = (a[0]*s[0]**2*s[1]**2 + a[1]*s[0]*s[2]**2 + a[2]*s[1]*s[2]) % p

flag = m*s[0]*s[1]*s[2]
print(f'c = {c}')
print(f'flag = {flag}')
print(f'a = {a}')
print(f'p = {p}')



c = 740925064346371394698186587854547113606276228956443989781507592148712696471120454242180757282913190509143771235457885619359315384722931529795071829165028
flag = 68803130911709451943985629442913968356735244797651554293510331427148284907075221530061581131130283569506280604032687824733336171953927
a = [8205051800134728054685810600921116779466017139080528864745521629232854690213051609775306424843961090482436503418278207286549634492623172279113808752825877, 7656695314164580223033364292542508972053206838456547579023164583502640699225283686572923544677077467571265812610524520719197913305928971777756847148151453, 12016313094941119621096276870216129960285946825332008187797823075795491053640261786033376211694851951499688886358239835607622191418940486434225440651886891]
p = 9725369974716521164256395525866212215114818770667579116304398350357785690930260317036889742178436308598088096925530431498664796728861093872628194022265573
分析
我们得到关系式

但是这里的c是已知量，我们构造的原则是让最短向量为未知数，所以我们要对关系式变形，让一个未知量作为结果写在一侧，两边同乘​，移项：

通过这个关系式的系数作为格的其中一列来构造格：

​

显然​是一个格点。

然后我们乘上一个对角线矩阵来配平大小关系，在这里，​的二进制位数都是32位，所以我们可以得到​上每个方向大小为：​

为此我们乘上此对角线矩阵：

这样便可利用LLL求解SVP问题从而得到​.

EXP
#sagemath
from Crypto.Util.number import *
c = 740925064346371394698186587854547113606276228956443989781507592148712696471120454242180757282913190509143771235457885619359315384722931529795071829165028
flag = 68803130911709451943985629442913968356735244797651554293510331427148284907075221530061581131130283569506280604032687824733336171953927
a = [8205051800134728054685810600921116779466017139080528864745521629232854690213051609775306424843961090482436503418278207286549634492623172279113808752825877, 7656695314164580223033364292542508972053206838456547579023164583502640699225283686572923544677077467571265812610524520719197913305928971777756847148151453, 12016313094941119621096276870216129960285946825332008187797823075795491053640261786033376211694851951499688886358239835607622191418940486434225440651886891]
p = 9725369974716521164256395525866212215114818770667579116304398350357785690930260317036889742178436308598088096925530431498664796728861093872628194022265573
ia = inverse_mod(a[2], p)

L = Matrix(ZZ, [[1, 0, 0, a[0]*ia%p],
                [0, 1, 0, a[1]*ia%p],
                [0, 0, 1,   -c*ia%p],
                [0, 0, 0,         p]]) * diagonal_matrix(ZZ, [1, 2^32, 2^128, 2^64])

v = L.LLL()[0]
s0s1 = isqrt(abs(v[0]))
s1s2 = abs(v[3]) >> 64
s1 = gcd(s0s1, s1s2)
s0 = s0s1 // s1
s2 = s1s2 // s1

flag = flag // s0 // s1 // s2
print(long_to_bytes(flag))
背包密码体制
一：背包问题
已知​个物品，他们的重量分别为​，现有一个重量为​的背包，装有其中某些物品，问装的是哪些物品？

或
二：超递增序列
，
即每个元素都大于前面所有元素的和。

超递增问题的解是很容易找到的。

例
例如：现有总质量为70kg的一个背包，质量序列为
，
，
，
，
，
​，试求哪些物品在背包中？

首先我们看到这个序列满足超递增序列，我们从质量大的物品开始计算：
1 .​，故52在背包中，剩余​
2 .​，故27不在背包中，
3 .​，故13在背包中，剩余​
4 .​，故6不在背包中，
5 .​，故3在背包中，剩余​
6 .​，故2在背包中，正好无剩余
故在背包中的有：
，
，
，
。
​

三：背包公钥系统的背包序列
①
超
递
增
序
列
②
用
模
乘
对
进
行
伪
装
，
选
取
，
与
互
素
，
③
得
到
一
个
序
列
（
注
意
，
此
时
不
在
满
足
超
递
增
序
列
）
将
序
列
作
为
公
钥
④
加
密
：
是
将
写
成
的
二
元
列
向
量
，
有
⑤
先
求
模
的
逆
，
即
，
已
知
，
则
易
得
例题1：加密过程
设背包密码系统的超递增序列为
（
）
​，乘数​，模数​，试对​加密

解题
首先将明文​转化为二进制，
（此题参照表如下，该参照表并非通用）

![image-20250304113001174](../../AppData/Roaming/Typora/typora-user-images/image-20250304113001174.png)

加密过程

![image-20250304113337858](../../AppData/Roaming/Typora/typora-user-images/image-20250304113337858.png)

例题2：解密过程
背包密码系统的超递增序列为
（
）
​，乘数​，模数​，试对密文
（
）
​解密

解题
，
易
得
​

有：​

即：
（
）
（
）
即
​

接下来对依次对（33,8,20,33）求物品（3,4,8,17,33）哪些在背包。

1：背包重量33kg：00001->A

2：背包重量8kg：00100->D

3：背包重量20kg：10010->R

4：背包重量33kg：00001->A

即明文：ADRA

Rabin加解密
Rabin算法的加密流程
1.取两个大素数p、q，满足​，有n=pq

2.加密过程​

我们会发现其实他等同于e=2时的RSA加密过程。Rabin加密算法适用于e=2,p、q已知且满足​.

Rabin算法的解密流程
Rabin本身是一种加解密方法,与RSA类似但这个函数不是单射,一个密文能解出4个明文。

取两个大素数(p,q)满足​

解密过程：求解​

因为p、q|n,相当于求解

(注：这里原本在模n下转换成分别模p，模q，是因为满足中国剩余定理：如果 p和 q 是互质的整数（即它们的最大公约数为 1），那么对于任意的整数 a和 b，存在唯一的整数 x使得：且这个 x的值是唯一的，范围在 0到 n−1（其中 n=p⋅q）.

对​来说c是模p的二次剩余，即

                                    ​

代入原式得​

开方得

同理，可解另外一个方程得（m3,m4）

明文为四个中的一个.

例题
from Crypto.Util.number import *
from gmpy2 import *

flag = b'NSSCTF{******}'

p = getPrime(256)
q = getPrime(256)

assert p%4 == 3 and q%4 == 3

n = p*q
e = 2
m = bytes_to_long(flag)

c = powmod(m, e, n)

print(f'p = {p}')
print(f'q = {q}')
print(f'e = {e}')
print(f'c = {c}')


p = 67711062621608175960173275013534737889372437946924512522469843485353704013203
q = 91200252033239924238625443698357031288749612243099728355449192607988117291739
e = 2
c = 5251890478898826530186837207902117236305266861227697352434308106457554098811792713226801824100629792962861125855696719512180887415808454466978721678349614
我们看到e=2,且有​.故是Rabin加密.

EXP
from Crypto.Util.number import *
from gmpy2 import *

p = 67711062621608175960173275013534737889372437946924512522469843485353704013203
q = 91200252033239924238625443698357031288749612243099728355449192607988117291739
e = 2
c = 5251890478898826530186837207902117236305266861227697352434308106457554098811792713226801824100629792962861125855696719512180887415808454466978721678349614

def rabin_attack(c, n, p, q):
    c1 = powmod(c, (p+1)//4, p)
    c2 = powmod(c, (q+1)//4, q)
    cp1 = p - c1
    cp2 = q - c2

    t1 = invert(p, q)
    t2 = invert(q, p)

    m1 = (q*c1*c2 + p*c2*t1) % n
    m2 = (q*c1*t2 + p*cp2*t1) % n
    m3 = (q*cp1*t2 + p*c2*t1) % n
    m4 = (q*cp1*t2 + p*cp2*t1) % n

    return m1, m2, m3, m4

ms = rabin_attack(c, p*q, p, q)

for m in ms:
    print(long_to_bytes(m))
例题2
from Crypto.Util.number import *
from gmpy2 import *

flag = b'NSSCTF{******}'

p = getPrime(256)
q = getPrime(256)

assert p%4 == 3 and q%4 == 3

n = p*q
e = 4
m = bytes_to_long(flag)

c = powmod(m, e, n)

print(f'p = {p}')
print(f'q = {q}')
print(f'e = {e}')
print(f'c = {c}')


p = 59146104467364373868799971411233588834178779836823785905639649355194168174467
q = 78458230412463183024731868185916348923227701568297699614451375213784918571587
e = 4
c = 1203393285445255679455330581174083350744414151272999693874069337386260499408999133487149585390696161509841251500970131235102423165932460197848215104528310
分析
本题是Rabin攻击的进阶题目，e从普通Rabin攻击中的2变成了4，如之奈何？

其实很简单，我们要的是e=2，那么就把​看成​即可，然后我们需要解两次Rabin一共会得到16组解，当然这里面只有一组解是我们想要的

本题的e更大，需要更多次Rabin，但其思想依然一样，一层一层的剥开即可，主要是考察代码编写能力，再两层时我们可以手动两次rabin，但多层时则需要考虑将重复的过程变成循环调用。

EXP
from Crypto.Util.number import *

p = 59146104467364373868799971411233588834178779836823785905639649355194168174467
q = 78458230412463183024731868185916348923227701568297699614451375213784918571587
e = 4
c = 1203393285445255679455330581174083350744414151272999693874069337386260499408999133487149585390696161509841251500970131235102423165932460197848215104528310

n = p*q

def rabin(c):
    mp = pow(c, (p + 1) // 4, p)
    mq = pow(c, (q + 1) // 4, q)

    yp = inverse(p,q)
    yq = inverse(q,p)

    r = (yp * p * mq + yq * q * mp) % n
    r_ = n - r
    s = (yp * p * mq - yq * q * mp) % n
    s_ = n - s
    return r,r_,s,s_

c_list = rabin(c)
for c in c_list:
    cc = rabin(c)
    for c in cc:
        flag = long_to_bytes(c)
        if b'NSSCTF' in flag:
            print(flag)
例1和例2代码差异比较
特性	rabin(c)	rabin_attack(c, n, p, q)
参数依赖	依赖全局变量 p, q, n	参数化，函数更通用
模反运算	使用 inverse(p, q)	使用 invert(p, q) (来自 gmpy2)
模幂运算	使用 Python 内置 pow	使用更高效的 gmpy2.powmod
公式表达	使用 ​	显式代数展开多个解公式
复用性	不易复用，特定场景下适用	更适合在不同参数下的场景复用
代码长度	较短，直观	稍微长一些，但更模块化
其他RSA
例题1
from Crypto.Util.number import *
from gmpy2 import next_prime
from secrets import flag
l=2331
key=0
for k in range(2**(l-1),2**l):
    s=bin(k)[2:]
    if(k%2==1 and '1111' not in s and '0000' not in s):
        key+=1
p=next_prime(key)
q=getPrime(2048)
n=p*q
e=65537
m=bytes_to_long(flag)
c=pow(m,e,n)
print(f'n=',n)
print(f'c=',c)


n=739243847275389709472067387827484120222494013590074140985399787562594529286597003777105115865446795908819036678700460141950875653695331369163361757157565377531721748744087900881582744902312177979298217791686598853486325684322963787498115587802274229739619528838187967527241366076438154697056550549800691528794136318856475884632511630403822825738299776018390079577728412776535367041632122565639036104271672497418509514781304810585503673226324238396489752427801699815592314894581630994590796084123504542794857800330419850716997654738103615725794629029775421170515512063019994761051891597378859698320651083189969905297963140966329378723373071590797203169830069428503544761584694131795243115146000564792100471259594488081571644541077283644666700962953460073953965250264401973080467760912924607461783312953419038084626809675807995463244073984979942740289741147504741715039830341488696960977502423702097709564068478477284161645957293908613935974036643029971491102157321238525596348807395784120585247899369773609341654908807803007460425271832839341595078200327677265778582728994058920387721181708105894076110057858324994417035004076234418186156340413169154344814582980205732305163274822509982340820301144418789572738830713925750250925049059
c=229043746793674889024653533006701296308351926745769842802636384094759379740300534278302123222014817911580006421847607123049816103885365851535481716236688330600113899345346872012870482410945158758991441294885546642304012025685141746649427132063040233448959783730507539964445711789203948478927754968414484217451929590364252823034436736148936707526491427134910817676292865910899256335978084133885301776638189969716684447886272526371596438362601308765248327164568010211340540749408337495125393161427493827866434814073414211359223724290251545324578501542643767456072748245099538268121741616645942503700796441269556575769250208333551820150640236503765376932896479238435739865805059908532831741588166990610406781319538995712584992928490839557809170189205452152534029118700150959965267557712569942462430810977059565077290952031751528357957124339169562549386600024298334407498257172578971559253328179357443841427429904013090062097483222125930742322794450873759719977981171221926439985786944884991660612824458339473263174969955453188212116242701330480313264281033623774772556593174438510101491596667187356827935296256470338269472769781778576964130967761897357847487612475534606977433259616857569013270917400687539344772924214733633652812119743
分析
我们看到代码在求key的过程很慢，故我们考虑优化此代码：
可以通过动态规划（DP）来优化这个问题，避免直接枚举每个数字。具体来说，我们可以通过状态转移来避免计算重复的子问题。

优化思路
状态定义：我们可以用动态规划来记录到某一位为止，满足条件的二进制数的个数。定义状态 dp[i][last4]，表示长度为 i 的二进制数，且末尾的4位是 last4，其中 last4 可以是 0-15 之间的任意值，表示二进制的最后4位的值。

状态转移：我们从状态 dp[i-1][last4] 转移到 dp[i][last4_new]。转移条件是，last4_new 不能是包含 1111 或 0000 的四位。

边界条件：初始状态为 dp[1][1] = 1（从长度为1的二进制数 1 开始，last4 只有 1），然后我们可以逐步扩展长度。

def count_valid_keys(l):
    # 初始化动态规划表
    dp = [[0] * 16 for _ in range(l+1)]
    
    # 初始条件：1位二进制数，末尾为1（即奇数）
    dp[1][1] = 1
    
    # 状态转移：从长度为i的二进制数转移到长度为i+1的二进制数
    for i in range(1, l):
        for last4 in range(16):
            if dp[i][last4] > 0:
                for bit in [0, 1]:
                    new_last4 = ((last4 << 1) | bit) & 0xF  # 更新last4，保留低4位
                    # 检查是否包含1111或0000
                    if new_last4 != 0xF and new_last4 != 0x0:
                        dp[i+1][new_last4] += dp[i][last4]

    # 统计满足条件的数字数量
    result = sum(dp[l][last4] for last4 in range(16) if last4 & 1)  # 最后一位为1（奇数）
    return result

# 调用函数，计算key
l = 2331
key = count_valid_keys(l)
print(key)
代码解释
dp[i][last4]：表示长度为 i 的二进制数，末尾的四位是 last4，其中 last4 是一个 4 位二进制数（0 到 15）。我们将状态压缩为 last4 的 4 位表示。

状态转移：从长度为 i 的二进制数转移到长度为 i+1 的二进制数时，last4_new 通过移位和按位或来更新。我们确保新生成的 last4_new 不包含 '1111' 或 '0000'（即不等于 0xF 和 0x0）。

最后的统计：我们只关心最后一位为 1 的二进制数，即 last4 中的最低位（即 last4 & 1）必须为 1。最终的结果是所有符合条件的长度为 l 且奇数的二进制数个数。

优点
通过动态规划，我们将问题转化为状态转移，避免了遍历所有可能的二进制数，大大提高了计算效率。

每个状态只考虑到当前四位的组合，避免了对整个二进制数的枚举。

EXP
#解法一
from Cryptodome.Util.number import *
from gmpy2 import next_prime
from Cryptodome.Util.number import *
import libnum
from gmpy2 import gmpy2
def count_valid_keys(l):
    # 初始化动态规划表
    dp = [[0] * 16 for _ in range(l + 1)]

    # 初始条件：1位二进制数，末尾为1（即奇数）
    dp[1][1] = 1

    # 状态转移：从长度为i的二进制数转移到长度为i+1的二进制数
    for i in range(1, l):
        for last4 in range(16):
            if dp[i][last4] > 0:
                for bit in [0, 1]:
                    new_last4 = ((last4 << 1) | bit) & 0xF  # 更新last4，保留低4位
                    # 检查是否包含1111或0000
                    if new_last4 != 0xF and new_last4 != 0x0:
                        dp[i + 1][new_last4] += dp[i][last4]

    # 统计满足条件的数字数量
    result = sum(dp[l][last4] for last4 in range(16) if last4 & 1)  # 最后一位为1（奇数）
    return result


# 调用函数，计算key
l = 2331
key = count_valid_keys(l)
print(key)
p=next_prime(key)
n=739243847275389709472067387827484120222494013590074140985399787562594529286597003777105115865446795908819036678700460141950875653695331369163361757157565377531721748744087900881582744902312177979298217791686598853486325684322963787498115587802274229739619528838187967527241366076438154697056550549800691528794136318856475884632511630403822825738299776018390079577728412776535367041632122565639036104271672497418509514781304810585503673226324238396489752427801699815592314894581630994590796084123504542794857800330419850716997654738103615725794629029775421170515512063019994761051891597378859698320651083189969905297963140966329378723373071590797203169830069428503544761584694131795243115146000564792100471259594488081571644541077283644666700962953460073953965250264401973080467760912924607461783312953419038084626809675807995463244073984979942740289741147504741715039830341488696960977502423702097709564068478477284161645957293908613935974036643029971491102157321238525596348807395784120585247899369773609341654908807803007460425271832839341595078200327677265778582728994058920387721181708105894076110057858324994417035004076234418186156340413169154344814582980205732305163274822509982340820301144418789572738830713925750250925049059
c=229043746793674889024653533006701296308351926745769842802636384094759379740300534278302123222014817911580006421847607123049816103885365851535481716236688330600113899345346872012870482410945158758991441294885546642304012025685141746649427132063040233448959783730507539964445711789203948478927754968414484217451929590364252823034436736148936707526491427134910817676292865910899256335978084133885301776638189969716684447886272526371596438362601308765248327164568010211340540749408337495125393161427493827866434814073414211359223724290251545324578501542643767456072748245099538268121741616645942503700796441269556575769250208333551820150640236503765376932896479238435739865805059908532831741588166990610406781319538995712584992928490839557809170189205452152534029118700150959965267557712569942462430810977059565077290952031751528357957124339169562549386600024298334407498257172578971559253328179357443841427429904013090062097483222125930742322794450873759719977981171221926439985786944884991660612824458339473263174969955453188212116242701330480313264281033623774772556593174438510101491596667187356827935296256470338269472769781778576964130967761897357847487612475534606977433259616857569013270917400687539344772924214733633652812119743
q=n//p
e=65537
phi_n=(p-1)*(q-1)
d = gmpy2.invert(e,phi_n)
m = pow(c,d,n)
print(long_to_bytes(m))
快速求二次剩余
def tonelli_shanks(a, p):
    """使用托内利-尚克斯算法求解 x^2 ≡ a (mod p)"""
    # 检查 a 是否为二次剩余
    if pow(a, (p - 1) // 2, p) != 1:
        return None  # a 不是二次剩余

    # 将 p-1 分解为 q * 2^s
    s = 0
    q = p - 1
    while q % 2 == 0:
        s += 1
        q //= 2

    # 找到一个非二次剩余 z
    z = 2
    while pow(z, (p - 1) // 2, p) != p - 1:
        z += 1

    # 初始化变量
    m = s
    c = pow(z, q, p)
    t = pow(a, q, p)
    r = pow(a, (q + 1) // 2, p)

    # 主循环
    while t != 1:
        # 找到最小的 i 满足 t^(2^i) ≡ 1 (mod p)
        t2i = t
        i = 0
        for i in range(1, m):
            t2i = pow(t2i, 2, p)
            if t2i == 1:
                break

        # 更新变量
        b = pow(c, 2 ** (m - i - 1), p)
        m = i
        c = pow(b, 2, p)
        t = (t * b * b) % p
        r = (r * b) % p

    return r

# 数据
p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139
a = 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771

# 调用函数
result = tonelli_shanks(a, p)
if result is not None:
    print(f"模平方根为: {result} 和 {p - result}")
else:
    print("没有平方根（不是二次剩余）")
左移10000位
题目
assert(len(open('flag.txt', 'rb').read()) <= 50)
assert(str(int.from_bytes(open('flag.txt', 'rb').read(), byteorder='big') << 10000).endswith('16732186163543403522711798960598469149029861032300263763941636254755451456334507142958574415880945599253440468447483752611840'))

#endwith后为125位
#其中加密方式为utf-8
分析
题目中给出了两个断言：

1.flag长度小于50.

2.int.from_bytes()函数，是将字符串按照ascll码转化成数字。flag转成数字后，在向左移10000位，即乘以​.

所以flag的变换就是：
我们设余数​

这里为什么要与​取余呢：因为最后结尾的数字有125位。在这里举例说明：

例如有一个数15239971，那么要得到9971，则模10 ** 4
>>> 15239971 % 10**4
9971
我们有​

我们发现
和
​有公因数​，约去得到：​

最后进行求​的逆元，进行正常运算求解即可。

EXP
from gmpy2 import *
from Cryptodome.Util.number import *

c = 16732186163543403522711798960598469149029861032300263763941636254755451456334507142958574415880945599253440468447483752611840

x = invert(pow(2, 9875), pow(5, 125))
m = (c//2**125) * x % (pow(5, 125))
print(long_to_bytes(m))
CRT和Fermat的妙用
import os
from Crypto.Util.number import *
from typing import Union
from flag import flag

bits = 512


def polar(msg: Union[bytes, bytearray], length: int) -> bytes:
    assert length > len(msg), "指定的长度必须大于原始消息长度加 1。"
    return bytes(msg) + b'\x00' + os.urandom(length - len(msg) - 1)


def unpolar(msg: Union[bytes, bytearray]) -> bytes:
    msg = bytes(msg)
    assert b'\x00' in msg, "输入的字节串中不包含分隔符。"
    return msg.split(b'\x00')[0]


def getflag1(m):
    result = []
    for i in range(2):
        result.append(getPrime(bits))
    p, q = result
    if p <= q:
        p, q = q, p
    e = 0x10001
    n = p * q
    c = pow(m, e, n)
    hint = pow(2024 * p + 2025, q, n)
    print('---------- getflag 1 ----------')
    print(f'{c = }')
    print(f'{n = }')
    print(f'{hint = }')


def getflag2(m):
    result = []
    for i in range(2):
        result.append(getPrime(bits))
    p, q = result
    n = p * q
    hint1 = pow(m, p, n)
    hint2 = pow(m, q, n)
    print('---------- getflag 2 ----------')
    print(f'{hint1 = }')
    print(f'{hint2 = }')
    print(f'{n = }')



def getflag3(m):
    result = []
    for i in range(2):
        result.append(getPrime(bits))
    p, q = result
    e = 0x10001
    n = p * q
    g = 20242025
    hint = pow(g + p * 1111, e, n)
    c = pow(m, e, n)
    print('---------- getflag 3 ----------')
    print(f'{c = }')
    print(f'{n = }')
    print(f'{hint = }')


assert len(flag) == 42
mm = []
for i in range(0, 42, 14):
    mm.append(bytes_to_long(polar(flag[i:i + 14], bits // 4 - 1)))

m1, m2, m3 = mm
getflag1(m1)
getflag2(m2)
getflag3(m3)
---------- getflag 1 ----------
c = 106932814634172489425702007139140373546834917771367058711944984593149465629951198769828679883270594158665297746680289248056977346295975218434156754937039740474715490069136163100111573379630763755493571058775063239132348709658984213922635566937023561820595839822600865948106997713601138967967447835143132518249
n = 114546425588310081671864824979705524066909097193297064099051733046402463555650788674630216283713981601352701801247525374203450930718461734483264497798387006484238009970986630571854153754756808866976403302100414756641710076386950849275884332309214691647884729239866449303022190966328416202728653161194734181397
hint = 14167026592757385645683964635731214642720851230816007832728179594137078788184547251188361494083671558554399706352083594406586455990047883120343525622731906783627614035714546815384092987686711187001531557864904478781545860378341648063119238398535969022698033097727057913728653478849054917253235938883271690040
---------- getflag 2 ----------
hint1 = 54970781924019595863484530626735693712920476619483230578277656430455790362335041922354389265430681573039703011001631761902508906456609398108389457140693872973125229844737616298484143628327833079090999615173264817695407599821875528027430069058944656983590302062976047694462479290647389958480266319059751445182
hint2 = 80980259919808074704372134146767866092949512532096534576106851289748846005248116120680155543668224921613789932208624456370489831230478815466334144780133065025062986201532876895224101781697909762258725545339404197634465901767246731955823620770784243939730616060814584918359635917314703766496053543724484797173
n = 99517070479321715054584809647801078099246408970263686466424530637818701832562120579305425855216653939240321111911361599565693184872902069364547154817279854814534957350288095457061287301409197137152708536099357243361609267071166651650163387054480968146813088675351466317148500854487952501075120046716531779527
---------- getflag 3 ----------
c = 51100026339357786159146465987268050654484932407305430030434719506588905998943430883131311324670025897109006729477302362003557202463770250321227873150557579374770683129700977409481692251037899461661968708767126966344274947046391169588818731128072220629623368296581244087481436853929555771832747210836109696703
n = 85897150916833688522635686742994777963661211681341125201267041008790197490758867298985626011222830465064289727655147523984810647113543131152913693609062807059393201711922197064632101712280889245466817477074958630885164568068656410500872384462043993495454174325021766338459126370431040295739507618513598240657
hint = 74207877151043153331465477182019527898792092627334195908322826913320865766713698819838691762501128169631345035620355122351143434970770413620094036828820672753396419434430235436928712839835293124866139083678902005527999303052152257999599043696672040830910609582145273960759790396567889053040599505269507804705
分析
我们看到该题目将flag分为了三段，每一段采用不同的加密方式。

flag1：

我们看到加密关键点：

hint = pow(2024 * p + 2025, q, n)
我们知道：

利用二次项展开和CRT在模p的情况下，我们知道上式等于：

由于我们不知道p和q的具体值，所以​我们写成：​

即：​，看出p是其公约数。

p=gcd(pow(2025,n,n)-hint%n,n)
这里为什么可以改写：

	
在
模
下
等
于
：
​

flag2：

我们看见关键点：

hint1 = pow(m, p, n)
hint2 = pow(m, q, n)
我们知道：

利用CRT分解，在模p的情况下：

利用在模p的情况下​

		这里构造
为
了
与
进
行
运
算
​

其中推出：​

即：​

flag3：

我们看见关键点：

hint = pow(g + p * 1111, e, n)
我们知道：

仍旧利用CRT分解，在模p的情况下：

考虑​在模p的情况下：

可以看出：​

我们看到此题我们大量运用了CRT的分解，将n分解成​，然后考虑在模p和模q的情况下（上面只分析了在模p的情况，而没有分析模q的情况原因在于：在模q的情况下与模p的分析过程类似，都主要运用Fermat化简，而题目所给在模p下可以求解，在模q下不成立故未分析模q）,进行化简，同时我们也多次运用了构造，将在类似
和
未
知
的
情
况
下
，
构
造
成
为
：
​.

EXP
from math import gcd
from Cryptodome.Util.number import long_to_bytes
from gmpy2 import invert
def flag1():
    e=65537
    c = 106932814634172489425702007139140373546834917771367058711944984593149465629951198769828679883270594158665297746680289248056977346295975218434156754937039740474715490069136163100111573379630763755493571058775063239132348709658984213922635566937023561820595839822600865948106997713601138967967447835143132518249
    n = 114546425588310081671864824979705524066909097193297064099051733046402463555650788674630216283713981601352701801247525374203450930718461734483264497798387006484238009970986630571854153754756808866976403302100414756641710076386950849275884332309214691647884729239866449303022190966328416202728653161194734181397
    hint = 14167026592757385645683964635731214642720851230816007832728179594137078788184547251188361494083671558554399706352083594406586455990047883120343525622731906783627614035714546815384092987686711187001531557864904478781545860378341648063119238398535969022698033097727057913728653478849054917253235938883271690040
    p=gcd(pow(2025,n,n)-hint%n,n)
    q=n//p
    d=invert(e,(p-1)*(q-1))
    flag1=long_to_bytes(pow(c,d,n))
    return flag1[:14]

def flag2():
    hint1 = 54970781924019595863484530626735693712920476619483230578277656430455790362335041922354389265430681573039703011001631761902508906456609398108389457140693872973125229844737616298484143628327833079090999615173264817695407599821875528027430069058944656983590302062976047694462479290647389958480266319059751445182
    hint2 = 80980259919808074704372134146767866092949512532096534576106851289748846005248116120680155543668224921613789932208624456370489831230478815466334144780133065025062986201532876895224101781697909762258725545339404197634465901767246731955823620770784243939730616060814584918359635917314703766496053543724484797173
    n = 99517070479321715054584809647801078099246408970263686466424530637818701832562120579305425855216653939240321111911361599565693184872902069364547154817279854814534957350288095457061287301409197137152708536099357243361609267071166651650163387054480968146813088675351466317148500854487952501075120046716531779527
    p=gcd(pow(hint1,n,n)-hint2,n)
    q=n//p
    q=n//p
    d=invert(p,(p-1)*(q-1))
    flag2=long_to_bytes(pow(hint1,d,n))
    return flag2[:14]

def flag3():
    c = 51100026339357786159146465987268050654484932407305430030434719506588905998943430883131311324670025897109006729477302362003557202463770250321227873150557579374770683129700977409481692251037899461661968708767126966344274947046391169588818731128072220629623368296581244087481436853929555771832747210836109696703
    n = 85897150916833688522635686742994777963661211681341125201267041008790197490758867298985626011222830465064289727655147523984810647113543131152913693609062807059393201711922197064632101712280889245466817477074958630885164568068656410500872384462043993495454174325021766338459126370431040295739507618513598240657
    hint = 74207877151043153331465477182019527898792092627334195908322826913320865766713698819838691762501128169631345035620355122351143434970770413620094036828820672753396419434430235436928712839835293124866139083678902005527999303052152257999599043696672040830910609582145273960759790396567889053040599505269507804705
    g = 20242025
    e=65537
    p=gcd(pow(g,e,n)-hint,n)
    q=n//p
    d=invert(e,(p-1)*(q-1))
    flag3=long_to_bytes(pow(c,d,n))
    return flag3[:14]

print(flag1()+flag2()+flag3())
RSA和base32换表
题目：[广东强网杯 2021 团队组]RSA and BASE? | NSSCTF
RSA:
n=56661243519426563299920058134092862370737397949947210394843021856477420959615132553610830104961645574615005956183703191006421508461009698780382360943562001485153455401650697532951591191737164547520951628336941289873198979641173541232117518791706826699650307105202062429672725308809988269372149027026719779368169
e=36269788044703267426177340992826172140174404390577736281478891381612294207666891529019937732720246602062358244751177942289155662197410594434293004130952671354973700999803850153697545606312859272554835232089533366743867361181786472126124169787094837977468259794816050397735724313560434944684790818009385459207329
c=137954301101369152742229874240507191901061563449586247819350394387527789763579249250710679911626270895090455502283455665178389917777053863730286065809459077858674885530015624798882224173066151402222862023045940035652321621761390317038440821354117827990307003831352154618952447402389360183594248381165728338233

BASE:
"GHI45FQRSCX****UVWJK67DELMNOPAB3"
题目看到e很大，在RSA部分考虑维纳攻击。

得到结果后发现是base加密，再看题目给出的base表，考虑base32换表。

#此题在RSA部分可以factordb可以直接分解，故未使用维纳攻击，但尝试维纳攻击脚本也可进行破解
from gmpy2 import invert
from Cryptodome.Util.number import long_to_bytes
from itertools import permutations
import base64

n = 56661243519426563299920058134092862370737397949947210394843021856477420959615132553610830104961645574615005956183703191006421508461009698780382360943562001485153455401650697532951591191737164547520951628336941289873198979641173541232117518791706826699650307105202062429672725308809988269372149027026719779368169
e = 36269788044703267426177340992826172140174404390577736281478891381612294207666891529019937732720246602062358244751177942289155662197410594434293004130952671354973700999803850153697545606312859272554835232089533366743867361181786472126124169787094837977468259794816050397735724313560434944684790818009385459207329
c = 137954301101369152742229874240507191901061563449586247819350394387527789763579249250710679911626270895090455502283455665178389917777053863730286065809459077858674885530015624798882224173066151402222862023045940035652321621761390317038440821354117827990307003831352154618952447402389360183594248381165728338233
# factordb result
p = 127059276863396320706295330136200886609600493401056775186365515611547962912096366560863480830412003882577863014816249680438671577507675892180828563868163627
q = 445943381059409537717658916522990906261609738909680208927145849237389096915733551127729182559244164126263654638010224865124975773193229727063534492604345147

m = pow(c, invert(e, (p - 1) * (q - 1)), n)
print("flag:", long_to_bytes(m))

str_list = ['T', 'Y', 'Z', '2']
perms = permutations(str_list)#列出列表所有排列组合
middle_part = []
for perm in perms:
    middle_part.append(''.join(perm))
for str_part in middle_part:
    flag = 'TCMDIEOH2MJFBLKHT2J7BLYZ2WUE5NYR2HNG===='
    t = 'GHI45FQRSCX' + str_part + 'UVWJK67DELMNOPAB3='
    table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='
    table = str.maketrans(t, table)#进行换表
    flag = base64.b32decode(flag.translate(table))
    print(flag)
discrete_log函数求解离散对数
题目[网鼎杯 2020 青龙组]you_raise_me_up | NSSCTF
from Crypto.Util.number import *
import random

n = 2 ** 512
m = random.randint(2, n-1) | 1
c = pow(m, bytes_to_long(flag), n)
print 'm = ' + str(m)
print 'c = ' + str(c)

# m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075
# c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499
分析
我们这次要求解的flag变成了正常RSA中的e，故我们考虑在模n下求解对数即可。

直接用 sympy 库里的 discrete_log(模数，真数，底数) 求解离散对数问题

EXP
from sympy import discrete_log

n = 2 ** 512
m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075
c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499
flag = discrete_log(n, c, m)
print(long_to_bytes(flag))
对称密码
DES
例题1：基本DES
from operator import add
from typing import List
from functools import reduce

_IP = [57, 49, 41, 33, 25, 17, 9, 1,
       59, 51, 43, 35, 27, 19, 11, 3,
       61, 53, 45, 37, 29, 21, 13, 5,
       63, 55, 47, 39, 31, 23, 15, 7,
       56, 48, 40, 32, 24, 16, 8, 0,
       58, 50, 42, 34, 26, 18, 10, 2,
       60, 52, 44, 36, 28, 20, 12, 4,
       62, 54, 46, 38, 30, 22, 14, 6
       ]


def IP(plain: List[int]):
    return list(map(lambda x: plain[x], _IP))


__pc1 = [56, 48, 40, 32, 24, 16, 8,
         0, 57, 49, 41, 33, 25, 17,
         9, 1, 58, 50, 42, 34, 26,
         6, 61, 53, 45, 37, 29, 21,
         18, 10, 2, 59, 51, 43, 35,
         62, 54, 46, 38, 30, 22, 14,
         13, 5, 60, 52, 44, 36, 28,
         20, 12, 4, 27, 19, 11, 3
         ]

__pc2 = [
    13, 16, 10, 23, 0, 4,
    2, 27, 14, 5, 20, 9,
    22, 18, 11, 3, 25, 7,
    43, 48, 38, 55, 33, 52,
    15, 6, 26, 19, 12, 1,
    40, 51, 30, 36, 46, 54,
    29, 39, 50, 44, 32, 47,
    45, 41, 49, 35, 28, 31
]
ROTATIONS = [1, 1, 2, 2, 3, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]


def PC_1(key: List[int]):
    return list(map(lambda x: key[x], __pc1))


def PC_2(key: List[int]):
    return list(map(lambda x: key[x], __pc2))


def get_sub_key(key: List[int]):
    key = PC_1(key)  # PC-1置换
    L, R = key[:28], key[28:]  # 分成两半

    skeys = []

    for i in range(16):
        for j in range(ROTATIONS[i]):  # 根据轮次左移
            L = L[1:] + L[:1]
            R = R[1:] + R[:1]

        skeys.append(PC_2(L + R))  # PC-2置换

    return skeys


__expansion_table = [
    31, 0, 1, 2, 3, 4,
    3, 4, 5, 6, 7, 8,
    7, 8, 9, 10, 11, 12,
    11, 12, 13, 14, 15, 16,
    15, 16, 17, 18, 19, 20,
    19, 20, 21, 22, 23, 24,
    23, 24, 25, 26, 27, 28,
    27, 28, 29, 30, 31, 0
]
__sbox = [
    # S1
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
     0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
     4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
     15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],

    # S2
    [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
     3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
     0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
     13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],

    # S3
    [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
     13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
     13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
     1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],

    # S4
    [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
     13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
     10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
     3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],

    # S5
    [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
     14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
     4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
     11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],

    # S6
    [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
     10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
     9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
     4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],

    # S7
    [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
     13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
     1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
     6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],

    # S8
    [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
     1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
     7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
     2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
]
__p = [
    15, 6, 19, 20, 28, 11,
    27, 16, 0, 14, 22, 25,
    4, 17, 30, 9, 1, 7,
    23, 13, 31, 26, 2, 8,
    18, 12, 29, 5, 21, 10,
    3, 24
]


def EP(data: List[int]):  # 扩展置换
    return list(map(lambda x: data[x], __expansion_table))


def P(data: List[int]):  # P置换
    return list(map(lambda x: data[x], __p))


def F(index: int, R: List[int], skeys: List[List[int]]):
    """
    index: 代表这是第几轮
    R: 输入数据
    skeys: 子密钥数组
    """
    R = EP(R)  # 扩展置换
    R = list(map(lambda x, y: x ^ y, R, skeys[index]))  # 异或

    B = [R[:6], R[6:12], R[12:18], R[18:24], R[24:30], R[30:36], R[36:42], R[42:]]  # 分成八份

    Bn = [0] * 32
    pos = 0
    for i in range(8):
        #  计算该使用S盒的行坐标和列坐标
        row = (B[i][0] << 1) + B[i][5]
        col = (B[i][1] << 3) + (B[i][2] << 2) + (B[i][3] << 1) + B[i][4]

        sb = __sbox[i][(row << 4) + col]

        Bn[pos + 0] = (sb & 8) >> 3  # 四位输出
        Bn[pos + 1] = (sb & 4) >> 2
        Bn[pos + 2] = (sb & 2) >> 1
        Bn[pos + 3] = (sb & 1)

        pos += 4
    R = P(Bn)
    return R


_FP = [
    39, 7, 47, 15, 55, 23, 63, 31,
    38, 6, 46, 14, 54, 22, 62, 30,
    37, 5, 45, 13, 53, 21, 61, 29,
    36, 4, 44, 12, 52, 20, 60, 28,
    35, 3, 43, 11, 51, 19, 59, 27,
    34, 2, 42, 10, 50, 18, 58, 26,
    33, 1, 41, 9, 49, 17, 57, 25,
    32, 0, 40, 8, 48, 16, 56, 24
]


def FP(plain: List[int]):
    return list(map(lambda x: plain[x], _FP))


plain = b'********'
flag = b'NSSCTF{%s}' % (plain)
key = b'12345678'
#
# # 转为二进制数组
# key = reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in key])
# plain = reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in plain])
# #表达式 `reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in key])` 使用了 Python 的 `reduce` 函数和 `map` 函数，以及列表推导式来处理一个名为 `key` 的列表。这个表达式的作用是将 `key` 列表中的每个整数转换为8位的二进制表示，并将这些二进制列表“累加”成一个单一的二进制列表。下面是这个表达式的详细解释：
# 1. `bin(i)[2:]`：对于 `key` 列表中的每个整数 `i`，`bin(i)` 会生成一个表示该整数的二进制字符串，例如 `bin(5)` 会返回 `'0b101'`。通过 `[2:]` 切片操作，我们去掉了前缀 `'0b'`，只保留了二进制数字部分。
# 2. `zfill(8)`：`zfill(8)` 方法用于在字符串左侧填充零，直到字符串长度为8。这意味着无论原始的二进制数字有多少位，使用 `zfill(8)` 后，它都会被转换为一个8位的二进制字符串。
# 3. `map(int, ...)`：`map` 函数将 `int` 函数应用于 `zfill(8)` 处理后的二进制字符串中的每个字符，将每个 '0' 或 '1' 字符串转换为整数。
# 4. `list(...)`：将 `map` 函数的结果转换为列表。
# 5. 列表推导式 `[... for i in key]`：对于 `key` 列表中的每个元素 `i`，执行上述转换，并将结果存储在一个新的列表中。
# 6. `reduce(add, ...)`：`reduce` 函数接受两个参数：一个函数和一个可迭代对象。在这个例子中，`add` 是一个函数，它接受两个参数并返回它们的和。`reduce` 函数将 `add` 函数应用于列表推导式的结果，这意味着它将列表中的所有二进制列表“累加”在一起。这里的“累加”实际上是列表的连接操作，因为 `add` 函数在这里被重载为列表的 `+` 操作。
# 举个例子，如果 `key` 是 `[3, 5]`，那么：
# python
# key = [3, 5]
# # 将每个数字转换为8位二进制并转换为整数列表
# binary_lists = [list(map(int, bin(i)[2:].zfill(8))) for i in key]
# # 累加（连接）所有的二进制列表
# result = reduce(add, binary_lists)
# print(result)  # 输出: [0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1]
# 在这个例子中，`3` 的二进制表示是 `11`，填充零后变为 `00000011`，`5` 的二进制表示是 `101`，填充零后变为 `00000101`。这两个二进制列表 `[0, 0, 0, 0, 1, 1]` 和 `[0, 0, 0, 1, 0, 1, 0, 1]` 被连接在一起，形成了最终的列表 `[0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1]`。


skeys = get_sub_key(key)

block = IP(plain)

L, R = block[:32], block[32:]
for i in range(16):
    tpR = R[:]
    R = F(i, R, skeys)
    R = list(map(lambda x, y: x ^ y, R, L))
    L = tpR
block = R + L
block = FP(block)
enc = bytes([int(''.join(map(str, block[i * 8:(i + 1) * 8])), 2) for i in range(8)])
print(enc)  # b'O5\xc9}\x7f`\xe8\xa8'
分析
我们发现无需关系F函数的内部实现，在16轮迭代中：

L, R = block[:32], block[32:]
for i in range(16):
    tpR = R[:]
    R = F(i, R, skeys)
    R = list(map(lambda x, y: x ^ y, R, L))
    L = tpR
第一轮的输入L, R来之初始block，然后通过循环生成新的R，并且和L异或得到下一轮的R，那么我们发现要通过下一轮来得到上一轮只需要将顺序倒过来即可，例如我们考虑第一轮：R2=L1⊕F(0,R1)，L2=R1；有R1=L2，L1=R2⊕F(0,L2).

所以我们解密只需要倒过来运行16次即可，而且对于DES来说，IP和FP置换互为逆运算，所以对于其他代码我们完全不需要改动，我们将中间16轮迭代看作E函数，则加密可简单的理解为：M→IP(M)→E(IP(M))→FP(E(IP(M)))；

则我们解密则需要：FP(E(I**P(M)))→IP(FP(E(IP(M))))=E(IP(M))
                                                                →E′(E(IP(M)))=IP(M)
                                                                →FP(M)=M
                                           （E′便是我们上述描述的逆过程）

EXP
#我们只需要将下面这部分改动即可.
for i in range(15, -1, -1):
    """
    解密关键点， 只需要将这里的循环逆过来操作即可，这个设计很巧妙
    若是不能理解为何其他地方不需做变更，可以在加密代码中去掉这组循环观察首位对明文造成的影响以及如何恢复
    以及将这组循环单独运行再观察对明文的影响以及如何恢复
    """
    tpR = R[:]
    R = F(i, R, skeys)
    R = list(map(lambda x, y: x ^ y, R, L))
    L = tpR
block = R + L
block = FP(block)
plain = bytes([int(''.join(map(str,block[i*8:(i+1)*8])),2) for i in range(8)])
    
print(b'NSSCTF{%s}' % plain)
例题2：未密钥异或DES
from operator import add
from typing import List
from functools import reduce

_IP = [57, 49, 41, 33, 25, 17, 9, 1,
       59, 51, 43, 35, 27, 19, 11, 3,
       61, 53, 45, 37, 29, 21, 13, 5,
       63, 55, 47, 39, 31, 23, 15, 7,
       56, 48, 40, 32, 24, 16, 8, 0,
       58, 50, 42, 34, 26, 18, 10, 2,
       60, 52, 44, 36, 28, 20, 12, 4,
       62, 54, 46, 38, 30, 22, 14, 6
       ]


def IP(plain: List[int]):
    return list(map(lambda x: plain[x], _IP))


__pc1 = [56, 48, 40, 32, 24, 16, 8,
         0, 57, 49, 41, 33, 25, 17,
         9, 1, 58, 50, 42, 34, 26,
         18, 10, 2, 59, 51, 43, 35,
         62, 54, 46, 38, 30, 22, 14,
         6, 61, 53, 45, 37, 29, 21,
         13, 5, 60, 52, 44, 36, 28,
         20, 12, 4, 27, 19, 11, 3
         ]

__pc2 = [
    13, 16, 10, 23, 0, 4,
    2, 27, 14, 5, 20, 9,
    22, 18, 11, 3, 25, 7,
    15, 6, 26, 19, 12, 1,
    40, 51, 30, 36, 46, 54,
    29, 39, 50, 44, 32, 47,
    43, 48, 38, 55, 33, 52,
    45, 41, 49, 35, 28, 31
]
ROTATIONS = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]


def PC_1(key: List[int]):
    return list(map(lambda x: key[x], __pc1))


def PC_2(key: List[int]):
    return list(map(lambda x: key[x], __pc2))


def get_sub_key(key: List[int]):
    key = PC_1(key)  # PC-1置换
    L, R = key[:28], key[28:]  # 分成两半

    skeys = []

    for i in range(16):
        for j in range(ROTATIONS[i]):  # 根据轮次左移
            L = L[1:] + L[:1]
            R = R[1:] + R[:1]

        skeys.append(PC_2(L + R))  # PC-2置换

    return skeys


__expansion_table = [
    31, 0, 1, 2, 3, 4,
    3, 4, 5, 6, 7, 8,
    7, 8, 9, 10, 11, 12,
    11, 12, 13, 14, 15, 16,
    15, 16, 17, 18, 19, 20,
    19, 20, 21, 22, 23, 24,
    23, 24, 25, 26, 27, 28,
    27, 28, 29, 30, 31, 0
]
__sbox = [
    # S1
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
     0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
     4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
     15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],

    # S2
    [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
     3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
     0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
     13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],

    # S3
    [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
     13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
     13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
     1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],

    # S4
    [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
     13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
     10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
     3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],

    # S5
    [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
     14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
     4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
     11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],

    # S6
    [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
     10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
     9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
     4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],

    # S7
    [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
     13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
     1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
     6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],

    # S8
    [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
     1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
     7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
     2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
]
__p = [
    15, 6, 19, 20, 28, 11,
    27, 16, 0, 14, 22, 25,
    4, 17, 30, 9, 1, 7,
    23, 13, 31, 26, 2, 8,
    18, 12, 29, 5, 21, 10,
    3, 24
]


def EP(data: List[int]):  # 扩展置换
    return list(map(lambda x: data[x], __expansion_table))


def P(data: List[int]):  # P置换
    return list(map(lambda x: data[x], __p))


def F(index: int, R: List[int], skeys: List[List[int]]):
    """
    index: 代表这是第几轮
    R: 输入数据
    skeys: 子密钥数组
    """
    R = EP(R)  # 扩展置换

    B = [R[:6], R[6:12], R[12:18], R[18:24], R[24:30], R[30:36], R[36:42], R[42:]]  # 分成八份

    Bn = [0] * 32
    pos = 0
    for i in range(8):
        #  计算该使用S盒的行坐标和列坐标
        row = (B[i][0] << 1) + B[i][5]
        col = (B[i][1] << 3) + (B[i][2] << 2) + (B[i][3] << 1) + B[i][4]

        sb = __sbox[i][(row << 4) + col]

        Bn[pos + 0] = (sb & 8) >> 3  # 四位输出
        Bn[pos + 1] = (sb & 4) >> 2
        Bn[pos + 2] = (sb & 2) >> 1
        Bn[pos + 3] = (sb & 1)

        pos += 4
    R = P(Bn)
    return R


_FP = [
    39, 7, 47, 15, 55, 23, 63, 31,
    38, 6, 46, 14, 54, 22, 62, 30,
    37, 5, 45, 13, 53, 21, 61, 29,
    36, 4, 44, 12, 52, 20, 60, 28,
    35, 3, 43, 11, 51, 19, 59, 27,
    34, 2, 42, 10, 50, 18, 58, 26,
    33, 1, 41, 9, 49, 17, 57, 25,
    32, 0, 40, 8, 48, 16, 56, 24
]


def FP(plain: List[int]):
    return list(map(lambda x: plain[x], _FP))


key = b'********'
plain = b'********'

# 转为二进制数组
key = reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in key])
plain = reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in plain])
skeys = get_sub_key(key)

block = IP(plain)

L, R = block[:32], block[32:]
for i in range(16):
    tpR = R[:]
    R = F(i, R, skeys)
    R = list(map(lambda x, y: x ^ y, R, L))
    L = tpR
block = R + L
block = FP(block)
enc = bytes([int(''.join(map(str, block[i * 8:(i + 1) * 8])), 2) for i in range(8)])
print(enc)  # b'1qSH\xf4\xcf\xd5\x92'
分析
本题看上去好像就是一个DES算法，但是却没有给出密钥，显然如果是真正的DES且没有泄漏信息的情况，我们是没办法破解的，我们可以考虑使用比较一下代码和DES算法代码的区别。

#例题2的DES片段
def F(index: int, R: List[int], skeys: List[List[int]]):
    """
    index: 代表这是第几轮
    R: 输入数据
    skeys: 子密钥数组
    """
    R = EP(R)  # 扩展置换

    B = [R[:6], R[6:12], R[12:18], R[18:24], R[24:30], R[30:36], R[36:42], R[42:]]  # 分成八份

    Bn = [0] * 32
    pos = 0
#例题1的DES片段
def F(index: int, R: List[int], skeys: List[List[int]]):
    """
    index: 代表这是第几轮
    R: 输入数据
    skeys: 子密钥数组
    """
    R = EP(R)  # 扩展置换
    R = list(map(lambda x, y: x ^ y, R, skeys[index]))  # 异或     #这一行和子密钥进行异或是例题2所没有的

    B = [R[:6], R[6:12], R[12:18], R[18:24], R[24:30], R[30:36], R[36:42], R[42:]]  # 分成八份

    Bn = [0] * 32
    pos = 0
可以发现在加密函数F函数中，R并没有和子密钥进行异或，也就是说此时根本不需要密钥，只是对原文进行了一些置换、异或等操作，我们可以直接正常解密即可。

EXP
from operator import add
from typing import List
from functools import reduce

_IP = [57, 49, 41, 33, 25, 17, 9,  1,
    59, 51, 43, 35, 27, 19, 11, 3,
    61, 53, 45, 37, 29, 21, 13, 5,
    63, 55, 47, 39, 31, 23, 15, 7,
    56, 48, 40, 32, 24, 16, 8,  0,
    58, 50, 42, 34, 26, 18, 10, 2,
    60, 52, 44, 36, 28, 20, 12, 4,
    62, 54, 46, 38, 30, 22, 14, 6
]

def IP(plain: List[int]):
    return list(map(lambda x: plain[x], _IP))

__pc1 = [56, 48, 40, 32, 24, 16,  8,
    0, 57, 49, 41, 33, 25, 17,
    9,  1, 58, 50, 42, 34, 26,
    18, 10,  2, 59, 51, 43, 35,
    62, 54, 46, 38, 30, 22, 14,
    6, 61, 53, 45, 37, 29, 21,
    13,  5, 60, 52, 44, 36, 28,
    20, 12,  4, 27, 19, 11,  3
]

__pc2 = [
    13, 16, 10, 23,  0,  4,
    2, 27, 14,  5, 20,  9,
    22, 18, 11,  3, 25,  7,
    15,  6, 26, 19, 12,  1,
    40, 51, 30, 36, 46, 54,
    29, 39, 50, 44, 32, 47,
    43, 48, 38, 55, 33, 52,
    45, 41, 49, 35, 28, 31
]
ROTATIONS = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

def PC_1(key: List[int]):
    return list(map(lambda x: key[x], __pc1))

def PC_2(key: List[int]):
    return list(map(lambda x: key[x], __pc2))

def get_sub_key(key: List[int]):
    key = PC_1(key) # PC-1置换
    L, R = key[:28], key[28:] # 分成两半

    skeys = []

    for i in range(16):
        for j in range(ROTATIONS[i]): # 根据轮次左移
            L = L[1:] + L[:1]
            R = R[1:] + R[:1]

        skeys.append(PC_2(L+R)) # PC-2置换
    
    return skeys

__expansion_table = [
    31,  0,  1,  2,  3,  4,
    3,  4,  5,  6,  7,  8,
    7,  8,  9, 10, 11, 12,
    11, 12, 13, 14, 15, 16,
    15, 16, 17, 18, 19, 20,
    19, 20, 21, 22, 23, 24,
    23, 24, 25, 26, 27, 28,
    27, 28, 29, 30, 31,  0
]
__sbox = [
        # S1
        [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
        0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
        4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
        15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],

        # S2
        [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
        3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
        0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
        13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],

        # S3
        [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
        13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
        13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
        1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],

        # S4
        [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
        13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
        10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
        3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],

        # S5
        [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
        14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
        4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
        11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],

        # S6
        [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
        10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
        9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
        4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],

        # S7
        [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
        13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
        1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
        6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],

        # S8
        [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
        1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
        7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
        2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
    ]
__p = [
    15, 6, 19, 20, 28, 11,
    27, 16, 0, 14, 22, 25,
    4, 17, 30, 9, 1, 7,
    23,13, 31, 26, 2, 8,
    18, 12, 29, 5, 21, 10,
    3, 24
]

def EP(data: List[int]):  # 扩展置换
    return list(map(lambda x: data[x], __expansion_table))

def P(data: List[int]):  # P置换
    return list(map(lambda x: data[x], __p))

def F(index: int, R: List[int], skeys: List[List[int]]):
    """
    index: 代表这是第几轮
    R: 输入数据
    skeys: 子密钥数组
    """
    R = EP(R)  # 扩展置换

    B = [R[:6], R[6:12], R[12:18], R[18:24], R[24:30], R[30:36], R[36:42], R[42:]]  # 分成八份

    Bn = [0] * 32
    pos = 0
    for i in range(8):
        #  计算该使用S盒的行坐标和列坐标
        row = (B[i][0] << 1) + B[i][5]
        col = (B[i][1] << 3) + (B[i][2] << 2) + (B[i][3] << 1) + B[i][4]

        sb = __sbox[i][(row << 4) + col]

        Bn[pos + 0] = (sb & 8) >> 3  # 四位输出
        Bn[pos + 1] = (sb & 4) >> 2
        Bn[pos + 2] = (sb & 2) >> 1
        Bn[pos + 3] = (sb & 1)

        pos += 4
    R = P(Bn)
    return R

_FP = [
    39,  7, 47, 15, 55, 23, 63, 31,
    38,  6, 46, 14, 54, 22, 62, 30,
    37,  5, 45, 13, 53, 21, 61, 29,
    36,  4, 44, 12, 52, 20, 60, 28,
    35,  3, 43, 11, 51, 19, 59, 27,
    34,  2, 42, 10, 50, 18, 58, 26,
    33,  1, 41,  9, 49, 17, 57, 25,
    32,  0, 40,  8, 48, 16, 56, 24
]

def FP(plain: List[int]):
    return list(map(lambda x: plain[x], _FP))


enc = b'1qSH\xf4\xcf\xd5\x92'

# 转为二进制数组
enc = reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in enc])
skeys = []
block = IP(enc)

L, R = block[:32], block[32:]
for i in range(15, -1, -1):
    tpR = R[:]
    R = F(i, R, skeys)
    R = list(map(lambda x, y: x ^ y, R, L))
    L = tpR
block = R + L
block = FP(block)
plain = bytes([int(''.join(map(str,block[i*8:(i+1)*8])),2) for i in range(8)])
    
print(b'NSSCTF{%s}' % plain)
例题3：子密钥泄露
1
from operator import add
2
from typing import List
3
from functools import reduce
4
​
5
_IP = [57, 49, 41, 33, 25, 17, 9, 1,
6
       59, 51, 43, 35, 27, 19, 11, 3,
7
       61, 53, 45, 37, 29, 21, 13, 5,
8
       63, 55, 47, 39, 31, 23, 15, 7,
9
       56, 48, 40, 32, 24, 16, 8, 0,
10
       58, 50, 42, 34, 26, 18, 10, 2,
11
       60, 52, 44, 36, 28, 20, 12, 4,
12
       62, 54, 46, 38, 30, 22, 14, 6
13
       ]
14
​
15
​
16
def IP(plain: List[int]):
17
    return list(map(lambda x: plain[x], _IP))
18
​
19
​
20
__pc1 = [56, 48, 40, 32, 24, 16, 8,
21
         0, 57, 49, 41, 33, 25, 17,
22
         9, 1, 58, 50, 42, 34, 26,
23
         18, 10, 2, 59, 51, 43, 35,
24
         62, 54, 46, 38, 30, 22, 14,
25
         6, 61, 53, 45, 37, 29, 21,
26
         13, 5, 60, 52, 44, 36, 28,
27
         20, 12, 4, 27, 19, 11, 3
28
         ]
29
​
30
__pc2 = [
31
    13, 16, 10, 23, 0, 4,
32
    2, 27, 14, 5, 20, 9,
33
    22, 18, 11, 3, 25, 7,
34
    15, 6, 26, 19, 12, 1,
35
    40, 51, 30, 36, 46, 54,
36
    29, 39, 50, 44, 32, 47,
37
    43, 48, 38, 55, 33, 52,
38
    45, 41, 49, 35, 28, 31
39
]
40
ROTATIONS = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
41
​
42
​
43
def PC_1(key: List[int]):
44
    return list(map(lambda x: key[x], __pc1))
45
​
46
​
47
def PC_2(key: List[int]):
48
    return list(map(lambda x: key[x], __pc2))
49
​
50
​
51
def get_sub_key(key: List[int]):
52
    key = PC_1(key)  # PC-1置换
53
    L, R = key[:28], key[28:]  # 分成两半
54
    print(f'L = {L}')
55
    print(f'R = {R[:20]}')
56
​
57
    skeys = []
58
​
59
    for i in range(16):
60
        for j in range(ROTATIONS[i]):  # 根据轮次左移
61
            L = L[1:] + L[:1]
62
            R = R[1:] + R[:1]
63
​
64
        skeys.append(PC_2(L + R))  # PC-2置换
65
​
66
    return skeys
67
​
68
​
69
__expansion_table = [
70
    31, 0, 1, 2, 3, 4,
71
    3, 4, 5, 6, 7, 8,
72
    7, 8, 9, 10, 11, 12,
73
    11, 12, 13, 14, 15, 16,
74
    15, 16, 17, 18, 19, 20,
75
    19, 20, 21, 22, 23, 24,
76
    23, 24, 25, 26, 27, 28,
77
    27, 28, 29, 30, 31, 0
78
]
79
__sbox = [
80
    # S1
81
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
82
     0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
83
     4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
84
     15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],
85
​
86
    # S2
87
    [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
88
     3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
89
     0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
90
     13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],
91
​
92
    # S3
93
    [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
94
     13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
95
     13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
96
     1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],
97
​
98
    # S4
99
    [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
100
     13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
101
     10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
102
     3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],
103
​
104
    # S5
105
    [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
106
     14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
107
     4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
108
     11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],
109
​
110
    # S6
111
    [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
112
     10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
113
     9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
114
     4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],
115
​
116
    # S7
117
    [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
118
     13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
119
     1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
120
     6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],
121
​
122
    # S8
123
    [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
124
     1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
125
     7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
126
     2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
127
]
128
__p = [
129
    15, 6, 19, 20, 28, 11,
130
    27, 16, 0, 14, 22, 25,
131
    4, 17, 30, 9, 1, 7,
132
    23, 13, 31, 26, 2, 8,
133
    18, 12, 29, 5, 21, 10,
134
    3, 24
135
]
136
​
137
​
138
def EP(data: List[int]):  # 扩展置换
139
    return list(map(lambda x: data[x], __expansion_table))
140
​
141
​
142
def P(data: List[int]):  # P置换
143
    return list(map(lambda x: data[x], __p))
144
​
145
​
146
def F(index: int, R: List[int], skeys: List[List[int]]):
147
    """
148
    index: 代表这是第几轮
149
    R: 输入数据
150
    skeys: 子密钥数组
151
    """
152
    R = EP(R)  # 扩展置换
153
    R = list(map(lambda x, y: x ^ y, R, skeys[index]))  # 异或
154
​
155
    B = [R[:6], R[6:12], R[12:18], R[18:24], R[24:30], R[30:36], R[36:42], R[42:]]  # 分成八份
156
​
157
    Bn = [0] * 32
158
    pos = 0
159
    for i in range(8):
160
        #  计算该使用S盒的行坐标和列坐标
161
        row = (B[i][0] << 1) + B[i][5]
162
        col = (B[i][1] << 3) + (B[i][2] << 2) + (B[i][3] << 1) + B[i][4]
163
​
164
        sb = __sbox[i][(row << 4) + col]
165
​
166
        Bn[pos + 0] = (sb & 8) >> 3  # 四位输出
167
        Bn[pos + 1] = (sb & 4) >> 2
168
        Bn[pos + 2] = (sb & 2) >> 1
169
        Bn[pos + 3] = (sb & 1)
170
​
171
        pos += 4
172
    R = P(Bn)
173
    return R
174
​
175
​
176
_FP = [
177
    39, 7, 47, 15, 55, 23, 63, 31,
178
    38, 6, 46, 14, 54, 22, 62, 30,
179
    37, 5, 45, 13, 53, 21, 61, 29,
180
    36, 4, 44, 12, 52, 20, 60, 28,
181
    35, 3, 43, 11, 51, 19, 59, 27,
182
    34, 2, 42, 10, 50, 18, 58, 26,
183
    33, 1, 41, 9, 49, 17, 57, 25,
184
    32, 0, 40, 8, 48, 16, 56, 24
185
]
186
​
187
​
188
def FP(plain: List[int]):
189
    return list(map(lambda x: plain[x], _FP))
190
​
191
​
192
key = b'********'
193
plain = b'********'
194
flag = b'NSSCTF{%s}' % (plain)
195
# 转为二进制数组
196
key = reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in key])
197
plain = reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in plain])
198
skeys = get_sub_key(key)
199
​
200
block = IP(plain)
201
​
202
L, R = block[:32], block[32:]
203
for i in range(16):
204
    tpR = R[:]
205
    R = F(i, R, skeys)
206
    R = list(map(lambda x, y: x ^ y, R, L))
207
    L = tpR
208
block = R + L
209
block = FP(block)
210
enc = bytes([int(''.join(map(str, block[i * 8:(i + 1) * 8])), 2) for i in range(8)])
211
​
212
print(enc)
213
​
214
​
215
L = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1]
216
R = [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
217
b'\x1d\xe8\xd1\xc8\x95{]\xa0'
分析
此题给出了L和R两个数组，搜索发现是在：

1
def get_sub_key(key: List[int]):
2
    key = PC_1(key)  # PC-1置换
3
    L, R = key[:28], key[28:]  # 分成两半
4
    print(f'L = {L}')
5
    print(f'R = {R[:20]}')
生成子密钥时给出，并且R只给了前面20位，我们发现这里的L和R就是原始密钥经过PC-1置换后的结果，如果我们能够得到完整的L和R便可以从这里往后继续运行生成子密钥，从而解密消息。

那么这里R缺少了8位，显然这八位的排列可能性有2^8 = 256种，这个范围很小，我们可以考虑进行爆破即可。

EXP
1
from operator import add
2
from typing import List
3
from functools import reduce
4
​
5
_IP = [57, 49, 41, 33, 25, 17, 9, 1,
6
       59, 51, 43, 35, 27, 19, 11, 3,
7
       61, 53, 45, 37, 29, 21, 13, 5,
8
       63, 55, 47, 39, 31, 23, 15, 7,
9
       56, 48, 40, 32, 24, 16, 8, 0,
10
       58, 50, 42, 34, 26, 18, 10, 2,
11
       60, 52, 44, 36, 28, 20, 12, 4,
12
       62, 54, 46, 38, 30, 22, 14, 6
13
       ]
14
​
15
​
16
def IP(plain: List[int]):
17
    return list(map(lambda x: plain[x], _IP))
18
​
19
​
20
__pc1 = [56, 48, 40, 32, 24, 16, 8,
21
         0, 57, 49, 41, 33, 25, 17,
22
         9, 1, 58, 50, 42, 34, 26,
23
         18, 10, 2, 59, 51, 43, 35,
24
         62, 54, 46, 38, 30, 22, 14,
25
         6, 61, 53, 45, 37, 29, 21,
26
         13, 5, 60, 52, 44, 36, 28,
27
         20, 12, 4, 27, 19, 11, 3
28
         ]
29
​
30
__pc2 = [
31
    13, 16, 10, 23, 0, 4,
32
    2, 27, 14, 5, 20, 9,
33
    22, 18, 11, 3, 25, 7,
34
    15, 6, 26, 19, 12, 1,
35
    40, 51, 30, 36, 46, 54,
36
    29, 39, 50, 44, 32, 47,
37
    43, 48, 38, 55, 33, 52,
38
    45, 41, 49, 35, 28, 31
39
]
40
ROTATIONS = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
41
​
42
​
43
def PC_1(key: List[int]):
44
    return list(map(lambda x: key[x], __pc1))
45
​
46
​
47
def PC_2(key: List[int]):
48
    return list(map(lambda x: key[x], __pc2))
49
​
50
​
51
def get_sub_key(L, R):
52
    # key = PC_1(key) # PC-1置换
53
    # L, R = key[:28], key[28:] # 分成两半
54
    # print(f'L = {L}')
55
    # print(f'R = {R[:20]}')
56
​
57
    skeys = []
58
​
59
    for i in range(16):
60
        for j in range(ROTATIONS[i]):  # 根据轮次左移
61
            L = L[1:] + L[:1]
62
            R = R[1:] + R[:1]
63
​
64
        skeys.append(PC_2(L + R))  # PC-2置换
65
​
66
    return skeys
67
​
68
​
69
__expansion_table = [
70
    31, 0, 1, 2, 3, 4,
71
    3, 4, 5, 6, 7, 8,
72
    7, 8, 9, 10, 11, 12,
73
    11, 12, 13, 14, 15, 16,
74
    15, 16, 17, 18, 19, 20,
75
    19, 20, 21, 22, 23, 24,
76
    23, 24, 25, 26, 27, 28,
77
    27, 28, 29, 30, 31, 0
78
]
79
__sbox = [
80
    # S1
81
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
82
     0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
83
     4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
84
     15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],
85
​
86
    # S2
87
    [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
88
     3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
89
     0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
90
     13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],
91
​
92
    # S3
93
    [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
94
     13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
95
     13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
96
     1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],
97
​
98
    # S4
99
    [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
100
     13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
101
     10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
102
     3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],
103
​
104
    # S5
105
    [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
106
     14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
107
     4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
108
     11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],
109
​
110
    # S6
111
    [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
112
     10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
113
     9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
114
     4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],
115
​
116
    # S7
117
    [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
118
     13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
119
     1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
120
     6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],
121
​
122
    # S8
123
    [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
124
     1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
125
     7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
126
     2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
127
]
128
__p = [
129
    15, 6, 19, 20, 28, 11,
130
    27, 16, 0, 14, 22, 25,
131
    4, 17, 30, 9, 1, 7,
132
    23, 13, 31, 26, 2, 8,
133
    18, 12, 29, 5, 21, 10,
134
    3, 24
135
]
136
​
137
​
138
def EP(data: List[int]):  # 扩展置换
139
    return list(map(lambda x: data[x], __expansion_table))
140
​
141
​
142
def P(data: List[int]):  # P置换
143
    return list(map(lambda x: data[x], __p))
144
​
145
​
146
def F(index: int, R: List[int], skeys: List[List[int]]):
147
    """
148
    index: 代表这是第几轮
149
    R: 输入数据
150
    skeys: 子密钥数组
151
    """
152
    R = EP(R)  # 扩展置换
153
    R = list(map(lambda x, y: x ^ y, R, skeys[index]))  # 异或
154
​
155
    B = [R[:6], R[6:12], R[12:18], R[18:24], R[24:30], R[30:36], R[36:42], R[42:]]  # 分成八份
156
​
157
    Bn = [0] * 32
158
    pos = 0
159
    for i in range(8):
160
        #  计算该使用S盒的行坐标和列坐标
161
        row = (B[i][0] << 1) + B[i][5]
162
        col = (B[i][1] << 3) + (B[i][2] << 2) + (B[i][3] << 1) + B[i][4]
163
​
164
        sb = __sbox[i][(row << 4) + col]
165
​
166
        Bn[pos + 0] = (sb & 8) >> 3  # 四位输出
167
        Bn[pos + 1] = (sb & 4) >> 2
168
        Bn[pos + 2] = (sb & 2) >> 1
169
        Bn[pos + 3] = (sb & 1)
170
​
171
        pos += 4
172
    R = P(Bn)
173
    return R
174
​
175
​
176
_FP = [
177
    39, 7, 47, 15, 55, 23, 63, 31,
178
    38, 6, 46, 14, 54, 22, 62, 30,
179
    37, 5, 45, 13, 53, 21, 61, 29,
180
    36, 4, 44, 12, 52, 20, 60, 28,
181
    35, 3, 43, 11, 51, 19, 59, 27,
182
    34, 2, 42, 10, 50, 18, 58, 26,
183
    33, 1, 41, 9, 49, 17, 57, 25,
184
    32, 0, 40, 8, 48, 16, 56, 24
185
]
186
​
187
​
188
def FP(plain: List[int]):
189
    return list(map(lambda x: plain[x], _FP))
190
​
191
​
192
enc = b'\x1d\xe8\xd1\xc8\x95{]\xa0'
193
enc = reduce(add, [list(map(int, bin(i)[2:].zfill(8))) for i in enc])
194
​
195
LL = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1]
196
RR = [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
197
​
198
for i in range(2 ** 8):
199
    R = RR + list(map(int, bin(i)[2:].zfill(8)))
200
    skeys = get_sub_key(LL, R)
201
​
202
    block = IP(enc)
203
​
204
    L, R = block[:32], block[32:]
205
    for i in range(15, -1, -1):
206
        tpR = R[:]
207
        R = F(i, R, skeys)
208
        R = list(map(lambda x, y: x ^ y, R, L))
209
        L = tpR
210
    block = R + L
211
    block = FP(block)
212
    plain = bytes([int(''.join(map(str, block[i * 8:(i + 1) * 8])), 2) for i in range(8)])
213
​
214
    flag = b'NSSCTF{%s}' % (plain)
215
    print(flag)
例题4：子密钥泄露
import pyDes

flag = b'NSSCTF{******}'
des = pyDes.des('********', padmode=pyDes.PAD_PKCS5)
print(des.encrypt(flag))
print(des.Kn)


b'3\xb3\xdc\xbfkg\x1b\xceG!\x08\x16\xf6i\x0c\xbd\xde_\xe7#\xe2\x99\xe7\xf0\xd9\x02\xd6Hi=1='
[[1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]]
#Kn 是 DES 的子密钥矩阵，由 16 轮密钥组成，每一轮的密钥是一个 48 比#特的二进制列表（0 或 1）。
#这些密钥显然不是由 pyDes 模块的密钥生成机制产生的，而是通过某种方式
#预先生成的（可能通过攻击或已知密钥调试）。
分析
它就是存储子密钥的数组，所以当子密钥全部泄漏的时候，原始密钥是什么已经不重要了，因为原始密钥的作用就是来生成这些子密钥，所以我们可以直接利用这些泄漏的子密钥来解密flag密文。

EXP
1
import pyDes
2
​
3
enc = b'3\xb3\xdc\xbfkg\x1b\xceG!\x08\x16\xf6i\x0c\xbd\xde_\xe7#\xe2\x99\xe7\xf0\xd9\x02\xd6Hi=1='
4
Kn = [[1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]]
5
​
6
des = pyDes.des('11111111', padmode=pyDes.PAD_PKCS5)
7
#密钥设置为 '11111111'（字符串），显然与实际解密没有直接关系，因为程序随后直接覆盖了 Kn。
8
des.Kn = Kn
9
print(des.decrypt(enc))
10
#pyDes.des 的默认实现中，Kn 是从提供的 64 比特密钥动态生成的子密钥（基于标准 DES 密钥调度算法）。
11
#在这里，Kn 被人为覆盖，导致密钥调度机制被修改，从而使用了自定义的轮密钥。
例题5：子密钥泄露
import pyDes

flag = b'NSSCTF{******}'
des = pyDes.des('********', padmode=pyDes.PAD_PKCS5)
print(des.encrypt(flag))
print(des.Kn[7])


b'\xed\xb7H\xa8zL\xb5\xff\xb2g\x1c<\x17G^\xda\xd4\xb2\x84X\xb4\x92\x18I\xaf9\xcd\xce\xc1\x182"'
[0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0]
分析
和上一题相比，本题只输出了des.Kn的第7组，显然本题要求我们对子密钥生成进行逆向操作恢复其他子密钥

我们再来回顾一下DES的子密钥是如何生成的

将64位密钥去掉8个校验位，用密钥置换PC-1置换剩下的56位密钥。

将56位分成前28位C0和后28位D0。

根据轮数，这两部分分别循环左移1位或2位

移动后，将两部分合并成56位后通过压缩置换PC-2后得到48位子密钥。

原始的密钥会经过置换后留下56位，这正是我们在P3中遇到的L,R，然后会继续进行位移操作，最后还会经过一次置换得到48位子密钥，这正是本题中的Kn[7]，我们知道对于位移、置换等操作我们很容易进行逆向，但问题是这是一个丢失信息的置换，最后一次置换将56位变成了48位，而我们无法知道那8位究竟是什么，如果无法得到56位密钥就无法去生成其他的子密钥。所以除了逆向这些操作之外，我们还需要对这8位内容进行爆破处理。

EXP
1
import pyDes
2
​
3
enc = b'\xed\xb7H\xa8zL\xb5\xff\xb2g\x1c<\x17G^\xda\xd4\xb2\x84X\xb4\x92\x18I\xaf9\xcd\xce\xc1\x182"'
4
Kn = [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0]
5
​
6
# Despermuted[48]
7
PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
8
# DesRotations
9
movnum = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]#对应16轮中每一轮的循环左移位数
10
​
11
def gen_key(C1,D1,k):#C1 和 D1：分别是当前轮次的左半部分和右半部分密钥（长度各为 28 位）,k：当前轮次指定的循环左移位数。
12
    tempc=C1
13
    tempd=D1
14
    for i in range(k):
15
        tempc = tempc[1:] + tempc[:1]
16
        tempd = tempd[1:] + tempd[:1]
17
    tempCD1=tempc+tempd
18
    tempkey=[]#本轮生成的子密钥
19
    for i in range(len(PC2)):
20
        tempkey.append(tempCD1[PC2[i]-1])
21
    return (tempkey,tempCD1)#轮运算得到下一轮子密钥
22
​
23
def re_gen_key(C1,D1):
24
    tempc=C1[-1:]+C1[:-1]
25
    tempd=D1[-1:]+D1[:-1]
26
    tempCD1=tempc+tempd
27
    return tempCD1 #轮运算得到上一轮CD
28
​
29
d = pyDes.des("0"*8)
30
CD = ['*']*56
31
​
32
# 获得PC-2置换前的数据，即56位密钥，当然其中有8位我们依然是未知的
33
for i in range(len(PC2)):
34
    CD[PC2[i]-1] = Kn[i]
35
​
36
for i in range(256):
37
    # 遍历2^8种可能
38
    temp = CD[::]
39
    bi = bin(i)[2:].zfill(8)#这里的256表示所有可能的8位二进制数（即0到255）。bin(i)[2:].zfill(8)会生成一个从00000000到11111111的8位二进制数。
40
    tot = 0
41
    for j in range(len(temp)):
42
        if temp[j] == '*':#遍历 temp 中的每一个位置，用来检查当前位是否是 "*"，即是否是未知或缺失的位。
43
            temp[j] = int(bi[tot])  # 将丢失的8位填充进去
44
            tot += 1
45
​
46
    # 回到初始密钥
47
    for j in range(sum(movnum[:8])):  # 逆向循环左移操作，回到最初的密钥形态;sum(movnum[:8])：计算前 8 轮的总左移次数
48
        temp = re_gen_key(temp[:28],temp[28:])
49
​
50
    tempK=[]
51
    Z = temp
52
    # 16轮迭代重新生成新的子密钥
53
    for j in range(16):
54
        tempx=gen_key(Z[:28],Z[28:],movnum[j])
55
        tempK.append(tempx[0])
56
        Z=tempx[1]
57
    # tempx[0]：访问元组的第一个元素，tempkey，也就是当前轮生成的
58
    # 子密钥，并将其添加到tempK列表中。
59
    # tempx[1]：访问元组的第二个元素，tempCD1，也就是更新后的C和D部分，并将其赋值给Z，以便进入下一轮的计算。
60
    d.Kn = tempK
61
    print(d.decrypt(enc))  # 使用子密钥解密消息
最终我们会获得256组输出，我们只需要在这些输出种找到包含NSSCTF的字符串即可，当然你也可以对输出经过字符串过滤使其包含特定字符串才输出。

AES
例题1
1
r_con = (0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,0x80, 0x1B, 0x36)
2
s_box = [129, 135, 43, 178, 226, 117, 54, 185, 67, 201, 34, 190, 121, 133, 125, 64, 69, 203, 147, 87, 131, 155, 148, 144, 197, 3, 162, 160, 247, 41, 179, 181, 184, 163, 142, 27, 192, 23, 243, 208, 204, 195, 105, 50, 80, 74, 146, 62, 66, 251, 104, 118, 89, 8, 139, 136, 140, 171, 235, 227, 128, 211, 106, 42, 188, 17, 79, 231, 154, 45, 255, 59, 157, 193, 254, 83, 127, 198, 116, 32, 212, 35, 233, 122, 49, 4, 194, 228, 249, 202, 229, 200, 78, 82, 253, 77, 96, 68, 152, 219, 91, 92, 46, 213, 39, 98, 103, 102, 119, 234, 85, 246, 236, 238, 242, 1, 150, 9, 182, 97, 22, 47, 221, 99, 223, 225, 224, 109, 240, 38, 126, 245, 63, 33, 176, 26, 21, 71, 58, 15, 53, 123, 6, 158, 232, 156, 55, 108, 25, 149, 191, 187, 0, 145, 20, 10, 214, 110, 241, 166, 18, 94, 137, 143, 199, 12, 14, 222, 65, 138, 164, 72, 159, 61, 95, 37, 111, 206, 141, 2, 209, 84, 217, 252, 28, 88, 248, 130, 44, 239, 60, 196, 24, 169, 153, 205, 5, 170, 183, 52, 81, 124, 244, 134, 11, 120, 250, 70, 218, 189, 16, 220, 173, 36, 101, 172, 115, 180, 75, 216, 40, 86, 51, 113, 151, 112, 100, 114, 31, 215, 174, 165, 19, 177, 76, 207, 107, 73, 13, 175, 237, 167, 132, 186, 161, 48, 7, 90, 93, 30, 210, 29, 230, 57, 168, 56]
3
​
4
def xor_bytes(a, b):
5
    return bytes(i^j for i, j in zip(a, b))
6
​
7
def add_round_key(s, k):
8
    for i in range(4):
9
        for j in range(4):
10
            s[i][j] ^= k[i][j]
11
​
12
def sub_bytes(s):
13
    for i in range(4):
14
        for j in range(4):
15
            s[i][j] = s_box[s[i][j]]
16
​
17
def shift_rows(s):
18
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
19
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
20
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]
21
​
22
# 参考 http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
23
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)
24
​
25
def mix_single_column(a):
26
    # see Sec 4.1.2 in The Design of Rijndael
27
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
28
    u = a[0]
29
    a[0] ^= t ^ xtime(a[0] ^ a[1])
30
    a[1] ^= t ^ xtime(a[1] ^ a[2])
31
    a[2] ^= t ^ xtime(a[2] ^ a[3])
32
    a[3] ^= t ^ xtime(a[3] ^ u)
33
​
34
def mix_columns(s):
35
    for i in range(4):
36
        mix_single_column(s[i])
37
​
38
def _expand_key(s):
39
    for i in range(10):
40
        word = list(s[-1])  # 取得最后一列
41
        word.append(word.pop(0)) # 将首位移动到最后
42
        word = [s_box[b] for b in word]  # SubBytes操作
43
        word[0] ^= r_con[i]  # 和异或表内数据异或
44
​
45
        s.append(xor_bytes(word, s[-4]))  # 得到新的子密钥
46
        s.append(xor_bytes(s[-1], s[-4]))  # 因为直接在s中添加，所以本该和上一轮第二列异或的位置还是-4
47
        s.append(xor_bytes(s[-1], s[-4]))
48
        s.append(xor_bytes(s[-1], s[-4]))
49
​
50
    return [s[4*i : 4*(i+1)] for i in range(len(s) // 4)]
51
​
52
def bytes2matrix(text):
53
    """ Converts a 16-byte array into a 4x4 matrix.  """
54
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]
55
​
56
key = b'1234567812345678'
57
plain = b'NSSCTF{********}'
58
skeys = _expand_key(bytes2matrix(key))
59
plain = bytes2matrix(plain)
60
​
61
add_round_key(plain, skeys[0])
62
​
63
for i in range(1, 10):
64
    sub_bytes(plain)
65
    shift_rows(plain)
66
    mix_columns(plain)
67
    add_round_key(plain, skeys[i])
68
​
69
sub_bytes(plain)
70
shift_rows(plain)
71
add_round_key(plain, skeys[-1])
72
​
73
enc = bytes(plain[0]+plain[1]+plain[2]+plain[3])
74
print(enc)  # b'\xddd\xe1Q\xfe\x81\xf8\x83wa1\xa5\tH|\xee'
分析
本题需要我们解密AES，在解密介绍中我们已经说明了每个函数的逆函数，所以解密我们只要将每一步倒过来执行其逆函数即可，不过注意本题中s_box和标准的s_box不一样，所以在解密的时候我们的inv_s_box也需要重新生成而不能使用标准库中的表

生成inv_s_box也很简单，我们只需要记录每一个s_box[i]和i的关系即可

inv_s_box = [0 for i in range(256)]
for i in range(256):
    inv_s_box[s_box[i]] = i
EXP 
r_con = (0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,0x80, 0x1B, 0x36)
s_box = [129, 135, 43, 178, 226, 117, 54, 185, 67, 201, 34, 190, 121, 133, 125, 64, 69, 203, 147, 87, 131, 155, 148, 144, 197, 3, 162, 160, 247, 41, 179, 181, 184, 163, 142, 27, 192, 23, 243, 208, 204, 195, 105, 50, 80, 74, 146, 62, 66, 251, 104, 118, 89, 8, 139, 136, 140, 171, 235, 227, 128, 211, 106, 42, 188, 17, 79, 231, 154, 45, 255, 59, 157, 193, 254, 83, 127, 198, 116, 32, 212, 35, 233, 122, 49, 4, 194, 228, 249, 202, 229, 200, 78, 82, 253, 77, 96, 68, 152, 219, 91, 92, 46, 213, 39, 98, 103, 102, 119, 234, 85, 246, 236, 238, 242, 1, 150, 9, 182, 97, 22, 47, 221, 99, 223, 225, 224, 109, 240, 38, 126, 245, 63, 33, 176, 26, 21, 71, 58, 15, 53, 123, 6, 158, 232, 156, 55, 108, 25, 149, 191, 187, 0, 145, 20, 10, 214, 110, 241, 166, 18, 94, 137, 143, 199, 12, 14, 222, 65, 138, 164, 72, 159, 61, 95, 37, 111, 206, 141, 2, 209, 84, 217, 252, 28, 88, 248, 130, 44, 239, 60, 196, 24, 169, 153, 205, 5, 170, 183, 52, 81, 124, 244, 134, 11, 120, 250, 70, 218, 189, 16, 220, 173, 36, 101, 172, 115, 180, 75, 216, 40, 86, 51, 113, 151, 112, 100, 114, 31, 215, 174, 165, 19, 177, 76, 207, 107, 73, 13, 175, 237, 167, 132, 186, 161, 48, 7, 90, 93, 30, 210, 29, 230, 57, 168, 56]

inv_s_box = [0 for i in range(256)]
for i in range(256):
    inv_s_box[s_box[i]] = i
    
def xor_bytes(a, b):
    return bytes(i^j for i, j in zip(a, b))

def add_round_key(s, k):
    for i in range(4):
        for j in range(4):
            s[i][j] ^= k[i][j]

def sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = s_box[s[i][j]]

def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]

# 参考 http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)

def mix_single_column(a):
    # see Sec 4.1.2 in The Design of Rijndael
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)

def inv_sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = inv_s_box[s[i][j]]

def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])

def inv_shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]

def inv_mix_columns(s):
    # see Sec 4.1.3 in The Design of Rijndael
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v

    mix_columns(s)
    
def _expand_key(s):
    for i in range(10):
        word = list(s[-1])  # 取得最后一列
        word.append(word.pop(0)) # 将首位移动到最后
        word = [s_box[b] for b in word]  # SubBytes操作
        word[0] ^= r_con[i]  # 和异或表内数据异或

        s.append(xor_bytes(word, s[-4]))  # 得到新的子密钥
        s.append(xor_bytes(s[-1], s[-4]))  # 因为直接在s中添加，所以本该和上一轮第二列异或的位置还是-4
        s.append(xor_bytes(s[-1], s[-4]))
        s.append(xor_bytes(s[-1], s[-4]))

    return [s[4*i : 4*(i+1)] for i in range(len(s) // 4)]

def bytes2matrix(text):
    """ Converts a 16-byte array into a 4x4 matrix.  """
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]

key = b'1234567812345678'
enc = b'\xddd\xe1Q\xfe\x81\xf8\x83wa1\xa5\tH|\xee'
skeys = _expand_key(bytes2matrix(key))
enc = bytes2matrix(enc)

add_round_key(enc, skeys[-1])
inv_shift_rows(enc)
inv_sub_bytes(enc)

for i in range(9, 0, -1):
    add_round_key(enc, skeys[i])
    inv_mix_columns(enc)
    inv_shift_rows(enc)
    inv_sub_bytes(enc)

add_round_key(enc, skeys[0])

plain = bytes(enc[0]+enc[1]+enc[2]+enc[3])
print(plain) 
例题2 子密钥未参与运算
r_con = (0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,0x80, 0x1B, 0x36)
s_box = [129, 135, 43, 178, 226, 117, 54, 185, 67, 201, 34, 190, 121, 133, 125, 64, 69, 203, 147, 87, 131, 155, 148, 144, 197, 3, 162, 160, 247, 41, 179, 181, 184, 163, 142, 27, 192, 23, 243, 208, 204, 195, 105, 50, 80, 74, 146, 62, 66, 251, 104, 118, 89, 8, 139, 136, 140, 171, 235, 227, 128, 211, 106, 42, 188, 17, 79, 231, 154, 45, 255, 59, 157, 193, 254, 83, 127, 198, 116, 32, 212, 35, 233, 122, 49, 4, 194, 228, 249, 202, 229, 200, 78, 82, 253, 77, 96, 68, 152, 219, 91, 92, 46, 213, 39, 98, 103, 102, 119, 234, 85, 246, 236, 238, 242, 1, 150, 9, 182, 97, 22, 47, 221, 99, 223, 225, 224, 109, 240, 38, 126, 245, 63, 33, 176, 26, 21, 71, 58, 15, 53, 123, 6, 158, 232, 156, 55, 108, 25, 149, 191, 187, 0, 145, 20, 10, 214, 110, 241, 166, 18, 94, 137, 143, 199, 12, 14, 222, 65, 138, 164, 72, 159, 61, 95, 37, 111, 206, 141, 2, 209, 84, 217, 252, 28, 88, 248, 130, 44, 239, 60, 196, 24, 169, 153, 205, 5, 170, 183, 52, 81, 124, 244, 134, 11, 120, 250, 70, 218, 189, 16, 220, 173, 36, 101, 172, 115, 180, 75, 216, 40, 86, 51, 113, 151, 112, 100, 114, 31, 215, 174, 165, 19, 177, 76, 207, 107, 73, 13, 175, 237, 167, 132, 186, 161, 48, 7, 90, 93, 30, 210, 29, 230, 57, 168, 56]

def xor_bytes(a, b):
    return bytes(i^j for i, j in zip(a, b))

def add_round_key(s, k):
    for i in range(4):
        for j in range(4):
            s[i][j] ^= k[i][j]

def sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = s_box[s[i][j]]

def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]

# 参考 http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)

def mix_single_column(a):
    # see Sec 4.1.2 in The Design of Rijndael
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)

def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])

def _expand_key(s):
    for i in range(10):
        word = list(s[-1])  # 取得最后一列
        word.append(word.pop(0)) # 将首位移动到最后
        word = [s_box[b] for b in word]  # SubBytes操作
        word[0] ^= r_con[i]  # 和异或表内数据异或

        s.append(xor_bytes(word, s[-4]))  # 得到新的子密钥
        s.append(xor_bytes(s[-1], s[-4]))  # 因为直接在s中添加，所以本该和上一轮第二列异或的位置还是-4
        s.append(xor_bytes(s[-1], s[-4]))
        s.append(xor_bytes(s[-1], s[-4]))

    return [s[4*i : 4*(i+1)] for i in range(len(s) // 4)]

def bytes2matrix(text):
    """ Converts a 16-byte array into a 4x4 matrix.  """
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]

key = b'******'
plain = b'NSSCTF{********}'
skeys = _expand_key(bytes2matrix(key))
plain = bytes2matrix(plain)

for i in range(1, 12):
    sub_bytes(plain)
    mix_columns(plain)
    shift_rows(plain)

sub_bytes(plain)
shift_rows(plain)

enc = bytes(plain[0]+plain[1]+plain[2]+plain[3])
print(enc)  # b'\xc3\x03R\x17\x81a#\xc6\x81fDGt\xd0\xb3\xaf'
分析 
我们对比AES加密代码会发现本题迭代过程中子密钥并没有参与运算，那么此时我们只需要将迭代过程逆过来即可。

同样的本题S盒也不是标准S盒，所以需要先得到inv_S数组。

EXP 
r_con = (0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,0x80, 0x1B, 0x36)
s_box = [129, 135, 43, 178, 226, 117, 54, 185, 67, 201, 34, 190, 121, 133, 125, 64, 69, 203, 147, 87, 131, 155, 148, 144, 197, 3, 162, 160, 247, 41, 179, 181, 184, 163, 142, 27, 192, 23, 243, 208, 204, 195, 105, 50, 80, 74, 146, 62, 66, 251, 104, 118, 89, 8, 139, 136, 140, 171, 235, 227, 128, 211, 106, 42, 188, 17, 79, 231, 154, 45, 255, 59, 157, 193, 254, 83, 127, 198, 116, 32, 212, 35, 233, 122, 49, 4, 194, 228, 249, 202, 229, 200, 78, 82, 253, 77, 96, 68, 152, 219, 91, 92, 46, 213, 39, 98, 103, 102, 119, 234, 85, 246, 236, 238, 242, 1, 150, 9, 182, 97, 22, 47, 221, 99, 223, 225, 224, 109, 240, 38, 126, 245, 63, 33, 176, 26, 21, 71, 58, 15, 53, 123, 6, 158, 232, 156, 55, 108, 25, 149, 191, 187, 0, 145, 20, 10, 214, 110, 241, 166, 18, 94, 137, 143, 199, 12, 14, 222, 65, 138, 164, 72, 159, 61, 95, 37, 111, 206, 141, 2, 209, 84, 217, 252, 28, 88, 248, 130, 44, 239, 60, 196, 24, 169, 153, 205, 5, 170, 183, 52, 81, 124, 244, 134, 11, 120, 250, 70, 218, 189, 16, 220, 173, 36, 101, 172, 115, 180, 75, 216, 40, 86, 51, 113, 151, 112, 100, 114, 31, 215, 174, 165, 19, 177, 76, 207, 107, 73, 13, 175, 237, 167, 132, 186, 161, 48, 7, 90, 93, 30, 210, 29, 230, 57, 168, 56]
inv_s_box = [0 for i in range(256)]
for i in range(256):
    inv_s_box[s_box[i]] = i
    
def xor_bytes(a, b):
    return bytes(i^j for i, j in zip(a, b))

def add_round_key(s, k):
    for i in range(4):
        for j in range(4):
            s[i][j] ^= k[i][j]

def sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = s_box[s[i][j]]

def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]

# 参考 http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)

def mix_single_column(a):
    # see Sec 4.1.2 in The Design of Rijndael
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)

def inv_sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = inv_s_box[s[i][j]]

def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])

def inv_shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]

def inv_mix_columns(s):
    # see Sec 4.1.3 in The Design of Rijndael
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v

    mix_columns(s)
    
def _expand_key(s):
    for i in range(10):
        word = list(s[-1])  # 取得最后一列
        word.append(word.pop(0)) # 将首位移动到最后
        word = [s_box[b] for b in word]  # SubBytes操作
        word[0] ^= r_con[i]  # 和异或表内数据异或

        s.append(xor_bytes(word, s[-4]))  # 得到新的子密钥
        s.append(xor_bytes(s[-1], s[-4]))  # 因为直接在s中添加，所以本该和上一轮第二列异或的位置还是-4
        s.append(xor_bytes(s[-1], s[-4]))
        s.append(xor_bytes(s[-1], s[-4]))

    return [s[4*i : 4*(i+1)] for i in range(len(s) // 4)]

def bytes2matrix(text):
    """ Converts a 16-byte array into a 4x4 matrix.  """
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]

enc = b'\xc3\x03R\x17\x81a#\xc6\x81fDGt\xd0\xb3\xaf'
enc = bytes2matrix(enc)

inv_shift_rows(enc)
inv_sub_bytes(enc)

for i in range(11, 0, -1):
    inv_shift_rows(enc)
    inv_mix_columns(enc)
    inv_sub_bytes(enc)

plain = bytes(enc[0]+enc[1]+enc[2]+enc[3])
print(plain) 
子密钥泄露
import os
import pyaes

key = os.urandom(16)
aes = pyaes.AES(key)
flag = b'NSSCTF{********}'
print(bytes(aes.encrypt(flag)))

print(aes._Ke)


b'Th_g\xd5\x01T\x9e=h\xcc7\xc9\xda\x99\xaa'
[[-622134778, -738926382, 513658859, -1527147565], [-3184092081, 2445442205, 2405413750, -3562659675], [-2608751938, -180099549, -2246290091, 1371174384], [-1810098577, 1633677388, -3837549287, -3037081367], [-4204001095, -2613839627, 2138070508, -3396760315], [-1305386193, 3590495194, 2842871350, -1661252813], [-1652383503, -3028272341, -487391971, 2114565678], [-590573310, 2538383913, -2319558860, -4098367206], [-181128407, -2642896640, 398904884, -3817787602], [-3000958283, 794401717, 949966209, -3675358545], [-2885977213, -2203918282, -3150072393, 1624493848]]

分析
在这里泄漏了aes._Ke，能从之前pydes中的Kn猜测出来这是什么。

![image-20241120174625835](../../AppData/Roaming/Typora/typora-user-images/image-20241120174625835.png)

我们可以看到_Ke会参与加密的运算进行和明文的异或，在这里你会发现这里的AES实现和我们的几乎完全不一样，根本没有看到什么AddRoundKey之类的函数，实际上我们的实现是一种8位的最原始的实现，即每次只处理8位信息，但是我们完全可以将一些操作并联在一起进行，而且中间操作的一些输出值完全可以再整理为一张新的表，而这里便是一个AES 32bit的实现，其中的T1、T2等表便是一些中间表，用来加速AES加密流程。

不管他的实现如何，只要还是AES，那么就和我们所学的内容是一样的，既然这里泄漏的全部的子密钥，我们便可以直接进行解密，只是需要注意这里每组密钥都是4个32bit数字，需要自行转换为16个8bit数字才能使用我们之前的解密代码。第二种方式便是直接利用pyaes包进行解密，在WP中我们主要讲解第二种方式，因为这里还需要我们手动进行一些转换。

和pydes中直接赋值不一样的时，在这里它将密钥分成了_Ke和_Kd两个东西，一个用来加密一个用来解密，当然这里和非对称的两组密钥是不同的，这里我们其实可以通过_Ke来得到_Kd，反之亦然。

EXP
def __init__(self, key):

    if len(key) not in (16, 24, 32):
        raise ValueError('Invalid key size')

    rounds = self.number_of_rounds[len(key)]

    # Encryption round keys
    self._Ke = [[0] * 4 for i in xrange(rounds + 1)]

    # Decryption round keys
    self._Kd = [[0] * 4 for i in xrange(rounds + 1)]

    round_key_count = (rounds + 1) * 4
    KC = len(key) // 4

    # Convert the key into ints
    tk = [ struct.unpack('>i', key[i:i + 4])[0] for i in xrange(0, len(key), 4) ]

    # Copy values into round key arrays
    for i in xrange(0, KC):
        self._Ke[i // 4][i % 4] = tk[i]
        self._Kd[rounds - (i // 4)][i % 4] = tk[i]

    # Key expansion (fips-197 section 5.2)
    rconpointer = 0
    t = KC
    while t < round_key_count:

        tt = tk[KC - 1]
        tk[0] ^= ((self.S[(tt >> 16) & 0xFF] << 24) ^
                  (self.S[(tt >>  8) & 0xFF] << 16) ^
                  (self.S[ tt        & 0xFF] <<  8) ^
                   self.S[(tt >> 24) & 0xFF]        ^
                  (self.rcon[rconpointer] << 24))
        rconpointer += 1

        if KC != 8:
            for i in xrange(1, KC):
                tk[i] ^= tk[i - 1]

        # Key expansion for 256-bit keys is "slightly different" (fips-197)
        else:
            for i in xrange(1, KC // 2):
                tk[i] ^= tk[i - 1]
            tt = tk[KC // 2 - 1]

            tk[KC // 2] ^= (self.S[ tt        & 0xFF]        ^
                           (self.S[(tt >>  8) & 0xFF] <<  8) ^
                           (self.S[(tt >> 16) & 0xFF] << 16) ^
                           (self.S[(tt >> 24) & 0xFF] << 24))

            for i in xrange(KC // 2 + 1, KC):
                tk[i] ^= tk[i - 1]

        # Copy values into round key arrays
        j = 0
        while j < KC and t < round_key_count:
            self._Ke[t // 4][t % 4] = tk[j]
            self._Kd[rounds - (t // 4)][t % 4] = tk[j]
            j += 1
            t += 1

    # Inverse-Cipher-ify the decryption round key (fips-197 section 5.3)
    for r in xrange(1, rounds):
        for j in xrange(0, 4):
            tt = self._Kd[r][j]
            self._Kd[r][j] = (self.U1[(tt >> 24) & 0xFF] ^
                              self.U2[(tt >> 16) & 0xFF] ^
                              self.U3[(tt >>  8) & 0xFF] ^
                              self.U4[ tt        & 0xFF])
在源代码中找到_Ke和_Kd的生成方式，去掉其他不相关代码，并且将一些常量添加到代码中，只留下关于这两组密钥相关的代码得到

def __init__(self, key):
    rounds = self.number_of_rounds[len(key)]  # 10
    round_key_count = (rounds + 1) * 4  # 44
    KC = len(key) // 4  # 4

    for i in xrange(0, KC):
        self._Ke[i // 4][i % 4] = tk[i]
        self._Kd[rounds - (i // 4)][i % 4] = tk[i]

    rconpointer = 0
    t = KC
    while t < round_key_count:
        j = 0
        while j < KC and t < round_key_count:
            self._Ke[t // 4][t % 4] = tk[j]
            self._Kd[rounds - (t // 4)][t % 4] = tk[j]
            j += 1
            t += 1

    for r in xrange(1, rounds):
        for j in xrange(0, 4):
            tt = self._Kd[r][j]
            self._Kd[r][j] = (self.U1[(tt >> 24) & 0xFF] ^
                              self.U2[(tt >> 16) & 0xFF] ^
                              self.U3[(tt >>  8) & 0xFF] ^
                              self.U4[ tt        & 0xFF])
我们会发现_Ke的第[i // 4][i % 4]组内容和_Kd的[rounds - (i // 4)][i % 4]组内容应该是一样的，最后对于_Kd单独再做一些置换操作即可。

得到_Kd后我们便可以直接利用pyaes包解密即可

import os
import pyaes

key = os.urandom(16)
aes = pyaes.AES(key)
enc = b'Th_g\xd5\x01T\x9e=h\xcc7\xc9\xda\x99\xaa'
Ke = [[-622134778, -738926382, 513658859, -1527147565], [-3184092081, 2445442205, 2405413750, -3562659675], [-2608751938, -180099549, -2246290091, 1371174384], [-1810098577, 1633677388, -3837549287, -3037081367], [-4204001095, -2613839627, 2138070508, -3396760315], [-1305386193, 3590495194, 2842871350, -1661252813], [-1652383503, -3028272341, -487391971, 2114565678], [-590573310, 2538383913, -2319558860, -4098367206], [-181128407, -2642896640, 398904884, -3817787602], [-3000958283, 794401717, 949966209, -3675358545], [-2885977213, -2203918282, -3150072393, 1624493848]]

for i in range(44):
    aes._Kd[10 - (i // 4)][i % 4] = Ke[i // 4][i % 4]

for r in range(1, 10):
    for j in range(0, 4):
        tt = aes._Kd[r][j]
        aes._Kd[r][j] = (aes.U1[(tt >> 24) & 0xFF] ^
                            aes.U2[(tt >> 16) & 0xFF] ^
                            aes.U3[(tt >>  8) & 0xFF] ^
                            aes.U4[ tt        & 0xFF])
    
print(bytes(aes.decrypt(enc)))
泄露一组子密钥
import os
import pyaes

key = os.urandom(16)
aes = pyaes.AES(key)
flag = b'NSSCTF{********}'
print(bytes(aes.encrypt(flag)))

print(aes._Ke[7])


b'\x101\x1e\xc7K\xae$Z\xfa\xe9\xc8\xa17\xe0N1'
[-4103470408, -2670959867, 1495165278, -3745702895]
分析
恢复原始密码 -> 生成完整子密钥 -> 解密消息

剩下的就是不断的调试代码罢了。

我们将包内生成_Ke相关的代码单独提取出来

EXP
key = [0, 0, 0, 0] # 初始key值，现在不知道
Ke = [key, [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
tk = key

S = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 ]
rcon = [ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 ]

round_key_count = 44
KC = 4
rconpointer = 0
t = KC
while t < round_key_count:
    tt = tk[KC - 1]
    tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                (S[(tt >>  8) & 0xFF] << 16) ^
                (S[ tt        & 0xFF] <<  8) ^
                S[(tt >> 24) & 0xFF]        ^
                (rcon[rconpointer] << 24))
    rconpointer += 1

    for i in range(1, KC):
        tk[i] ^= tk[i - 1]

    j = 0
    while j < KC and t < round_key_count:
        Ke[t // 4][t % 4] = tk[j]
        j += 1
        t += 1

print(Ke)
我们得到的是_Ke[7]，也就是tk的内容，那么我们发现向前恢复只需要让他再异或一遍即可，由此我们可以得到循环体开始时tk的内容（即上一轮子密钥），依此往复便可以得到最初的子密钥内容然后重新生成子密钥进行解密。

import struct
import pyaes

Sbox = [ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 ]
T = [ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 ]
ROT = lambda x: ((x & 0xffffff) << 8) | ((x >> 24) & 0xFF)
S = lambda x: (Sbox[(x >> 24) & 0xff] << 24) | (Sbox[(x >> 16) & 0xff] << 16) | (Sbox[(x >> 8) & 0xff] << 8) | (Sbox[x & 0xff])

def inv_key(k5, k6, k7, k8, i):
    k4 = k8 ^ k7
    k3 = k7 ^ k6
    k2 = k6 ^ k5
    k1 = k5 ^ S(ROT(k4)) ^ (T[i-1] << 24)
    
    return k1, k2, k3, k4

def transform(k1, k2, k3, k4):
    return  struct.pack('>i',k1) + \
            struct.pack('>i',k2) + \
            struct.pack('>i',k3) + \
            struct.pack('>i',k4)

key = [-4103470408, -2670959867, 1495165278, -3745702895]
for i in range(7, 0, -1):
    key = inv_key(*key, i)

enc = b'\x101\x1e\xc7K\xae$Z\xfa\xe9\xc8\xa17\xe0N1'

aes = pyaes.AES(transform(*key))
print(bytes(aes.decrypt(enc)))
hint求得密钥
题目
#!/usr/bin/python
from Crypto.Cipher import AES
import binascii
from Crypto.Util.number import bytes_to_long
from flag import flag
from key import key

iv = flag.strip(b'd0g3{').strip(b'}')

LENGTH = len(key)
assert LENGTH == 16

hint = os.urandom(4) * 8
print(bytes_to_long(hint)^bytes_to_long(key))

msg = b'Welcome to this competition, I hope you can have fun today!!!!!!'

def encrypto(message):
    aes = AES.new(key,AES.MODE_CBC,iv)
    return aes.encrypt(message)

print(binascii.hexlify(encrypto(msg))[-32:])


56631233292325412205528754798133970783633216936302049893130220461139160682777
b'3c976c92aff4095a23e885b195077b66'
分析
我们看到题目flag采用AES的CBC模式进行加密，其中flag括号里面的内容是初始化的IV值。

题目告诉我们hint和key异或的结果tmp，同时我们发现key的值小于hint，即hint有一部分没有进行运算，其中hint是8个重复的4字节，所以我们由此可以推断出key.

tmp = 56631233292325412205528754798133970783633216936302049893130220461139160682777
_tmp = long_to_bytes(tmp)
#b'}4$d}4$d}4$d}4$d\x19\x04CW\x06CA\x08\x1e[I\x01\x04[Q\x19'
hint = b'}4$d'*8
key = long_to_bytes(bytes_to_long(hint)^tmp)
print("key=",key)
得到key之后，对密文进行解密，我们知道加密采用了CBC模式，即每一块明文在用key加密之前会先和上一轮的密文进行异或操作，从而形成一个链式结构。

现在我们要求解的flag是iv，故我们考虑将原先加密时CBC模式进行转换改为ECB模式，而CBC模式中的与上一轮密文进行异或的操作我们单独写代码进行完成。

msg = b'Welcome to this competition, I hope you can have fun today!!!!!!'
# 将msg按照16位进行分割，存入msgs中
msgs = [msg[i:i+16] for i in range(0, len(msg), 16)]
# 将msgs中的元素反转
msgs.reverse()
# 遍历msgs中的元素
for j in msgs:
    enc = xor(decrypt(enc),j)
    print(enc)
EXP
from Cryptodome.Util.number import *
from Cryptodome.Cipher import AES
import binascii


tmp = 56631233292325412205528754798133970783633216936302049893130220461139160682777


_tmp = long_to_bytes(tmp)
#b'}4$d}4$d}4$d}4$d\x19\x04CW\x06CA\x08\x1e[I\x01\x04[Q\x19'


hint = b'}4$d'*8
key = long_to_bytes(bytes_to_long(hint)^tmp)
print("key=",key)


# 定义一个函数decrypt，用于解密
def decrypt(enc):
    # 使用key和AES.MODE_ECB模式创建一个AES对象
    aes = AES.new(key, AES.MODE_ECB)
    return aes.decrypt(enc)

# 定义一个函数xor，用于异或
def xor(a,b):
    return bytes([_a^_b for _a,_b in zip(a,b)])


enc = binascii.unhexlify('3c976c92aff4095a23e885b195077b66')
msg = b'Welcome to this competition, I hope you can have fun today!!!!!!'
# 将msg按照16位进行分割，存入msgs中
msgs = [msg[i:i+16] for i in range(0, len(msg), 16)]
# 将msgs中的元素反转
msgs.reverse()

# 遍历msgs中的元素
for j in msgs:
    enc = xor(decrypt(enc),j)
    print(enc)
时间戳
image-20250105181205353

我们看到该题在生成key存在漏洞，题目利用创建文件的时间戳来作为random随机数的种子，然后再利用random的getrandbits来生成密钥。

但我们知道在中确定的情况下，后面random的随机数也是确定的，故可以爆破文件创建时的时间来解题

image-20250105181325291

image-20250105181701804

分组模式
MTP(多次密码本攻击)
介绍
本文讨论的加密方式是最简单的一种：简单异或。准备一个 字符串，然后利用 去异或相同长度的明文，即得到密文。如果每个密文都利用新的 去加密，那么这种方式称为“一次一密”（One-Time-Pad）。OTP是无条件安全的：即使攻击者拥有无限的计算资源，都不可能破译OTP加密的密文。

然而，一次一密的密钥分发是比较困难的。首先，Alice 想要 给 Bob 发送长度为 n 的信息，则必须在这之前传送长度为 n 的密钥，相当于传输的数据总量翻了倍。其次，尽管密文是无条件安全的，但密钥的传输信道未必是安全的，攻击者一旦窃听了密钥，则可以解密密文。

那么马上就可以想到一个投机取巧的方法—— Alice 造一个比较长的密钥，然后用非常秘密的方式告诉 Bob。接下来，Alice 每次向 Bob 发送信息，都把明文异或上这个约定好的字符串;Bob 收到信息之后，把密文异或上 ， 于是就可以拿到明文。整个过程只需要传送一次密钥，这是很方便的。这种方式称为 Many-Time-Pad （MTP）。

很遗憾，上述的 MTP 办法是不安全的。攻击者如果截获了足够多的密文，就有可能推断出明文、进而拿到密钥。这个缺陷是异或运算的性质带来的。

例题
1
from Crypto.Cipher import AES
2
from Crypto.Util.strxor import strxor as xor
3
from Crypto.Util.Padding import pad
4
from random import *
5
from base64 import *
6
from copy import copy
7
from secret import data
8
​
9
iv=bytes([randint(0,2**8-1) for i in range(16)])
10
iva=copy(iv)
11
key=bytes([randint(0,2**8-1) for i in range(16)])
12
cipher=AES.new(key,mode=AES.MODE_ECB)
13
data=pad(data,16)
14
c=b""
15
for i in range(0,len(data),16):
16
    s=data[i:i+16].ljust(16,b"\n")
17
    c+=cipher.encrypt(xor(s,iv))
18
    iv=xor(s,c[-16:])
19
​
20
​
21
key=b64encode(key)
22
c=b64encode(c)
23
​
24
print(key)
25
print(c)
26
​
27
​
28
​
29
"""
30
b'+0zkhmid1PFjVdxSP09zSw=='
31
b'A0bzFxdM95YoXm64g0gZkiTloPsBAq7iV56t1M7Q4zVNxRJSTdZH0lzOMa7QyIQbKN/ftm01iZgQAk+JVgCB6hlCdMPWkdpKYHix8BTq/ClEHUPwMEjUEvgKD4tH3T/thoccBw1jfJ9RjhXbMFByWn5cyA/gHVvEEJRpII/ryKMQkzelioQ5b0MfhSy4INLqQk6yAgLzihip5ho7lDJCbYcaz85bDksOo5n9kjOfjFnjUn9G7jX+AtyhygPlGfrvauTeuPdVxqrJTVHvrzUNAqiqtCElX+BWpicP2mkZLt5B/gpquTv8U+StrdTOcr7UkWuz+YdhXkTJYUZguv7EbEnRy+M64QzqfnNf8Zk0tJQ5xOumbY8hxGTuZ8w3rWxjPKLhdgTGLgMcMYF3hPb2eqG9VZKC3T9zElI5MWPyIdkmqkrLEt6vGT8AxWJy1hl2ApkGhrJFB0DobJircN6kXUXvZXitjXSH+BA48muaRlAwK13re+zIcbI+B7+Tm3LuRT9j5NWD9RBoy+IeAQvR05IKWqEpqXEScmZsQxpAFZCSnbchYaYNAuHvBwMcMW7vTMyxROHRtyZ+gWNUhpd8CcZ9FA6w+cwQLMWW5D4nUCMK+NEsSyTBBm/jTiAp/waq+2dTVyBhbQtmm9pBtZtHJtfeVRKuZRXduNnlWDa7Wlwv0Jk2EIJpAaXxosuZnO0PHW3oX+WO5F9ydIfIJAFUpBrn4fMx3c7IJ08+bKwAfBw/johSs1ieyX/YjOOL1KbE9J6Hz3ZBBR4waQ4p9sdLsJ9UFnNghH0ZuB2F7bGoH7SurvaMglo3FyQAfM+n/EVCGWnax/JGEcw5YZuS2c7y5Gd4oOCmpFO/lVj0IaOlZsFsMgQ3GUsBT2h1yh4yarlYUczvGNyOyfUXfueCDBQJNJ7adbdra/DHpV3LXieADKED2HankT+9ACs8oVYPpZhji0UuCdvs1txytsCqPSf5l7JLDkrGP3/7Ob7UcCA4h/B+6/0xg7h+ZJ6ZR41sDpOR8S4pmPlfJkU/np52QZfplY0sKpKlaYhuhUmMSle2TAcvNUGHobNTReFV/MOfX5/HX6behFAeOwHGI14AvUbDmrmkVvbyU88DzBW2YQ/tTTiSLg/wgggkkhLd17NZAMB3XbKuw3WdkdyJfTTpyiN05DqMwV3q64fpzasFXFNQ7ix8Q/APov/TmBYtgFw4ys2jKC6Yws166RXRkrQXzY4Ey9Xvjp5i5nUgW2HLHRGz2B5lg0jI9oWjj5+89Y0Tcqb81OFD5SfeqTbg7Y2WoW6YjQ/Hzvt1l0+p/lFrnOy3ORfhwl+DFBZi4P9i+Hh7/uC1kCW8Lil2M9oVaAH4YB2yhm61AqEk4NPhSeTuioaFfvUY5lD75QiM6BdDFMTlNkC7crXmuiUpztHTzIS6E1kVARI8xsGeljjmJmuKIfQPPQfvSnnAjGeaxCNmRPDMgFGltFiGy63Pv/tVRWbUWiB27APHPsqM2qcV/nM8IwDx5xmwExl/atQXGzn/LL4xyqzmyzD+2qMeZqfzcKZWOjoWIX+SycPvc62HAQmsKqZK5ZO2JKq5OeuFEovG9oOcRYve1XStbTQYiocEbQ4XX/c6xE0cm9P/I5NM1Mlr6CT6qt3Pqb/m+7s/kwzww59FKOq5R6HmK7SHCQ6gwTQ1ciGWbJF3NLHuOpe08X4xl/l0tJengSfJRJ39Q9WwZbgBlEPf7NYeMlR9zU9QQxvZ+r4LiaJVYrQYSCcDj37Vk9XVRMijBDWDWFbK5sgkDHQYmwGYiwH4hEAqAAXDNj1/f2eRFbIU2GN6Wfj89fEINJjoG/1O/I5Q8S7tHnlWFQNoXJQ2e4r2Aca9RPLVCWz7Nq96YUKBRN3afW/9FSwWLLvjsBptQmoRj4FwmJzJf7Vj6KCOkm6mdaZ4l6FB4/E2Lk9aopD7Q473leULPM1CydXWme/8WKUqEucDwraXS57+Z+iGRMvQ8MABtZboAVFK2B1mzNL4Ba/bxVE4puy4HwvQI+N1tKmeMf99FfR13IA0y+FWL3eCzXKw8gimaJCW1e3QJJWDorDXRRjExeokMGGHzOd8MrTfNNFGWSPqZRTdGJxW7wOWQi3bHT0WSqP1fBpdU9m+WKHIxy57dL/8JFJJ97R56P76rlToRrM825JcTBEfrK0Nb9Q+2RI83vyTA2UxH9s9cSnWd+e7nacrfXjV7EjkGHgblEGHX9LqNETaZpBAL0NG9OAJ0+f+6id4/Ixcee0jx4b8k5xvblujFEdK0q2MRo2uTxSAFMpelt8JY0EZbnF9uT88N4LPms3cNeKBt0KBhx+vshFKMc/b3W7OMCo6m7EyzmcTmMe+Y6CO0x0FF0p6h1bTnJu3MMok1hO27iBSfYusHgKWVmKpgNHjiDfuBYnuBCysa+hHQZW23zxNRqi2OGAy6zCGPOY4E4nyUA6g/jlVOjq6fFv1VHN1tlQlBOCvB9r5B0os1zI2XL/Mlb9eggNuA8nw2igDm+9qkBtLxOXojAGDonAPzBagHXnVd+0kLdUGEoddt45A2fgSSociCx4tVDMd5ag1zR4VxdADAy0lnmW0n8noAT5y60SV7gICvMOphILBRjk365Mu6GNA3C+n8k5YH9sRnS7Z5EVEKdSeYigJs4XNavD50/paKnJcux2l3gzm/1aTUMzLd8tw7vZuUWv1XaYULcez8ieEMeACETyN53+RlcPQefupgszELvwlKz0prl5ydHCPOA7+ZS2zfUZOEmRSBNaIZUCd5euNg+HXMeFa/Qb452+KKEjq7vRthC4hH9gluaYMl/eXboQvvVu4xDhfVW403enI7sxdMR3t2WO1cOaLE8IN5c71W+IqhaRbJ/Prlo/pk/XAtMvimZxIN4y5/oP5vQ/lCt5jM9wAtPKSoQbJxWIYWNrXVfkZUOOwD2tlOmyxMCcKFr8921JHgtWqcYliElNX19hzmYhow+19EV3zhITzsGOX/PP1BHIKz/NJyKcGqx1hlfrDfDVedhJWkQL9sg4clbfguprs3KG5YNbbjclaK9JoEboBY3EGBGHtsWfmIRAREwy1a53y/a/NUDLaQxrMsyV/YnbiyBevGjMVNnqIY5T0YtPLL/s5Wvmq7EU9qoMDIlaosCf616TagcZalGFQumL15q6wx3FxwVB5EAjFa/MKnZNc0CqbFhXgEevp1ZXRnjEAdSK99gyAmwVawWpxIWXZQvQ5w7tIQ+nF8utoG4ab/AdLbZyKCtT8pxjiHifNcCCkLfew8Qq9S2JnrhCUMs9SEiRrLZHiE9JVlwbUJzAQjCM6G4tdeLNEApqDv4eZ7zh2U9K2+Gk9OjBgSk5xMjRkCzKCrNAKgRLoJ1Gu8L4T9LSBp1juhUsyaIaK'
32
"""
分析
我们先来分析一下加密代码： 

1
cipher=AES.new(key,mode=AES.MODE_ECB)
2
data=pad(data,16)
3
c=b""
4
for i in range(0,len(data),16):
5
    s=data[i:i+16].ljust(16,b"\n")
6
    c+=cipher.encrypt(xor(s,iv))
7
    iv=xor(s,c[-16:])
我们看到加密采用AES的ECB模式，但在后面的for循环中，我们看到密文被分块成16字节大小，然后再采用类似CBC模式进行处理（在CBC模式中IV_next=密文快，而在此题中IV_next=明文⊕密文块）。

下面我们开始讨论MTP攻击的本质：

回顾异或运算的性质，我们知道有：

这表明，两个密文的异或，就等于对应明文的异或。

在异或运算中有一个重要的规律：小写字母⊕空格，会得到对应的大写字母；大写字母⊕空格，会得到对应的小写字母。所以，当两个字符如x⊕y得到一个英文字母时，那么x和y中某一个有很大概率是空格。
由此我们考虑C_1分别异或其他块密文，也就是M_1分别异或其他明文，如果第col列存在大量的英文字母，我们可以猜测M_1[col]是一个空格，当那一列的英文字母越多，把握也就越大。
于是，只要知道某个字符串的某一位是空格，我们就可以恢复出所有明文在这一列的值。

攻击过程显而易见：对于每一条密文C我，拿去异或其他所有密文。然后去数每一列有多少个英文字符，作为“M我在这一位是空格”的评分。

上面的事情做完时候，依据评分从大到小排序，依次利用 “某个明文的某一位是空格” 这种信息恢复出所有明文的那一列。如果产生冲突，则舍弃掉评分小的。

1
import base64
2
from Cryptodome.Cipher import AES
3
from Cryptodome.Util.strxor import strxor as xor
4
from Cryptodome.Util.number import *
5
import Cryptodome.Util.strxor as xo
6
import libnum, codecs, numpy as np
7
​
8
​
9
def isChr(x):
10
    if ord('a') <= x and x <= ord('z'): return True
11
    if ord('A') <= x and x <= ord('Z'): return True
12
    return False
13
​
14
​
15
def infer(index, pos):
16
    if msg[index, pos] != 0:
17
        return
18
    msg[index, pos] = ord(' ')
19
    for x in range(len(c)):
20
        if x != index:
21
            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(' ')
22
​
23
​
24
def know(index, pos, ch):
25
    msg[index, pos] = ord(ch)
26
    for x in range(len(c)):
27
        if x != index:
28
            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)
29
​
30
​
31
def getSpace():
32
    for index, x in enumerate(c):
33
        res = [xo.strxor(x, y) for y in c if x != y]
34
        f = lambda pos: len(list(filter(isChr, [s[pos] for s in res])))
35
        cnt = [f(pos) for pos in range(len(x))]
36
        for pos in range(len(x)):
37
            dat.append((f(pos), index, pos))
38
​
39
​
40
key = b'+0zkhmid1PFjVdxSP09zSw=='
41
key = base64.b64decode(key)
42
c = b'A0bzFxdM95YoXm64g0gZkiTloPsBAq7iV56t1M7Q4zVNxRJSTdZH0lzOMa7QyIQbKN/ftm01iZgQAk+JVgCB6hlCdMPWkdpKYHix8BTq/ClEHUPwMEjUEvgKD4tH3T/thoccBw1jfJ9RjhXbMFByWn5cyA/gHVvEEJRpII/ryKMQkzelioQ5b0MfhSy4INLqQk6yAgLzihip5ho7lDJCbYcaz85bDksOo5n9kjOfjFnjUn9G7jX+AtyhygPlGfrvauTeuPdVxqrJTVHvrzUNAqiqtCElX+BWpicP2mkZLt5B/gpquTv8U+StrdTOcr7UkWuz+YdhXkTJYUZguv7EbEnRy+M64QzqfnNf8Zk0tJQ5xOumbY8hxGTuZ8w3rWxjPKLhdgTGLgMcMYF3hPb2eqG9VZKC3T9zElI5MWPyIdkmqkrLEt6vGT8AxWJy1hl2ApkGhrJFB0DobJircN6kXUXvZXitjXSH+BA48muaRlAwK13re+zIcbI+B7+Tm3LuRT9j5NWD9RBoy+IeAQvR05IKWqEpqXEScmZsQxpAFZCSnbchYaYNAuHvBwMcMW7vTMyxROHRtyZ+gWNUhpd8CcZ9FA6w+cwQLMWW5D4nUCMK+NEsSyTBBm/jTiAp/waq+2dTVyBhbQtmm9pBtZtHJtfeVRKuZRXduNnlWDa7Wlwv0Jk2EIJpAaXxosuZnO0PHW3oX+WO5F9ydIfIJAFUpBrn4fMx3c7IJ08+bKwAfBw/johSs1ieyX/YjOOL1KbE9J6Hz3ZBBR4waQ4p9sdLsJ9UFnNghH0ZuB2F7bGoH7SurvaMglo3FyQAfM+n/EVCGWnax/JGEcw5YZuS2c7y5Gd4oOCmpFO/lVj0IaOlZsFsMgQ3GUsBT2h1yh4yarlYUczvGNyOyfUXfueCDBQJNJ7adbdra/DHpV3LXieADKED2HankT+9ACs8oVYPpZhji0UuCdvs1txytsCqPSf5l7JLDkrGP3/7Ob7UcCA4h/B+6/0xg7h+ZJ6ZR41sDpOR8S4pmPlfJkU/np52QZfplY0sKpKlaYhuhUmMSle2TAcvNUGHobNTReFV/MOfX5/HX6behFAeOwHGI14AvUbDmrmkVvbyU88DzBW2YQ/tTTiSLg/wgggkkhLd17NZAMB3XbKuw3WdkdyJfTTpyiN05DqMwV3q64fpzasFXFNQ7ix8Q/APov/TmBYtgFw4ys2jKC6Yws166RXRkrQXzY4Ey9Xvjp5i5nUgW2HLHRGz2B5lg0jI9oWjj5+89Y0Tcqb81OFD5SfeqTbg7Y2WoW6YjQ/Hzvt1l0+p/lFrnOy3ORfhwl+DFBZi4P9i+Hh7/uC1kCW8Lil2M9oVaAH4YB2yhm61AqEk4NPhSeTuioaFfvUY5lD75QiM6BdDFMTlNkC7crXmuiUpztHTzIS6E1kVARI8xsGeljjmJmuKIfQPPQfvSnnAjGeaxCNmRPDMgFGltFiGy63Pv/tVRWbUWiB27APHPsqM2qcV/nM8IwDx5xmwExl/atQXGzn/LL4xyqzmyzD+2qMeZqfzcKZWOjoWIX+SycPvc62HAQmsKqZK5ZO2JKq5OeuFEovG9oOcRYve1XStbTQYiocEbQ4XX/c6xE0cm9P/I5NM1Mlr6CT6qt3Pqb/m+7s/kwzww59FKOq5R6HmK7SHCQ6gwTQ1ciGWbJF3NLHuOpe08X4xl/l0tJengSfJRJ39Q9WwZbgBlEPf7NYeMlR9zU9QQxvZ+r4LiaJVYrQYSCcDj37Vk9XVRMijBDWDWFbK5sgkDHQYmwGYiwH4hEAqAAXDNj1/f2eRFbIU2GN6Wfj89fEINJjoG/1O/I5Q8S7tHnlWFQNoXJQ2e4r2Aca9RPLVCWz7Nq96YUKBRN3afW/9FSwWLLvjsBptQmoRj4FwmJzJf7Vj6KCOkm6mdaZ4l6FB4/E2Lk9aopD7Q473leULPM1CydXWme/8WKUqEucDwraXS57+Z+iGRMvQ8MABtZboAVFK2B1mzNL4Ba/bxVE4puy4HwvQI+N1tKmeMf99FfR13IA0y+FWL3eCzXKw8gimaJCW1e3QJJWDorDXRRjExeokMGGHzOd8MrTfNNFGWSPqZRTdGJxW7wOWQi3bHT0WSqP1fBpdU9m+WKHIxy57dL/8JFJJ97R56P76rlToRrM825JcTBEfrK0Nb9Q+2RI83vyTA2UxH9s9cSnWd+e7nacrfXjV7EjkGHgblEGHX9LqNETaZpBAL0NG9OAJ0+f+6id4/Ixcee0jx4b8k5xvblujFEdK0q2MRo2uTxSAFMpelt8JY0EZbnF9uT88N4LPms3cNeKBt0KBhx+vshFKMc/b3W7OMCo6m7EyzmcTmMe+Y6CO0x0FF0p6h1bTnJu3MMok1hO27iBSfYusHgKWVmKpgNHjiDfuBYnuBCysa+hHQZW23zxNRqi2OGAy6zCGPOY4E4nyUA6g/jlVOjq6fFv1VHN1tlQlBOCvB9r5B0os1zI2XL/Mlb9eggNuA8nw2igDm+9qkBtLxOXojAGDonAPzBagHXnVd+0kLdUGEoddt45A2fgSSociCx4tVDMd5ag1zR4VxdADAy0lnmW0n8noAT5y60SV7gICvMOphILBRjk365Mu6GNA3C+n8k5YH9sRnS7Z5EVEKdSeYigJs4XNavD50/paKnJcux2l3gzm/1aTUMzLd8tw7vZuUWv1XaYULcez8ieEMeACETyN53+RlcPQefupgszELvwlKz0prl5ydHCPOA7+ZS2zfUZOEmRSBNaIZUCd5euNg+HXMeFa/Qb452+KKEjq7vRthC4hH9gluaYMl/eXboQvvVu4xDhfVW403enI7sxdMR3t2WO1cOaLE8IN5c71W+IqhaRbJ/Prlo/pk/XAtMvimZxIN4y5/oP5vQ/lCt5jM9wAtPKSoQbJxWIYWNrXVfkZUOOwD2tlOmyxMCcKFr8921JHgtWqcYliElNX19hzmYhow+19EV3zhITzsGOX/PP1BHIKz/NJyKcGqx1hlfrDfDVedhJWkQL9sg4clbfguprs3KG5YNbbjclaK9JoEboBY3EGBGHtsWfmIRAREwy1a53y/a/NUDLaQxrMsyV/YnbiyBevGjMVNnqIY5T0YtPLL/s5Wvmq7EU9qoMDIlaosCf616TagcZalGFQumL15q6wx3FxwVB5EAjFa/MKnZNc0CqbFhXgEevp1ZXRnjEAdSK99gyAmwVawWpxIWXZQvQ5w7tIQ+nF8utoG4ab/AdLbZyKCtT8pxjiHifNcCCkLfew8Qq9S2JnrhCUMs9SEiRrLZHiE9JVlwbUJzAQjCM6G4tdeLNEApqDv4eZ7zh2U9K2+Gk9OjBgSk5xMjRkCzKCrNAKgRLoJ1Gu8L4T9LSBp1juhUsyaIaK'
43
​
44
c = base64.b64decode(c)
45
cipher = AES.new(key, mode=AES.MODE_ECB)
46
​
47
t = []
48
for i in range(0, len(c), 16):
49
    if i == 0:
50
        t.append(cipher.decrypt(c[i:i + 16]))  # s1 ^ iv
51
    else:
52
        t.append(xor(cipher.decrypt(c[i:i + 16]), c[i - 16:i]))
53
tmp = []
54
tmp.append(t[0])
55
for i in range(1, len(t)):
56
    tttt = t[i]
57
    for j in range(0, i):
58
        tttt = xor(tttt, t[j])
59
    tmp.append(tttt)  # si ^ iv
60
# MTP attack
61
c = tmp
62
dat = []
63
msg = np.zeros([len(c), len(c[0])], dtype=int)
64
getSpace()
65
dat = sorted(dat)[::-1]
66
for w, index, pos in dat:
67
    infer(index, pos)
68
​
69
print(''.join([''.join([chr(c) for c in x]) for x in msg]))
ECB模式
1.相同明文产生相同密文
题目
1
from Crypto.Cipher import AES
2
import binascii
3
import os
4
import random
5
import string
6
​
7
flag = os.getenv('FLAG')
8
BLOCKSIZE = 16
9
​
10
table = []
11
​
12
for i in range(1024):
13
    table.append(''.join(random.choices(string.ascii_lowercase, k=16)))
14
​
15
​
16
def pad(data):
17
    pad_len = BLOCKSIZE - (len(data) % BLOCKSIZE) if  len(data) % BLOCKSIZE != 0 else 0
18
    return data + chr(pad_len) * pad_len
19
​
20
def enc(data,key):
21
    cipher = AES.new(key,AES.MODE_ECB)
22
    encrypt = cipher.encrypt(pad(data).encode())
23
    return encrypt
24
​
25
def task():
26
    try:
27
        key = os.urandom(16)
28
        secret = ''.join(random.choices(table, k=3))
29
        print(binascii.hexlify(enc(secret,key)))
30
        while True:
31
            opt = int(input())
32
            if opt == 1:
33
                v = random.choice(table)
34
                print(f'{v} -> {binascii.hexlify(enc(v,key)).decode()}')
35
            elif opt == 2:
36
                v = input("Plz input: ")
37
                if v == secret:
38
                    print(flag)
39
                exit(0)
40
    except Exception as e:
41
        pass
42
​
43
task()
分析
简单分析这段代码后，我们首先梳理一下题目交互逻辑：首先我们nc之后题目给我们一段加密字符串，这个字符串就是我们要解密的。即以下代码：

1
try:
2
        key = os.urandom(16)
3
        secret = ''.join(random.choices(table, k=3))
4
        print(binascii.hexlify(enc(secret,key)))
之后便进入while循环，我们输入1，服务器返回给我们一个明文及其对应的密文；输入2，我们输入字符串，服务器判断是否与secre相等，若相等给我们返回flag。

解题思路：

我们在拿到要破解的字符串之后，不断输入1，让服务器返回许多明文和密文的对应关系，并将该关系存入一个字典中，然后将secret中的每一部分与字典中的密文对比，若相等则从字典获取对应明文。当secret的三段都破解之后，将其输入2步骤中，拿到flag。

EXP
1
#kali中的nc环境
2
from pwn import *
3
p=remote('',)
4
s=p.recvline().strip()[2:-1]
5
m={}
6
count=3
7
secret=[0 for i in range(count)]
8
while True:
9
    p.sendline(b'1')
10
    plain,enc=p.recvline().strip().split(b'->')
11
    m[enc.strip()]=plain.strip()
12
    for i in range(count):
13
        if s[32*i:32*(i+1)]in m:
14
            secret[i]=m[s[32*i:32*(i+1)]]
15
    flag=True
16
    for i in secret:
17
        if i==0:
18
            flag =False
19
    if flag:break
20
p.snedline('2')
21
p.sendline(b''.join(secret))
22
p.interactive()
23
​
2.尾字节爆破
题目
1
from Crypto.Cipher import AES
2
import binascii
3
import os
4
flag = os.getenv('FLAG')
5
BLOCKSIZE = 16
6
​
7
def pad(data):
8
    pad_len = BLOCKSIZE - (len(data) % BLOCKSIZE) if  len(data) % BLOCKSIZE != 0 else 0
9
    return data + chr(pad_len) * pad_len
10
​
11
def enc(data,key):
12
    cipher = AES.new(key,AES.MODE_ECB)
13
    encrypt = cipher.encrypt(pad(data).encode())
14
    return encrypt
15
​
16
def task():
17
    try:
18
        key = os.urandom(16)
19
        while True:
20
            plaintext = input("Plz input: ")
21
            print(binascii.hexlify(enc(plaintext+flag,key)))
22
    except Exception as e:
23
        print(e)
24
​
25
task()
分析
我们看到代码：

1
def task():
2
    try:
3
        key = os.urandom(16)
4
        while True:
5
            plaintext = input("Plz input: ")
6
            print(binascii.hexlify(enc(plaintext+flag,key)))
7
    except Exception as e:
8
        print(e)
这段代码的功能我们经常成为oracle(预言机)。
从这段代码中我们分析加密逻辑：题目首先会生成一个key，之后进入while循环，由此我们知道在同一个nc环境中key是相同的。
在循环中我们首先输入字符串plaintext，服务器会返回plaintext+flag的加密结果，注意服务器返回的是plaintext+flag的整体加密结果，由此产生了尾字节爆破攻击的漏洞。

从题目知道16字节为一组。

尾字节爆破攻击：
我们假设flag为NSSCTF{xxxxx}
首先我们假设我们传入字符串‘0000000000000000’(16个’0’)，服务器返回的是enc(‘0000000000000000’+flag)，在这里16个‘0’已经满足一组，故不与flag进行拼接；
若我们传入15个‘0’，由于不满足一组16个，故会与flag的字符进行拼接之后再加密返回，即此时的第一组变成了’000000000000000N’,然后对此用key加密；第二组变成了‘SSCTF{xxxxx}…’对第二组用key加密；后面的组亦如此，最后返回给我们完整加密结果。
在这里我们便可以爆破flag的第一个字符N，后面的字符同理。

EXP
1
from pwn import *
2
from Crypto.Util.number import *
3
p=remote('',)
4
length=48
5
s='0'*(length-1)
6
flag=''
7
for i in range(length):
8
    p.sendlineafter("Plz input",s)
9
    res=p.recvuntil("\n")[:(length*2)]
10
    for j in range(32,127):
11
        tmp='0'*((length-1)-i)+flag+chr(j)
12
        p.sendlineafter("Plz input",tmp)
13
        res2 = p.recvuntil("\n")[:(length*2)]
14
        if res==res2:
15
            flag+=chr(j)
16
            s=s[:-1]
17
            break
OFB模式
image-20250604145039812

介绍
首先我们看到OFB模式实际上每一节加密又两个输出了image-20250604150559404

输出2是我们最终拿到的密文（解密同理）。

同时加密和解密都是加密函数。

1.字节反转攻击
题目
1
from Crypto.Cipher import AES
2
import os
3
import binascii
4
​
5
flag = os.getenv('FLAG')
6
BLOCKSIZE = 16
7
​
8
def pad(data):
9
    pad_len = BLOCKSIZE - (len(data) % BLOCKSIZE) if  len(data) % BLOCKSIZE != 0 else 0
10
    return data + b"=" * pad_len
11
​
12
def unpad(data):
13
    return data.replace(b"=",b"")
14
​
15
​
16
def enc(data,key,iv):
17
    cipher = AES.new(key,AES.MODE_OFB,iv)
18
    encrypt = cipher.encrypt(pad(data))
19
    return encrypt
20
​
21
​
22
def dec(data,key,iv):
23
    cipher = AES.new(key,AES.MODE_OFB,iv)
24
    encrypt = cipher.decrypt(data)
25
    return unpad(encrypt)
26
​
27
def task():
28
    try:
29
        key = os.urandom(16)
30
        iv = os.urandom(16)
31
        while True:
32
            choice = input(menu)
33
            if choice == '1':
34
                name = input("What's your name?")
35
                if name == 'admin':
36
                    exit()
37
                token = enc(name.encode(),key,iv)
38
                print(b"Token: " + binascii.hexlify(token))
39
            elif choice == '2':
40
                token = bytes.fromhex(input("Input token: "))
41
                name = dec(token,key,iv)
42
                print(b"Hello, " + name)
43
                if name == b'admin':
44
                    print(flag)
45
                    exit()
46
            else:
47
                exit()
48
    except Exception as e:
49
        exit()
50
menu=
51
1. register
52
2. login
53
3. exit
54
task()
分析
了解了OFB的加密模式之后我们可以知道，OFB加密模式每一节加密过程都与前面的加密结果（输出1）有关。
在此题中，每一节是16字节，而我们要拿到的明文’admin‘是5字节，也就是说在该题目中只涉及第一节，我们也就只用关心iv变量即可，倘若题目的明文超过了16字节我们可以参考CBC模式字节翻转攻击的题目2。

题目要求得到admin的token，但我们又不能直接输入admin。这时我们考虑字节翻转攻击

原理：

题目要求’admin‘

假设我们输入’bdmin‘,此时我们得到’bdmin‘的token值。我们只需要能够用这个token值来构造出admin的token就行了。

Ciphertext=Plaintext xor enc(key,iv)

Plaintext=Ciphertext xor enc(key,iv)

假设：’bdmin’ xor enc(key,iv)—>C1

正常解密：C1 xor enc(key,iv)—>‘bdmin’

攻击：我们最终是要将b变为a，那么我们只需要C1(第一个字节) xor enc(key,iv) (第一个字节) xor ‘b’ xor ‘a’即可得到一个新的token即对应admin.

解释先异或’b‘是因为我们知道结果要改变的字符是b,’b’ xor ‘b’ =0,在异或’a‘，得到我们需要的token。

EXP
hex(int(token[i*2:2+i*2], 16) ^ plaintext[i] ^ ord(m[i]))[2:]
1
from pwn import *
2
p=remote('node5.anna.nssctf.cn',23070)
3
#context.log_level = 'debug'  #debug模式
4
p.sendlineafter("exit","1")
5
p.sendline("abcde")
6
p.recvuntil("Token: ")
7
token=p.recvuntil('\n').strip().decode()[:-1]
8
p.sendlineafter("exit","2")
9
p.sendline(token)
10
payload=token
11
​
12
m='admin'
13
​
14
for i in range(5):
15
    p.recvuntil('Hello, ')
16
    plaintext=eval(b"b'"+p.recvuntil('\n'))
17
    payload=payload[:i*2]+hex(int(token[i*2:2+i*2], 16) ^ plaintext[i] ^ ord(m[i]))[2:] + token[2+i*2:]
18
    p.sendlineafter("exit", "2")
19
    p.sendline(payload)
20
​
21
print(p.recvall())
CBC模式
1.尾字节爆破
题目
1
from Crypto.Cipher import AES
2
import binascii
3
import os
4
flag = os.getenv('FLAG')
5
BLOCKSIZE = 16
6
​
7
def pad(data):
8
    pad_len = BLOCKSIZE - (len(data) % BLOCKSIZE) if  len(data) % BLOCKSIZE != 0 else 0
9
    return data + chr(pad_len) * pad_len
10
​
11
def enc(data,key,iv):
12
    cipher = AES.new(key,AES.MODE_CBC,iv)
13
    encrypt = cipher.encrypt(pad(data).encode())
14
    return encrypt
15
​
16
def task():
17
    try:
18
        key = os.urandom(16)
19
        iv = os.urandom(16)
20
        print(b'iv: ' + binascii.hexlify(iv))
21
        while True:
22
            plaintext = input("Plz input: ")
23
            if not plaintext: break
24
            print(binascii.hexlify(enc(plaintext+flag,key,iv)))
25
    except Exception as e:
26
        pass
27
​
28
task()
分析
依然还是尾字节爆破攻击，这里使用的是CBC分组模式，但是我们回想CBC加密模型

img

假设flag是NSSCTF{xxx}我们依然可以构造输入

000000000000000

这样拼接后得到

000000000000000N SSCTF{xxx}

此时我们再不断输入

1
000000000000000A
2
000000000000000B
3
...
4
000000000000000N
对比加密值，如果得到的和最开始输入的加密值相同则我们就得到了flag的第一位，对于第二位我们可以以此类推。

当flag大于16位，即大于一组时，我们依然使用我们在ECB中使用的方法，构造多组输入，比较多组密文即可。

EXP
1
from pwn import *
2
from Crypto.Util.number import *
3
p=remote('node4.anna.nssctf.cn',28481)
4
length=48
5
s='0'*(length-1)
6
flag=''
7
for i in range(length):
8
    p.sendlineafter("Plz input: ",s)
9
    res=p.recvuntil("\n")[:(length*2)]
10
    for j in b'NSSCTF{1234567890qwertyuiop}':
11
        tmp='0'*((length-1)-i)+flag+chr(j)
12
        p.sendlineafter("Plz input: ",tmp)
13
        res2=p.recvuntil("\n")[:(length*2)]
14
        if res==res2:
15
            flag+=chr(j)
16
            print(flag)
17
            s=s[:-1]
18
            break
2.字节翻转攻击
题目1
1
from Crypto.Cipher import AES
2
import os
3
import binascii
4
​
5
flag = os.getenv('FLAG')
6
BLOCKSIZE = 16
7
​
8
def pad(data):
9
    pad_len = BLOCKSIZE - (len(data) % BLOCKSIZE) if  len(data) % BLOCKSIZE != 0 else 0
10
    return data + b"=" * pad_len
11
​
12
def unpad(data):
13
    return data.replace(b"=",b"")
14
​
15
def enc(data,key,iv):
16
    cipher = AES.new(key,AES.MODE_CBC,iv)
17
    encrypt = cipher.encrypt(pad(data))
18
    return encrypt
19
​
20
def dec(data,key,iv):
21
    cipher = AES.new(key,AES.MODE_CBC,iv)
22
    encrypt = cipher.decrypt(data)
23
    return unpad(encrypt)
24
​
25
def task():
26
    try:
27
        key = os.urandom(16)
28
        iv = os.urandom(16)
29
        for i in range(2):
30
            choice = input(menu)
31
            if choice == '1':
32
                name = input("What's your name?")
33
                if name == 'admin':
34
                    exit()
35
                token = enc(name.encode(),key,iv)
36
                print(b"IV: " + binascii.hexlify(iv))
37
                print(b"Token: " + binascii.hexlify(token))
38
            elif choice == '2':
39
                iv = bytes.fromhex(input("Input IV: "))
40
                token = bytes.fromhex(input("Input token: "))
41
​
42
                if len(iv) != 16:
43
                    break
44
​
45
                name = dec(token,key,iv)
46
                print(b"Hello, " + name)
47
                if name == b'admin':
48
                    print(flag)
49
                    exit()
50
            else:
51
                exit()
52
    except Exception as e:
53
        exit()
54
​
55
menu=
56
1. register
57
2. login
58
3. exit
59
​
60
task()
分析
可参考OFB的字节翻转攻击。

EXP
1
from pwn import *
2
import binascii
3
​
4
p = remote("node4.anna.nssctf.cn", 28663)
5
​
6
context.log_level = 'debug'
7
​
8
plaintext = b"abcde"
9
​
10
p.sendlineafter(b"exit", b"1")
11
p.sendline(plaintext)
12
​
13
p.recvuntil(b"IV: ")
14
iv = p.recvuntil(b'\n').strip().decode()[:-1]
15
​
16
p.recvuntil(b"Token: ")
17
token = p.recvuntil(b'\n').strip().decode()[:-1]
18
​
19
m = b'admin'
20
​
21
def strxor(token):
22
    s = list(bytes.fromhex(token))
23
    for i in range(len(m)):
24
        s[i] = s[i]^plaintext[i]^m[i]
25
    return bytes(s)
26
​
27
iv = strxor(iv)
28
​
29
p.sendlineafter(b"exit", b"2")
30
p.sendlineafter(b"Input IV: ", binascii.hexlify(iv))
31
p.sendlineafter(b"Input token: ", token)
32
​
33
p.interactive()
题目2
-
1
from Crypto.Cipher import AES
2
import os
3
import binascii
4
​
5
flag = os.getenv('FLAG')
6
BLOCKSIZE = 16
7
​
8
def pad(data):
9
    pad_len = BLOCKSIZE - (len(data) % BLOCKSIZE) if  len(data) % BLOCKSIZE != 0 else 0
10
    return data + b"=" * pad_len
11
​
12
def unpad(data):
13
    return data.replace(b"=",b"")
14
​
15
​
16
def enc(data,key,iv):
17
    cipher = AES.new(key,AES.MODE_CBC,iv)
18
    encrypt = cipher.encrypt(pad(data))
19
    return encrypt
20
​
21
​
22
def dec(data,key,iv):
23
    cipher = AES.new(key,AES.MODE_CBC,iv)
24
    encrypt = cipher.decrypt(data)
25
    return unpad(encrypt)
26
​
27
def task():
28
    try:
29
        key = os.urandom(16)
30
        iv = os.urandom(16)
31
        for i in range(4):
32
            choice = input(menu)
33
            if choice == '1':
34
                name = input("What's your name?")
35
                if 'q' in name:
36
                    exit()
37
                token = enc(name.encode(),key,iv)
38
                print(b"IV: " + binascii.hexlify(iv))
39
                print(b"Token: " + binascii.hexlify(token))
40
            elif choice == '2':
41
                iv = bytes.fromhex(input("Input IV: "))
42
                token = bytes.fromhex(input("Input token: "))
43
​
44
                if len(iv) != 16:
45
                    break
46
​
47
                name = dec(token,key,iv)
48
                print(b"Hello, " + name)
49
                if name == b'qwertyuiopasdfghqwertyuiopasdfghqwertyuiopasdfgh':
50
                    print(flag)
51
                    exit()
52
            else:
53
                exit()
54
    except Exception as e:
55
        exit()
56
​
57
menu=
58
1. register
59
2. login
60
3. exit
61
​
62
task()
分析
我们看到这次的字符数明显超过16字节，也就是多组。

EXP
1
from pwn import *
2
​
3
context.log_level = 'debug'
4
​
5
p = remote("node4.anna.nssctf.cn", 28145)
6
​
7
​
8
def register(name):
9
    p.sendlineafter("exit", "1")
10
    p.sendline(name)
11
    p.recvuntil(b"IV: ")
12
    iv = bytes.fromhex(p.recvline().strip().decode()[:-1])
13
    p.recvuntil("Token: ")
14
    token = bytes.fromhex(p.recvline().strip().decode()[:-1])
15
    return iv, token
16
​
17
​
18
def login(iv, token):
19
    p.sendlineafter("exit", "2")
20
    p.sendlineafter(b"Input IV: ", binascii.hexlify(iv))
21
    p.sendlineafter(b"Input token: ", binascii.hexlify(token))
22
    p.recvuntil('Hello, ')
23
    plain = eval(b"b'" + p.recvline())
24
    return plain
25
​
26
​
27
plain = b"awertyuiopasdfghawertyuiopasdfghawertyuiopasdfgh"
28
target = b"qwertyuiopasdfghqwertyuiopasdfghqwertyuiopasdfgh"
29
​
30
iv, token = register(plain)
31
​
32
​
33
def strxor(token, plain, target):
34
    s = list(token)
35
    for i in range(len(target)):
36
        s[i] = s[i] ^ plain[i] ^ target[i]
37
    return bytes(s)
38
​
39
​
40
for i in range(3, 0, -1):
41
    if i == 1:
42
        iv = strxor(iv, plain[:16], target[:16])
43
    else:
44
        payload = strxor(token[16 * (i - 2):16 * (i - 1)], plain[16 * (i - 1):16 * i], target[16 * (i - 1):16 * i])
45
        token = token[:16 * (i - 2)] + payload + token[16 * (i - 1):]
46
​
47
    plain = login(iv, token)
48
p.interactive()
MISC
爆破与文件分离
文件分离
1：010editor看到zip（50 4B）截取zip片段分离

2：随波逐流将文件拖入，binwalk，foremost分离

3：kali在终端分离（binwalk：binwalk 文件名 -e）

爆破
在排除伪加密之后可以使用ARCHPR爆破

ZIP文件在16进制编辑器中的样子
压缩源文件数据区（通常在16进制编辑器的开头）
50 4B 03 04：头文件标记

14 00：解压文件所需pkware版本

00 00：全局方位式标记（有无加密，第一个00为奇数则有加密如：09，加密后一般为09 00）

08 00：压缩方式

5A 7E：最后修改文件时间

F7 46：最后修改文件日期

压缩源文件目录区（通常在16进制编辑器接近末尾）
50 4B 01 02：目录中文件文件头标记

3F 00：压缩使用的pkware版本

14 00：解压文件所需pkware版本

00 00：全局方位式标记（有无加密，一般在此修改进行伪加密，改为09 00打开就会提示有密码）

08 00：压缩方式

5A 7E：最后修改文件时间

F7 46：最后修改文件日期

压缩源文件目录结束标志（通常在16进制编辑器结尾）
50 4B 05 06：目录结束标记

00 00：当前磁盘编号

00 00：目录区开始磁盘编号

01 00：本磁盘上记录总数

01 00：目录区记录总数

明文攻击与合并
传统明文攻击
当我们已经有一张图片和压缩包（未解密）里面的一张图片相同时（对比大小，crc值），且加密算法是ZipCrypto Store时，可以使用传统明文攻击，将已有的图片采用ZipCrypto Store压缩算法（利用7-zip压缩时可以选择为ZipCrypto）压缩为压缩包，再利用ARCHPR破解。
![image-20250121014456814](../../AppData/Roaming/Typora/typora-user-images/image-20250121014456814.png)

传统明文攻击：

1.完整的明文文件

2.被相同压缩工具压缩

3.加密算法为ZipCrypto Store

zip加密算法有四种：

1.ZipCrypto Deflate

2.ZipCrypto Store

3.AES-256 Deflate

4.AES-256 Store

深度明文攻击
已知加密压缩包中的少部分明文字节就可以实现攻击
要求：

		已知明文的12个字节及偏移，8字节或者以上连续。

		加密方式为ZipCrypto Store

利用PNG头+一些内容的部分明文攻击
使用工具查看压缩包信息
![image-20250121020910575](../../AppData/Roaming/Typora/typora-user-images/image-20250121020910575.png)

例题1
现有一加密文件flag.zip，密码没有爆破出来。

步骤：

1.用bkcrack看一下，发现使用ZipCrypto加密

（注：在进行深度明文攻击时，压缩包要采用 ZipCrypto 类（如 Store）算法）

bkcrack -L "文件地址"
![image-20250309170622244](../../AppData/Roaming/Typora/typora-user-images/image-20250309170622244.png)

2.使用明文攻击，但是发现并没有什么明文，所以这里就需要自己构造一个明文，用png文件的头(89504E470D0A1A0A0000000D49484452)就可以构造一张1.png的图片

3.再攻击

./bkcrack -C "文件地址" -c flag.png -p "构造的文件地址" 
4.得到key代入

./bkcrack -C "文件地址" -c flag.png -k 29d29517 0fa535a9 abc67696 -d "新文件地址"
合并
有时我们得到文件如下面时：
我们可以使用7-zip合并文件
![image-20250121021231406](../../AppData/Roaming/Typora/typora-user-images/image-20250121021231406.png)

合并结果：

![image-20250121021312071](../../AppData/Roaming/Typora/typora-user-images/image-20250121021312071.png)

掩码和进制翻转运算
掩码攻击
当我们已经知道压缩包密码的部分内容时可以使用ARCHPR工具选择掩码攻击（未知部分用“?”代替）

例如密码部分内容为NSSCTFXXX（XXX为未知部分），便可使用掩码攻击。
![image-20250121000907845](../../AppData/Roaming/Typora/typora-user-images/image-20250121000907845.png)

字典
在ARCHPR中我们也可以自己编写典，简单python代码生成字典如下：

with open("a.txt", "w") as f:
for i in range(1000):
  a = "NSSCTF" + str(i).zfill(3)  //zfill表示不足时补零
  f.write(a + "\n")
进制翻转运算
我们有时利用16进制编辑器（如010editor）时，对16进制内容没有思路，也不是其他文件的文件头或文件无法正常打开时，可以考虑利用010editor的“向左旋转”，“向右旋转”.
![image-20250121002906262](../../AppData/Roaming/Typora/typora-user-images/image-20250121002906262.png)

如上述16进制内容在向右旋转一次后，变成了一个正常的zip文件，如下：
![image-20250121003126865](../../AppData/Roaming/Typora/typora-user-images/image-20250121003126865.png)

CRC爆破
CRC校验实用程序库，应用于数据存储和数据通讯领域，是为了保证数据的正确采用的检错手段。CRC是最著名的验错手段之一。CRC的全称是循环冗余校验。

每个文件都有唯一的CRC32值，即便数据中一个bit发生变化，也会导致CRC32值不同。若是知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但通常只适用于较小文本文件。比如这里有一个加密的rar，直接双击就可以看见其中信息，而且我知道其中全是数字，便可写脚本爆破。

在不确定内容时，可以找工具使用.

简单编写脚本如下：

//纯数字
from zlib import crc32
import random

char = '0123456789'

def crc32_f(data):
    return hex(crc32(data.encode()) & 0xffffffff)[2:10]

length = int(input('请输入长度：'))
crc32_input = input('请输入 CRC32 值：').lower()

while True:
    text = ''.join(random.choice(char) for _ in range(length))
    if crc32_f(text) == crc32_input:
        input('找到匹配值：' + text)
        exit()
字符长度很小，有CRC值且不知道密码，使用CRC校验：
![image-20250121005450212](../../AppData/Roaming/Typora/typora-user-images/image-20250121005450212.png)

得到要求的数字：
![image-20250121005518634](../../AppData/Roaming/Typora/typora-user-images/image-20250121005518634.png)

rar伪加密
1.rar伪加密（rar4）
RAR的伪加密与zip的伪加密类似，都作用在一个位标记字段。
修改该值为0，就可解除伪加密。
![image-20250121013505319](../../AppData/Roaming/Typora/typora-user-images/image-20250121013505319.png)

2.rar4和rar5的区别
一、压缩算法的改变（AES-256 算法，理论上比 RAR 4.x 的 AES-128压缩能力更强 ）

二、更高的压缩率和较慢的速度

三、压缩率更高

四、文件存储时间不同

五、rar5不可用上述方法实现伪加密破解

音频隐写
DeepSound
1.普通隐写
解释：在音频文件里面，写入了其它的文件，比如flag.txt，也可以是图片等等，此时可以用deepsound去进行进行解密，此过程中可能还需要找到密钥才能解密，deepsound隐写的内容更多是基于LSB算法

步骤如下：

1.打开文件输入密码：

![image-20250309164932757](../../AppData/Roaming/Typora/typora-user-images/image-20250309164932757.png)

2.提取出隐写的文件

![image-20250309165003968](../../AppData/Roaming/Typora/typora-user-images/image-20250309165003968.png)

MP3隐写
工具：MP3Stego

步骤：

# 隐藏信息
# —E 读取隐藏信息文件的内容，-P 设置密码
encode.exe -E hidden_text.txt -P pass svega.wav svega_stego.mp3
# 解密信息
decode.exe -X svega_stego.mp3 -P pass
简单镜像提取
R-Studio工具

ZIP多层嵌套提取
例题：
给了一个不断嵌套的zip和password.txt，password.txt内容转base64就可以就解出期内的文件.

1
import zipfile
2
import base64
3
import os
4
 
5
def extract_zip_with_password(zip_filename, password):
6
    try:
7
        with zipfile.ZipFile(zip_filename, 'r') as zf:
8
            zf.extractall(pwd=password.encode())
9
            print(f"解压成功: {zip_filename}")
10
            return True
11
    except RuntimeError as e:
12
        print(f"解压失败: {zip_filename} - {e}")
13
    except zipfile.BadZipFile:
14
        print(f"无效的 ZIP 文件: {zip_filename}")
15
    return False
16
 
17
def main(start_number=99):
18
    current_number = start_number
19
    while True:
20
        ##################修改这里####################
21
        zip_filename = f"zip_{current_number}.zip"
22
        ##################修改这里####################
23
        password_filename = f"password_{current_number}.txt"
24
        if not (os.path.exists(zip_filename) and os.path.exists(password_filename)):
25
            print(f"文件不存在，停止处理: {zip_filename} 或 {password_filename}")
26
            break
27
        print(f"处理文件: {zip_filename} - {password_filename}")
28
        try:
29
            with open(password_filename, 'r') as pf:
30
                encoded_password = pf.read().strip()
31
                password = base64.b64decode(encoded_password).decode('utf-8')
32
        except Exception as e:
33
            print(f"读取或解码密码失败: {password_filename} - {e}")
34
            break
35
        if extract_zip_with_password(zip_filename, password):
36
            current_number -= 1
37
        else:
38
            print(f"解压失败，停止处理: {zip_filename}")
39
            break
40
 
41
if __name__ == "__main__":
42
    main(99)  # 明确指定从99开始
这一步可以提取出嵌套的zip和txt文档。

紧接着我们又发现：每一个password.txt的内容合起来是一个16进制的png图片。在写一段脚本，读取每一个txt文档，再将内容合并。

import os
import base64
from PIL import Image
from io import BytesIO
 
 
# 写到文件
def hex_string_to_file(hex_string, output_file):
    try:
        hex_string = hex_string.strip()
        if len(hex_string) % 2!= 0:
            raise ValueError("无法解析")
        binary_data = bytes.fromhex(hex_string)
        with open(output_file, "wb") as file:
            file.write(binary_data)
        print(f"成功写入：{output_file}")
    except Exception as e:
        print(f"错误：{e}")
 
 
def main():
    concatenated_content = b""
    for i in range(96):
        ##################修改这里####################
        filename = f"password_{i}.txt"
        if os.path.exists(filename):
            with open(filename, "r", encoding="utf-8") as file:
                encoded_content = file.read().strip()
                try:
                    # 解码密码
                    decoded_content = base64.b64decode(encoded_content)
                    concatenated_content += decoded_content
                except Exception as e:
                    print(f"解码失败：{e}")
    print(concatenated_content)
    hex_string_to_file(concatenated_content.hex(), "Output.png")
 
 
if __name__ == "__main__":
    main()
Excel表
Excel表本质上是一个zip压缩包，我们可以将excel的后缀直接修改为zip，看到一些其他的文件。

有的题目在压缩包里面有一个无名文件，这时候我们要考虑在linux系统进行操作。（windows无法执行空白文件）

题型
Rabbit加解密
Rabbit加密技术，又称作兔子加密，是一种基于对称密钥的加密算法。其核心思想是将明文或密文转化为一个固定长度的比特串，通过加密密钥对比特串进行加密，实现信息的安全传输。其密文R开头部分通常为U2FsdGVkX1

例题[FSCTF 2023]兔帽的奇妙冒险 | NSSCTF
有一只名叫贝斯64先生的兔子。它戴着一顶古老的兔帽子，帽子上绣着奇异的符文，传说这是一种能与神秘力量连接的魔法帽子。
OFR3c05RTEFKM2Q3QkxqRGlTbWthWExxSXhrZFo3SU5DVWRkOTVFQ2JUSE1VcXpRQk9hc3hqMzRrbHRJMD0=
使用base64解码后得到：

8TwsNQLAJ3d7BLjDiSmkaXLqIxkdZ7INCUdd95ECbTHMUqzQBOasxj34kltI0=
再看到题目描述，想到Rabbit加解密，但不符合Rabbit的密文特征，故我们手动添加开头，利用网站进行解密：在线Rabbit加密 | Rabbit解密- 在线工具

U2FsdGVkX18TwsNQLAJ3d7BLjDiSmkaXLqIxkdZ7INCUdd95ECbTHMUqzQBOasxj34kltI0=
得到：

FSCTF{Bunny_is_so_cute_Why_e@t_bunny}
逐项相减取ASCLL码
题目
781612443113954655886887407898899451044114412011257135914071455155316031651170318041861191719652013207021272183228423832485254125932643269827992924
题目给了一串数字，经过随波逐流的各种解码没有结果，后来看wp发现这是一个递增序列，逐项相减取ASCLL码。

EXP
# 781612443113954655886887407898899451044114412011257135914071455155316031651170318041861191719652013207021272183228423832485254125932643269827992924
str = "1612443113954655886887407898899451044114412011257135914071455155316031651170318041861191719652013207021272183228423832485254125932643269827992924"
ls = [0, 78]  # 前补0方便加密，把第一个78加进来方便分割
s = ""
for ch in str:
    s += ch
    if int(s) > ls[-1]:  # 因为是前缀和，取第一个比前一个大的数即可
        ls.append(int(s))
        s = ""
flag = ""
for i in range(len(ls) - 1):
    flag += chr(ls[i + 1] - ls[i])
print(flag)
0和255(二维数组还原为图片)
题目：
附件1：image_list.py

# -*- coding = utf-8 -*-
# @software:PyCharm
from PIL import Image
image = Image.open('flag.png')   #flag.png分辨率为33*33
width = image.width
height = image.height
image_list = []
for x in range(height):
    scanline_list = []
    for y in range(width):
        pixel = image.getpixel((y, x))
        scanline_list.append(pixel)
    image_list.append(scanline_list)
print(image_list)
附件2：image_list.txt

1
[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 0, 255, 255, 0, 255, 0, 0, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 0, 0, 255, 255, 0, 0, 0, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 0, 0, 255, 0, 0, 255, 0, 0, 0, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 0, 255, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 255, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 255, 0, 0, 255, 0, 0, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 255, 255, 255, 0, 255, 255, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 0, 255, 255, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 0, 0, 255, 255, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 0, 255, 255, 0, 0, 255, 0, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 0, 255, 255, 0, 0, 255, 255, 255, 0, 255, 0, 0, 0, 0, 255, 0, 0, 255, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 0, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 255, 0, 0, 255, 255, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 255, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 255, 0, 255, 255, 255, 0, 0, 255, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 0, 255, 0, 255, 0, 255, 255, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255, 255, 255, 0, 255, 0, 0, 0, 0, 255, 255, 255, 0, 255, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 255, 0, 0, 255, 0, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255, 255, 0, 255, 0, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255, 0, 255, 0, 0, 255, 255, 0, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]
分析
经过分析我们知道附件1的作用是：将图片的像素数据转换为一个可以程序处理的二维数组结构，便于后续的图像分析或处理。

而附件2就是转化之后的二维数组，我们将二维数组还原为图片即可。

EXP
1
from PIL import Image
2
​
3
# 假设你的像素数据是这样的（示例）
4
pixel_data = [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 255, 0, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 0, 255, 255, 0, 255, 0, 0, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 0, 0, 255, 255, 0, 0, 0, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 0, 0, 255, 0, 0, 255, 0, 0, 0, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 0, 255, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 255, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 0, 255, 255, 255, 0, 0, 255, 0, 0, 0, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 255, 255, 255, 0, 255, 255, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 0, 255, 255, 0, 255, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 255, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 0, 0, 255, 255, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 0, 255, 255, 0, 0, 255, 0, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 0, 255, 255, 0, 0, 255, 255, 255, 0, 255, 0, 0, 0, 0, 255, 0, 0, 255, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 0, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 255, 0, 0, 255, 255, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 255, 255, 255, 0, 255, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 255, 0, 0, 255, 0, 255, 255, 255, 0, 0, 255, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 255, 255, 0, 255, 0, 255, 0, 255, 255, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255, 255, 255, 0, 255, 0, 0, 0, 0, 255, 255, 255, 0, 255, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255, 0, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 0, 255, 255, 255, 0, 0, 255, 255, 255, 0, 255, 0, 0, 255, 0, 0, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255, 255, 0, 255, 0, 255, 255, 255, 0, 255, 0, 0, 0, 255, 0, 255, 255, 255, 255], [255, 255, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255, 0, 255, 0, 0, 255, 255, 0, 255, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 0, 0, 0, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]
5
​
6
# 获取图片的尺寸（行数 x 列数）
7
height = len(pixel_data)
8
width = len(pixel_data[0]) if height > 0 else 0
9
​
10
# 创建一个新的RGB图像
11
new_image = Image.new("RGB", (width, height))
12
​
13
# 遍历每个像素并填充
14
for y in range(height):
15
    for x in range(width):
16
        new_image.putpixel((x, y), pixel_data[y][x])
17
​
18
# 保存图片
19
new_image.save("output.png")
20
print("图片已保存为 output.png")
01
题目
1
1111111011111001001111111
2
1000001000000001101000001
3
1011101000100010101011101
4
1011101010011110001011101
5
1011101001110010101011101
6
1000001000111001001000001
7
1111111010101010101111111
8
0000000000110001000000000
9
0010111011011101010001001
10
1110100111100111010101001
11
0110001100010000110111011
12
0000100100001010111100010
13
0001001111110100110001001
14
0001000110000101110101010
15
1001111000010111101011011
16
0101010001010010100000010
17
1001001011100111111111001
18
0000000011011100100010001
19
1111111001100010101011011
20
1000001011111001100011000
21
1011101011001010111111000
22
1011101000001110010111010
23
1011101011001000111110101
24
1000001001101001001110010
25
1111111000010001000011011
分析
从给定的25行字符串数据生成一个25×25的QR二维码，并放大显示以便识别。

EXP
1
from PIL import Image
2
​
3
# 输入的25行数据（每行代表QR码的一行）
4
qr_data = [
5
    "1111111011111001001111111",
6
    "1000001000000001101000001",
7
    "1011101000100010101011101",
8
    "1011101010011110001011101",
9
    "1011101001110010101011101",
10
    "1000001000111001001000001",
11
    "1111111010101010101111111",
12
    "0000000000110001000000000",
13
    "0010111011011101010001001",
14
    "1110100111100111010101001",
15
    "0110001100010000110111011",
16
    "0000100100001010111100010",
17
    "0001001111110100110001001",
18
    "0001000110000101110101010",
19
    "1001111000010111101011011",
20
    "0101010001010010100000010",
21
    "1001001011100111111111001",
22
    "0000000011011100100010001",
23
    "1111111001100010101011011",
24
    "1000001011111001100011000",
25
    "1011101011001010111111000",
26
    "1011101000001110010111010",
27
    "1011101011001000111110101",
28
    "1000001001101001001110010",
29
    "1111111000010001000011011"
30
]
31
​
32
# QR码尺寸（25x25）
33
size = len(qr_data)
34
​
35
# 创建一个新的黑白图像（1-bit模式）
36
img = Image.new("1", (size, size))
37
​
38
# 填充像素
39
for y in range(size):
40
    row = qr_data[y]
41
    for x in range(size):
42
        pixel = int(row[x])  # '1' 是黑色，'0' 是白色
43
        img.putpixel((x, y), pixel)
44
​
45
# 放大图片（否则25x25太小看不清）
46
scale = 20  # 放大倍数
47
img = img.resize((size * scale, size * scale), Image.NEAREST)
48
​
49
# 保存图片
50
img.save("qr_code.png")
51
print("二维码已生成：qr_code.png")
