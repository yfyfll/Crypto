# 浅谈RC4加密原理

## 基本原理（Rivest Cipher 4）

RC4开发时间1987年，稍晚于RSA。

RC4属于对称密码算法中的流密码加密算法。

密钥长度可变，面向字节操作，即可以给任意位数的密钥。

它以一个足够大的表S为基础，对表进行非线性变换，产生密钥流。



对称密码：加密和解密使用同一个密钥，异或运算。

![image-20241113203739872](https://raw.githubusercontent.com/yfyfll/typora/main/img2202505281041371.png)

> 流密码：以bit(位)为单位进行加密的，并非以一个字节为单位进行加密。
>
> 块加密（分组加密）：先将明文切分成一个个固定大小的块，再对每个块进行加密，这种方式被称为分组加密或块加密，有的资料称呼为"分组密码"或"块密码"。

模运算：模的概念：

> 模运算是一种算术运算，常写作a mod n，表示整数a除以正整数n后的余数。
> 模数是模运算中的除数n，它决定了结果的范围。
> 公式表达：
>
> 对于任意整数a和正整数n，可以将a表示为：a = qn + r，其中0 ≤ r < n，q是整数商，即q = ⌊a/n⌋。
> a除以n的余数是a mod n。
> 示例：
> 11 mod 7 = 4（11除以7的余数是4）
> -11 mod 7 = 3（-11除以7的余数是3）
>
> 同余关系
> 同余的定义：当两个整数a和b除以同一个正整数n得到相同的余数时，称a和b模n同余。
> 表达式为a ≡ b (mod n)。
>
> 
>
> 同余的性质：
> 如果a mod n与b mod n的结果相同，那么a ≡ b (mod n)。
> 如果a = 0 (mod n)，则n整除a（n是a的因子）。
>
> 模运算规则：
>
> - `(a + b) mod n = [(a mod n) + (b mod n)] mod n`
> - `(a - b) mod n = [(a mod n) - (b mod n)] mod n`
> - `(a * b) mod n = [(a mod n) * (b mod n)] mod n`

## 加密过程

一：初始化S表
Step1:对S表进行线性填充，一般为256个字节:
Step2:用种子密钥填充另一个256字节的T表;
Step3:用T表对S表进行初始置换

初始化赋值：

```c
for(i=0;i<256;i++)
{
	S[i]=i;
	T[i]=K[i mod keylen];#引入数组K，为密钥K，可以用户自定。
}
```

置换，用T产生S的初始置换

```c
j=0;
for i=0 to 255 do
	j=(j+S[i]+T[i])mod 256;
	Swap(S[i],S[j]);
```

二：密钥流的生成(为每个待加密的字节生成一个伪随机数，用来异或)
注:表S一旦完成初始化，种子密钥就不再被使用。

得到密钥流K并开始加密

```c
i=j=0;
for(h=0;h<datalen;h++)#h为明文长度
{	
	i=(i+1)mod 256;
	j=(j+S[i])mod 256;
	swap(S[i],S[j]);
	t=(S[i}+S[j])mod 256;
	k=S[t];#密钥流K
	D[h]^=k;#加密
}
```

解密过程：

```c
i=j=0;
for(h=0;h<datalen;h++)
{
	i=(i+1)mod 256;
	j=(j+S[i])mod 256;
	swap(s[i],s[j]);
	t=(S[i]+S[j])mod 256;
	k=S[t];
	SD[h]^=k;
}
```







