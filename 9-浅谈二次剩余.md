# 9-二次剩余

## 二次剩余定义：

$$
x^2\equiv a \pmod n
$$

给定a求是否有x满足这个式子，若有则称a是模p的二次剩余；若没有满足条件的x，则称a是模p的非二次剩余。

## 探讨

p为奇素数的情况（p=2时没有意义），对于一个数a，如果我们要求$\sqrt{a} \pmod p$ ,若n为p的二次剩余，那么很明显$\sqrt a \pmod p=x \pmod p$简单地说，如果该二次同余方程有解，那么a可以在模p的情况下开根号。

## 二次同余方程求解

### 勒让德符号$\left( \frac{a}{p} \right)$:表示a是否为p的二次剩余，1和-1分别表示是与否，0表示a为0的情况

$$
\left( \frac{a}{p} \right)= \begin{cases}
1，a是p的二次剩余 \\
-1，a是p的二次非剩余 \\
0，a \equiv 0 \pmod p
\end{cases}
$$





## 定理1

$\left( \frac{a}{p} \right)=a^ \frac{p-1}{2} \pmod n$

也就是说如果知道了a和p的值相当于知道了这个符号的值

## 定理2

$ (p-1)! \equiv -\left( \frac{a}{p} \right)a^\frac{p-1}{2} \pmod p$

### 威尔逊定理：$ (p-1)!\equiv -1 \pmod p$

#### 推论1：$\left( \frac{a}{p} \right)\equiv a^\frac{p-1}{2} \pmod p$

#### 推论2：$ \left(\frac{-1}{p} \right)=(-1)^\frac{p-1}{2}$,当p为4n+1型时，-1是二次剩余；p为4n+3型时，-1是二次非剩余

### 推论3：若a,b是两个互素的正整数，则$a^2+b^2$的素因子都是4n+1型的





## 例题

```python
from Crypto.Util.number import *
from shin import flag


m=bytes_to_long(flag)
r=getPrime(1024)
assert r%4==3
p=getPrime(1024)
assert pow(p,(r-1)//2,r)==1
q=getPrime(1024)
e=65537
n=p*q
a=pow(p,2,r)
c=pow(m,e,n)
print(f"n = {n}")
print(f"r = {r}")
print(f"a = {a}")
print(f"c = {c}")
'''
n = 14859096721972571275113983218934367817755893152876205380485481243331724183921836088288081702352994668073737901001999266644597320501510110156000004121260529706467596723314403262665291609405901413014268847623323618322794733633701355018297180967414569196496398340411723555826597629318524966741762029358820546567319749619243298957600716201084388836601266780686983787343862081546627427588380349419143512429889606408316907950943872684371787773262968532322073585449855893701828146080616188277162144464353498105939650706920663343245426376506714689749161228876988380824497513873436735960950355105802057279581583149036118078489
r = 145491538843334216714386412684012043545621410855800637571278502175614814648745218194962227539529331856802087217944496965842507972546292280972112841086902373612910345469921148426463042254195665018427080500677258981687116985855921771781242636077989465778056018747012467840003841693555272437071000936268768887299
a = 55964525692779548127584763434439890529728374088765597880759713360575037841170692647451851107865577004136603179246290669488558901413896713187831298964947047118465139235438896930729550228171700578741565927677764309135314910544565108363708736408337172674125506890098872891915897539306377840936658277631020650625
c = 12162333845365222333317364738458290101496436746496440837075952494841057738832092422679700884737328562151621948812616422038905426346860411550178061478808128855882459082137077477841624706988356642870940724988156263550796637806555269282505420720558849717265491643392140727605508756229066139493821648882251876933345101043468528015921111395602873356915520599085461538265894970248065772191748271175288506787110428723281590819815819036931155215189564342305674107662339977581410206210870725691314524812137801739246685784657364132180368529788767503223017329025740936590291109954677092128550252945936759891497673970553062223608
'''

```



### 分析

由代码$ a=p^2 \pmod r$其中a和r已知，固可以求出P，且p有两个值满足$p1+p2=r$.

利用sagemath解出p

```sagemath
r = 145491538843334216714386412684012043545621410855800637571278502175614814648745218194962227539529331856802087217944496965842507972546292280972112841086902373612910345469921148426463042254195665018427080500677258981687116985855921771781242636077989465778056018747012467840003841693555272437071000936268768887299
a = 55964525692779548127584763434439890529728374088765597880759713360575037841170692647451851107865577004136603179246290669488558901413896713187831298964947047118465139235438896930729550228171700578741565927677764309135314910544565108363708736408337172674125506890098872891915897539306377840936658277631020650625
R.<x>=PolynomialRing(Zmod(r))
f=(x^2)-a
ans=f.roots()
print(ans)
```



解出p后在由$q=n//p$,得到q.剩下的正常RSA解题步骤。

```python
from Crypto.Util.number import *
n = 14859096721972571275113983218934367817755893152876205380485481243331724183921836088288081702352994668073737901001999266644597320501510110156000004121260529706467596723314403262665291609405901413014268847623323618322794733633701355018297180967414569196496398340411723555826597629318524966741762029358820546567319749619243298957600716201084388836601266780686983787343862081546627427588380349419143512429889606408316907950943872684371787773262968532322073585449855893701828146080616188277162144464353498105939650706920663343245426376506714689749161228876988380824497513873436735960950355105802057279581583149036118078489
c = 12162333845365222333317364738458290101496436746496440837075952494841057738832092422679700884737328562151621948812616422038905426346860411550178061478808128855882459082137077477841624706988356642870940724988156263550796637806555269282505420720558849717265491643392140727605508756229066139493821648882251876933345101043468528015921111395602873356915520599085461538265894970248065772191748271175288506787110428723281590819815819036931155215189564342305674107662339977581410206210870725691314524812137801739246685784657364132180368529788767503223017329025740936590291109954677092128550252945936759891497673970553062223608
e=65537
p=135098300162574110032318082604507116145598393187097375349178563291884099917465443655846455456198422625358836544141120445250413758672683505731015242196083913722084539762488109001442453793004455466844129788221721833309756439196036660458760461237225684006072689852654273913614912604470081753828559417535710077291
q=n//p
d=inverse(e,n-p-q+1)
m=pow(c,d,n)
print(long_to_bytes(m))
```

